Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> begin
Rule 1     begin -> BEGIN OPAREN ID CPAREN classDef fxDef main end
Rule 2     main -> MAIN OPAREN CPAREN OBRACKET body CBRACKET
Rule 3     fxDef -> VOID FX ID OPAREN param CPAREN OBRACKET body CBRACKET fxDef
Rule 4     fxDef -> simpleType FX ID OPAREN param CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef
Rule 5     fxDef -> epsilon
Rule 6     param -> simpleType ID
Rule 7     param -> simpleType ID COMMA param
Rule 8     param -> epsilon
Rule 9     paramCall -> ID
Rule 10    paramCall -> ID COMMA paramCall
Rule 11    paramCall -> epsilon
Rule 12    voidCall -> ID OPAREN paramCall CPAREN EOF
Rule 13    body -> varsDef body
Rule 14    body -> statements body
Rule 15    body -> epsilon
Rule 16    statements -> assignmentDef
Rule 17    statements -> input
Rule 18    statements -> output
Rule 19    statements -> voidCall
Rule 20    statements -> whileCycle
Rule 21    statements -> ifCond
Rule 22    statements -> classCall
Rule 23    varsDef -> VAR objType var EOF
Rule 24    varsDef -> VAR simpleType var EOF
Rule 25    var -> varsType
Rule 26    var -> varsType COMMA var
Rule 27    varsType -> ID
Rule 28    varsType -> arrDef
Rule 29    varsType -> matrixDef
Rule 30    arrDef -> ID OSQUAREBR varCte CSQUAREBR
Rule 31    matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR
Rule 32    assignmentDef -> ID ASSIGNMENT expAssignment
Rule 33    expAssignment -> expRelational EOF
Rule 34    expAssignment -> returnCall EOF
Rule 35    expAssignment -> classCall
Rule 36    returnCall -> ID OPAREN paramCall CPAREN
Rule 37    expRelational -> plusMinus
Rule 38    expRelational -> plusMinus opRelational expRelational
Rule 39    opRelational -> EQUAL
Rule 40    opRelational -> DIFFERENT
Rule 41    opRelational -> GREATERTHAN
Rule 42    opRelational -> GREATERTHANEQ
Rule 43    opRelational -> LESSTHAN
Rule 44    opRelational -> LESSTHANEQ
Rule 45    plusMinus -> multDiv
Rule 46    plusMinus -> multDiv PLUS plusMinus
Rule 47    plusMinus -> multDiv MINUS plusMinus
Rule 48    multDiv -> expParen
Rule 49    multDiv -> expParen MULTIPLY multDiv
Rule 50    multDiv -> expParen DIVIDE multDiv
Rule 51    expParen -> OPAREN expRelational CPAREN
Rule 52    expParen -> varCte
Rule 53    classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef
Rule 54    classDef -> epsilon
Rule 55    classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF
Rule 56    simpleType -> INT
Rule 57    simpleType -> STRING
Rule 58    simpleType -> DEC
Rule 59    simpleType -> BOOL
Rule 60    objType -> ID
Rule 61    varCte -> INT
Rule 62    varCte -> DEC
Rule 63    varCte -> STRING
Rule 64    varCte -> ID
Rule 65    whileCycle -> WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET
Rule 66    ifCond -> IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET
Rule 67    ifCond -> ifCond ELSE OBRACKET statements CBRACKET
Rule 68    input -> INPUT OPAREN ID CPAREN EOF
Rule 69    output -> OUTPUT OPAREN expRelational CPAREN EOF
Rule 70    end -> END OPAREN ID CPAREN
Rule 71    epsilon -> <empty>

Terminals, with rules where they appear

ASSIGNMENT           : 32
ATTRIBUTES           : 53
BEGIN                : 1
BOOL                 : 59
CBRACKET             : 2 3 4 53 65 66 67
CLASS                : 53
COLON                : 53 53
COMMA                : 7 10 26
CPAREN               : 1 2 3 4 12 36 51 55 65 66 68 69 70
CSQUAREBR            : 30 31
DEC                  : 58 62
DIFFERENT            : 40
DIVIDE               : 50
ELSE                 : 67
END                  : 70
EOF                  : 4 12 23 24 33 34 55 68 69
EQUAL                : 39
FX                   : 3 4
GREATERTHAN          : 41
GREATERTHANEQ        : 42
ID                   : 1 3 4 4 6 7 9 10 12 27 30 32 36 53 55 55 60 64 68 70
IF                   : 66
INPUT                : 68
INT                  : 56 61
LESSTHAN             : 43
LESSTHANEQ           : 44
MAIN                 : 2
METHODS              : 53
MINUS                : 47
MONEY                : 55
MULTIPLY             : 49
OBRACKET             : 2 3 4 53 65 66 67
OPAREN               : 1 2 3 4 12 36 51 55 65 66 68 69 70
OSQUAREBR            : 30 31
OUTPUT               : 69
PLUS                 : 46
RETURN               : 4
STRING               : 57 63
VAR                  : 23 24
VOID                 : 3
WHILE                : 65
error                : 

Nonterminals, with rules where they appear

arrDef               : 28 31
assignmentDef        : 16
begin                : 0
body                 : 2 3 4 13 14
classCall            : 22 35
classDef             : 1 53
end                  : 1
epsilon              : 5 8 11 15 54
expAssignment        : 32
expParen             : 48 49 50
expRelational        : 33 38 51 65 66 69
fxDef                : 1 3 4 53
ifCond               : 21 67
input                : 17
main                 : 1
matrixDef            : 29
multDiv              : 45 46 47 49 50
objType              : 23
opRelational         : 38
output               : 18
param                : 3 4 7
paramCall            : 10 12 36 55
plusMinus            : 37 38 46 47
returnCall           : 34
simpleType           : 4 6 7 24
statements           : 14 65 66 67
var                  : 23 24 26
varCte               : 30 31 52
varsDef              : 13 53
varsType             : 25 26
voidCall             : 19
whileCycle           : 20

Parsing method: LALR

state 0

    (0) S' -> . begin
    (1) begin -> . BEGIN OPAREN ID CPAREN classDef fxDef main end

    BEGIN           shift and go to state 2

    begin                          shift and go to state 1

state 1

    (0) S' -> begin .



state 2

    (1) begin -> BEGIN . OPAREN ID CPAREN classDef fxDef main end

    OPAREN          shift and go to state 3


state 3

    (1) begin -> BEGIN OPAREN . ID CPAREN classDef fxDef main end

    ID              shift and go to state 4


state 4

    (1) begin -> BEGIN OPAREN ID . CPAREN classDef fxDef main end

    CPAREN          shift and go to state 5


state 5

    (1) begin -> BEGIN OPAREN ID CPAREN . classDef fxDef main end
    (53) classDef -> . CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef
    (54) classDef -> . epsilon
    (71) epsilon -> .

    CLASS           shift and go to state 7
    VOID            reduce using rule 71 (epsilon -> .)
    INT             reduce using rule 71 (epsilon -> .)
    STRING          reduce using rule 71 (epsilon -> .)
    DEC             reduce using rule 71 (epsilon -> .)
    BOOL            reduce using rule 71 (epsilon -> .)
    MAIN            reduce using rule 71 (epsilon -> .)

    classDef                       shift and go to state 6
    epsilon                        shift and go to state 8

state 6

    (1) begin -> BEGIN OPAREN ID CPAREN classDef . fxDef main end
    (3) fxDef -> . VOID FX ID OPAREN param CPAREN OBRACKET body CBRACKET fxDef
    (4) fxDef -> . simpleType FX ID OPAREN param CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef
    (5) fxDef -> . epsilon
    (56) simpleType -> . INT
    (57) simpleType -> . STRING
    (58) simpleType -> . DEC
    (59) simpleType -> . BOOL
    (71) epsilon -> .

    VOID            shift and go to state 10
    INT             shift and go to state 13
    STRING          shift and go to state 14
    DEC             shift and go to state 15
    BOOL            shift and go to state 16
    MAIN            reduce using rule 71 (epsilon -> .)

    fxDef                          shift and go to state 9
    simpleType                     shift and go to state 11
    epsilon                        shift and go to state 12

state 7

    (53) classDef -> CLASS . ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef

    ID              shift and go to state 17


state 8

    (54) classDef -> epsilon .

    VOID            reduce using rule 54 (classDef -> epsilon .)
    INT             reduce using rule 54 (classDef -> epsilon .)
    STRING          reduce using rule 54 (classDef -> epsilon .)
    DEC             reduce using rule 54 (classDef -> epsilon .)
    BOOL            reduce using rule 54 (classDef -> epsilon .)
    MAIN            reduce using rule 54 (classDef -> epsilon .)


state 9

    (1) begin -> BEGIN OPAREN ID CPAREN classDef fxDef . main end
    (2) main -> . MAIN OPAREN CPAREN OBRACKET body CBRACKET

    MAIN            shift and go to state 19

    main                           shift and go to state 18

state 10

    (3) fxDef -> VOID . FX ID OPAREN param CPAREN OBRACKET body CBRACKET fxDef

    FX              shift and go to state 20


state 11

    (4) fxDef -> simpleType . FX ID OPAREN param CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef

    FX              shift and go to state 21


state 12

    (5) fxDef -> epsilon .

    MAIN            reduce using rule 5 (fxDef -> epsilon .)
    CBRACKET        reduce using rule 5 (fxDef -> epsilon .)


state 13

    (56) simpleType -> INT .

    FX              reduce using rule 56 (simpleType -> INT .)
    ID              reduce using rule 56 (simpleType -> INT .)


state 14

    (57) simpleType -> STRING .

    FX              reduce using rule 57 (simpleType -> STRING .)
    ID              reduce using rule 57 (simpleType -> STRING .)


state 15

    (58) simpleType -> DEC .

    FX              reduce using rule 58 (simpleType -> DEC .)
    ID              reduce using rule 58 (simpleType -> DEC .)


state 16

    (59) simpleType -> BOOL .

    FX              reduce using rule 59 (simpleType -> BOOL .)
    ID              reduce using rule 59 (simpleType -> BOOL .)


state 17

    (53) classDef -> CLASS ID . OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef

    OBRACKET        shift and go to state 22


state 18

    (1) begin -> BEGIN OPAREN ID CPAREN classDef fxDef main . end
    (70) end -> . END OPAREN ID CPAREN

    END             shift and go to state 24

    end                            shift and go to state 23

state 19

    (2) main -> MAIN . OPAREN CPAREN OBRACKET body CBRACKET

    OPAREN          shift and go to state 25


state 20

    (3) fxDef -> VOID FX . ID OPAREN param CPAREN OBRACKET body CBRACKET fxDef

    ID              shift and go to state 26


state 21

    (4) fxDef -> simpleType FX . ID OPAREN param CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef

    ID              shift and go to state 27


state 22

    (53) classDef -> CLASS ID OBRACKET . ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef

    ATTRIBUTES      shift and go to state 28


state 23

    (1) begin -> BEGIN OPAREN ID CPAREN classDef fxDef main end .

    $end            reduce using rule 1 (begin -> BEGIN OPAREN ID CPAREN classDef fxDef main end .)


state 24

    (70) end -> END . OPAREN ID CPAREN

    OPAREN          shift and go to state 29


state 25

    (2) main -> MAIN OPAREN . CPAREN OBRACKET body CBRACKET

    CPAREN          shift and go to state 30


state 26

    (3) fxDef -> VOID FX ID . OPAREN param CPAREN OBRACKET body CBRACKET fxDef

    OPAREN          shift and go to state 31


state 27

    (4) fxDef -> simpleType FX ID . OPAREN param CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef

    OPAREN          shift and go to state 32


state 28

    (53) classDef -> CLASS ID OBRACKET ATTRIBUTES . COLON varsDef METHODS COLON fxDef CBRACKET classDef

    COLON           shift and go to state 33


state 29

    (70) end -> END OPAREN . ID CPAREN

    ID              shift and go to state 34


state 30

    (2) main -> MAIN OPAREN CPAREN . OBRACKET body CBRACKET

    OBRACKET        shift and go to state 35


state 31

    (3) fxDef -> VOID FX ID OPAREN . param CPAREN OBRACKET body CBRACKET fxDef
    (6) param -> . simpleType ID
    (7) param -> . simpleType ID COMMA param
    (8) param -> . epsilon
    (56) simpleType -> . INT
    (57) simpleType -> . STRING
    (58) simpleType -> . DEC
    (59) simpleType -> . BOOL
    (71) epsilon -> .

    INT             shift and go to state 13
    STRING          shift and go to state 14
    DEC             shift and go to state 15
    BOOL            shift and go to state 16
    CPAREN          reduce using rule 71 (epsilon -> .)

    param                          shift and go to state 36
    simpleType                     shift and go to state 37
    epsilon                        shift and go to state 38

state 32

    (4) fxDef -> simpleType FX ID OPAREN . param CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef
    (6) param -> . simpleType ID
    (7) param -> . simpleType ID COMMA param
    (8) param -> . epsilon
    (56) simpleType -> . INT
    (57) simpleType -> . STRING
    (58) simpleType -> . DEC
    (59) simpleType -> . BOOL
    (71) epsilon -> .

    INT             shift and go to state 13
    STRING          shift and go to state 14
    DEC             shift and go to state 15
    BOOL            shift and go to state 16
    CPAREN          reduce using rule 71 (epsilon -> .)

    simpleType                     shift and go to state 37
    param                          shift and go to state 39
    epsilon                        shift and go to state 38

state 33

    (53) classDef -> CLASS ID OBRACKET ATTRIBUTES COLON . varsDef METHODS COLON fxDef CBRACKET classDef
    (23) varsDef -> . VAR objType var EOF
    (24) varsDef -> . VAR simpleType var EOF

    VAR             shift and go to state 41

    varsDef                        shift and go to state 40

state 34

    (70) end -> END OPAREN ID . CPAREN

    CPAREN          shift and go to state 42


state 35

    (2) main -> MAIN OPAREN CPAREN OBRACKET . body CBRACKET
    (13) body -> . varsDef body
    (14) body -> . statements body
    (15) body -> . epsilon
    (23) varsDef -> . VAR objType var EOF
    (24) varsDef -> . VAR simpleType var EOF
    (16) statements -> . assignmentDef
    (17) statements -> . input
    (18) statements -> . output
    (19) statements -> . voidCall
    (20) statements -> . whileCycle
    (21) statements -> . ifCond
    (22) statements -> . classCall
    (71) epsilon -> .
    (32) assignmentDef -> . ID ASSIGNMENT expAssignment
    (68) input -> . INPUT OPAREN ID CPAREN EOF
    (69) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (12) voidCall -> . ID OPAREN paramCall CPAREN EOF
    (65) whileCycle -> . WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (66) ifCond -> . IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (67) ifCond -> . ifCond ELSE OBRACKET statements CBRACKET
    (55) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF

    VAR             shift and go to state 41
    CBRACKET        reduce using rule 71 (epsilon -> .)
    ID              shift and go to state 54
    INPUT           shift and go to state 55
    OUTPUT          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 58

    body                           shift and go to state 43
    varsDef                        shift and go to state 44
    statements                     shift and go to state 45
    epsilon                        shift and go to state 46
    assignmentDef                  shift and go to state 47
    input                          shift and go to state 48
    output                         shift and go to state 49
    voidCall                       shift and go to state 50
    whileCycle                     shift and go to state 51
    ifCond                         shift and go to state 52
    classCall                      shift and go to state 53

state 36

    (3) fxDef -> VOID FX ID OPAREN param . CPAREN OBRACKET body CBRACKET fxDef

    CPAREN          shift and go to state 59


state 37

    (6) param -> simpleType . ID
    (7) param -> simpleType . ID COMMA param

    ID              shift and go to state 60


state 38

    (8) param -> epsilon .

    CPAREN          reduce using rule 8 (param -> epsilon .)


state 39

    (4) fxDef -> simpleType FX ID OPAREN param . CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef

    CPAREN          shift and go to state 61


state 40

    (53) classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef . METHODS COLON fxDef CBRACKET classDef

    METHODS         shift and go to state 62


state 41

    (23) varsDef -> VAR . objType var EOF
    (24) varsDef -> VAR . simpleType var EOF
    (60) objType -> . ID
    (56) simpleType -> . INT
    (57) simpleType -> . STRING
    (58) simpleType -> . DEC
    (59) simpleType -> . BOOL

    ID              shift and go to state 65
    INT             shift and go to state 13
    STRING          shift and go to state 14
    DEC             shift and go to state 15
    BOOL            shift and go to state 16

    objType                        shift and go to state 63
    simpleType                     shift and go to state 64

state 42

    (70) end -> END OPAREN ID CPAREN .

    $end            reduce using rule 70 (end -> END OPAREN ID CPAREN .)


state 43

    (2) main -> MAIN OPAREN CPAREN OBRACKET body . CBRACKET

    CBRACKET        shift and go to state 66


state 44

    (13) body -> varsDef . body
    (13) body -> . varsDef body
    (14) body -> . statements body
    (15) body -> . epsilon
    (23) varsDef -> . VAR objType var EOF
    (24) varsDef -> . VAR simpleType var EOF
    (16) statements -> . assignmentDef
    (17) statements -> . input
    (18) statements -> . output
    (19) statements -> . voidCall
    (20) statements -> . whileCycle
    (21) statements -> . ifCond
    (22) statements -> . classCall
    (71) epsilon -> .
    (32) assignmentDef -> . ID ASSIGNMENT expAssignment
    (68) input -> . INPUT OPAREN ID CPAREN EOF
    (69) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (12) voidCall -> . ID OPAREN paramCall CPAREN EOF
    (65) whileCycle -> . WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (66) ifCond -> . IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (67) ifCond -> . ifCond ELSE OBRACKET statements CBRACKET
    (55) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF

    VAR             shift and go to state 41
    CBRACKET        reduce using rule 71 (epsilon -> .)
    RETURN          reduce using rule 71 (epsilon -> .)
    ID              shift and go to state 54
    INPUT           shift and go to state 55
    OUTPUT          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 58

    varsDef                        shift and go to state 44
    body                           shift and go to state 67
    statements                     shift and go to state 45
    epsilon                        shift and go to state 46
    assignmentDef                  shift and go to state 47
    input                          shift and go to state 48
    output                         shift and go to state 49
    voidCall                       shift and go to state 50
    whileCycle                     shift and go to state 51
    ifCond                         shift and go to state 52
    classCall                      shift and go to state 53

state 45

    (14) body -> statements . body
    (13) body -> . varsDef body
    (14) body -> . statements body
    (15) body -> . epsilon
    (23) varsDef -> . VAR objType var EOF
    (24) varsDef -> . VAR simpleType var EOF
    (16) statements -> . assignmentDef
    (17) statements -> . input
    (18) statements -> . output
    (19) statements -> . voidCall
    (20) statements -> . whileCycle
    (21) statements -> . ifCond
    (22) statements -> . classCall
    (71) epsilon -> .
    (32) assignmentDef -> . ID ASSIGNMENT expAssignment
    (68) input -> . INPUT OPAREN ID CPAREN EOF
    (69) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (12) voidCall -> . ID OPAREN paramCall CPAREN EOF
    (65) whileCycle -> . WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (66) ifCond -> . IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (67) ifCond -> . ifCond ELSE OBRACKET statements CBRACKET
    (55) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF

    VAR             shift and go to state 41
    CBRACKET        reduce using rule 71 (epsilon -> .)
    RETURN          reduce using rule 71 (epsilon -> .)
    ID              shift and go to state 54
    INPUT           shift and go to state 55
    OUTPUT          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 58

    statements                     shift and go to state 45
    body                           shift and go to state 68
    varsDef                        shift and go to state 44
    epsilon                        shift and go to state 46
    assignmentDef                  shift and go to state 47
    input                          shift and go to state 48
    output                         shift and go to state 49
    voidCall                       shift and go to state 50
    whileCycle                     shift and go to state 51
    ifCond                         shift and go to state 52
    classCall                      shift and go to state 53

state 46

    (15) body -> epsilon .

    CBRACKET        reduce using rule 15 (body -> epsilon .)
    RETURN          reduce using rule 15 (body -> epsilon .)


state 47

    (16) statements -> assignmentDef .

    VAR             reduce using rule 16 (statements -> assignmentDef .)
    ID              reduce using rule 16 (statements -> assignmentDef .)
    INPUT           reduce using rule 16 (statements -> assignmentDef .)
    OUTPUT          reduce using rule 16 (statements -> assignmentDef .)
    WHILE           reduce using rule 16 (statements -> assignmentDef .)
    IF              reduce using rule 16 (statements -> assignmentDef .)
    CBRACKET        reduce using rule 16 (statements -> assignmentDef .)
    RETURN          reduce using rule 16 (statements -> assignmentDef .)


state 48

    (17) statements -> input .

    VAR             reduce using rule 17 (statements -> input .)
    ID              reduce using rule 17 (statements -> input .)
    INPUT           reduce using rule 17 (statements -> input .)
    OUTPUT          reduce using rule 17 (statements -> input .)
    WHILE           reduce using rule 17 (statements -> input .)
    IF              reduce using rule 17 (statements -> input .)
    CBRACKET        reduce using rule 17 (statements -> input .)
    RETURN          reduce using rule 17 (statements -> input .)


state 49

    (18) statements -> output .

    VAR             reduce using rule 18 (statements -> output .)
    ID              reduce using rule 18 (statements -> output .)
    INPUT           reduce using rule 18 (statements -> output .)
    OUTPUT          reduce using rule 18 (statements -> output .)
    WHILE           reduce using rule 18 (statements -> output .)
    IF              reduce using rule 18 (statements -> output .)
    CBRACKET        reduce using rule 18 (statements -> output .)
    RETURN          reduce using rule 18 (statements -> output .)


state 50

    (19) statements -> voidCall .

    VAR             reduce using rule 19 (statements -> voidCall .)
    ID              reduce using rule 19 (statements -> voidCall .)
    INPUT           reduce using rule 19 (statements -> voidCall .)
    OUTPUT          reduce using rule 19 (statements -> voidCall .)
    WHILE           reduce using rule 19 (statements -> voidCall .)
    IF              reduce using rule 19 (statements -> voidCall .)
    CBRACKET        reduce using rule 19 (statements -> voidCall .)
    RETURN          reduce using rule 19 (statements -> voidCall .)


state 51

    (20) statements -> whileCycle .

    VAR             reduce using rule 20 (statements -> whileCycle .)
    ID              reduce using rule 20 (statements -> whileCycle .)
    INPUT           reduce using rule 20 (statements -> whileCycle .)
    OUTPUT          reduce using rule 20 (statements -> whileCycle .)
    WHILE           reduce using rule 20 (statements -> whileCycle .)
    IF              reduce using rule 20 (statements -> whileCycle .)
    CBRACKET        reduce using rule 20 (statements -> whileCycle .)
    RETURN          reduce using rule 20 (statements -> whileCycle .)


state 52

    (21) statements -> ifCond .
    (67) ifCond -> ifCond . ELSE OBRACKET statements CBRACKET

    VAR             reduce using rule 21 (statements -> ifCond .)
    ID              reduce using rule 21 (statements -> ifCond .)
    INPUT           reduce using rule 21 (statements -> ifCond .)
    OUTPUT          reduce using rule 21 (statements -> ifCond .)
    WHILE           reduce using rule 21 (statements -> ifCond .)
    IF              reduce using rule 21 (statements -> ifCond .)
    CBRACKET        reduce using rule 21 (statements -> ifCond .)
    RETURN          reduce using rule 21 (statements -> ifCond .)
    ELSE            shift and go to state 69


state 53

    (22) statements -> classCall .

    VAR             reduce using rule 22 (statements -> classCall .)
    ID              reduce using rule 22 (statements -> classCall .)
    INPUT           reduce using rule 22 (statements -> classCall .)
    OUTPUT          reduce using rule 22 (statements -> classCall .)
    WHILE           reduce using rule 22 (statements -> classCall .)
    IF              reduce using rule 22 (statements -> classCall .)
    CBRACKET        reduce using rule 22 (statements -> classCall .)
    RETURN          reduce using rule 22 (statements -> classCall .)


state 54

    (32) assignmentDef -> ID . ASSIGNMENT expAssignment
    (12) voidCall -> ID . OPAREN paramCall CPAREN EOF
    (55) classCall -> ID . MONEY ID OPAREN paramCall CPAREN EOF

    ASSIGNMENT      shift and go to state 70
    OPAREN          shift and go to state 71
    MONEY           shift and go to state 72


state 55

    (68) input -> INPUT . OPAREN ID CPAREN EOF

    OPAREN          shift and go to state 73


state 56

    (69) output -> OUTPUT . OPAREN expRelational CPAREN EOF

    OPAREN          shift and go to state 74


state 57

    (65) whileCycle -> WHILE . OPAREN expRelational CPAREN OBRACKET statements CBRACKET

    OPAREN          shift and go to state 75


state 58

    (66) ifCond -> IF . OPAREN expRelational CPAREN OBRACKET statements CBRACKET

    OPAREN          shift and go to state 76


state 59

    (3) fxDef -> VOID FX ID OPAREN param CPAREN . OBRACKET body CBRACKET fxDef

    OBRACKET        shift and go to state 77


state 60

    (6) param -> simpleType ID .
    (7) param -> simpleType ID . COMMA param

    CPAREN          reduce using rule 6 (param -> simpleType ID .)
    COMMA           shift and go to state 78


state 61

    (4) fxDef -> simpleType FX ID OPAREN param CPAREN . OBRACKET body RETURN ID EOF CBRACKET fxDef

    OBRACKET        shift and go to state 79


state 62

    (53) classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS . COLON fxDef CBRACKET classDef

    COLON           shift and go to state 80


state 63

    (23) varsDef -> VAR objType . var EOF
    (25) var -> . varsType
    (26) var -> . varsType COMMA var
    (27) varsType -> . ID
    (28) varsType -> . arrDef
    (29) varsType -> . matrixDef
    (30) arrDef -> . ID OSQUAREBR varCte CSQUAREBR
    (31) matrixDef -> . arrDef OSQUAREBR varCte CSQUAREBR

    ID              shift and go to state 83

    var                            shift and go to state 81
    varsType                       shift and go to state 82
    arrDef                         shift and go to state 84
    matrixDef                      shift and go to state 85

state 64

    (24) varsDef -> VAR simpleType . var EOF
    (25) var -> . varsType
    (26) var -> . varsType COMMA var
    (27) varsType -> . ID
    (28) varsType -> . arrDef
    (29) varsType -> . matrixDef
    (30) arrDef -> . ID OSQUAREBR varCte CSQUAREBR
    (31) matrixDef -> . arrDef OSQUAREBR varCte CSQUAREBR

    ID              shift and go to state 83

    var                            shift and go to state 86
    varsType                       shift and go to state 82
    arrDef                         shift and go to state 84
    matrixDef                      shift and go to state 85

state 65

    (60) objType -> ID .

    ID              reduce using rule 60 (objType -> ID .)


state 66

    (2) main -> MAIN OPAREN CPAREN OBRACKET body CBRACKET .

    END             reduce using rule 2 (main -> MAIN OPAREN CPAREN OBRACKET body CBRACKET .)


state 67

    (13) body -> varsDef body .

    CBRACKET        reduce using rule 13 (body -> varsDef body .)
    RETURN          reduce using rule 13 (body -> varsDef body .)


state 68

    (14) body -> statements body .

    CBRACKET        reduce using rule 14 (body -> statements body .)
    RETURN          reduce using rule 14 (body -> statements body .)


state 69

    (67) ifCond -> ifCond ELSE . OBRACKET statements CBRACKET

    OBRACKET        shift and go to state 87


state 70

    (32) assignmentDef -> ID ASSIGNMENT . expAssignment
    (33) expAssignment -> . expRelational EOF
    (34) expAssignment -> . returnCall EOF
    (35) expAssignment -> . classCall
    (37) expRelational -> . plusMinus
    (38) expRelational -> . plusMinus opRelational expRelational
    (36) returnCall -> . ID OPAREN paramCall CPAREN
    (55) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (45) plusMinus -> . multDiv
    (46) plusMinus -> . multDiv PLUS plusMinus
    (47) plusMinus -> . multDiv MINUS plusMinus
    (48) multDiv -> . expParen
    (49) multDiv -> . expParen MULTIPLY multDiv
    (50) multDiv -> . expParen DIVIDE multDiv
    (51) expParen -> . OPAREN expRelational CPAREN
    (52) expParen -> . varCte
    (61) varCte -> . INT
    (62) varCte -> . DEC
    (63) varCte -> . STRING
    (64) varCte -> . ID

    ID              shift and go to state 88
    OPAREN          shift and go to state 94
    INT             shift and go to state 98
    DEC             shift and go to state 99
    STRING          shift and go to state 100

    expAssignment                  shift and go to state 89
    expRelational                  shift and go to state 90
    returnCall                     shift and go to state 91
    classCall                      shift and go to state 92
    plusMinus                      shift and go to state 93
    multDiv                        shift and go to state 95
    expParen                       shift and go to state 96
    varCte                         shift and go to state 97

state 71

    (12) voidCall -> ID OPAREN . paramCall CPAREN EOF
    (9) paramCall -> . ID
    (10) paramCall -> . ID COMMA paramCall
    (11) paramCall -> . epsilon
    (71) epsilon -> .

    ID              shift and go to state 101
    CPAREN          reduce using rule 71 (epsilon -> .)

    paramCall                      shift and go to state 102
    epsilon                        shift and go to state 103

state 72

    (55) classCall -> ID MONEY . ID OPAREN paramCall CPAREN EOF

    ID              shift and go to state 104


state 73

    (68) input -> INPUT OPAREN . ID CPAREN EOF

    ID              shift and go to state 105


state 74

    (69) output -> OUTPUT OPAREN . expRelational CPAREN EOF
    (37) expRelational -> . plusMinus
    (38) expRelational -> . plusMinus opRelational expRelational
    (45) plusMinus -> . multDiv
    (46) plusMinus -> . multDiv PLUS plusMinus
    (47) plusMinus -> . multDiv MINUS plusMinus
    (48) multDiv -> . expParen
    (49) multDiv -> . expParen MULTIPLY multDiv
    (50) multDiv -> . expParen DIVIDE multDiv
    (51) expParen -> . OPAREN expRelational CPAREN
    (52) expParen -> . varCte
    (61) varCte -> . INT
    (62) varCte -> . DEC
    (63) varCte -> . STRING
    (64) varCte -> . ID

    OPAREN          shift and go to state 94
    INT             shift and go to state 98
    DEC             shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 107

    expRelational                  shift and go to state 106
    plusMinus                      shift and go to state 93
    multDiv                        shift and go to state 95
    expParen                       shift and go to state 96
    varCte                         shift and go to state 97

state 75

    (65) whileCycle -> WHILE OPAREN . expRelational CPAREN OBRACKET statements CBRACKET
    (37) expRelational -> . plusMinus
    (38) expRelational -> . plusMinus opRelational expRelational
    (45) plusMinus -> . multDiv
    (46) plusMinus -> . multDiv PLUS plusMinus
    (47) plusMinus -> . multDiv MINUS plusMinus
    (48) multDiv -> . expParen
    (49) multDiv -> . expParen MULTIPLY multDiv
    (50) multDiv -> . expParen DIVIDE multDiv
    (51) expParen -> . OPAREN expRelational CPAREN
    (52) expParen -> . varCte
    (61) varCte -> . INT
    (62) varCte -> . DEC
    (63) varCte -> . STRING
    (64) varCte -> . ID

    OPAREN          shift and go to state 94
    INT             shift and go to state 98
    DEC             shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 107

    expRelational                  shift and go to state 108
    plusMinus                      shift and go to state 93
    multDiv                        shift and go to state 95
    expParen                       shift and go to state 96
    varCte                         shift and go to state 97

state 76

    (66) ifCond -> IF OPAREN . expRelational CPAREN OBRACKET statements CBRACKET
    (37) expRelational -> . plusMinus
    (38) expRelational -> . plusMinus opRelational expRelational
    (45) plusMinus -> . multDiv
    (46) plusMinus -> . multDiv PLUS plusMinus
    (47) plusMinus -> . multDiv MINUS plusMinus
    (48) multDiv -> . expParen
    (49) multDiv -> . expParen MULTIPLY multDiv
    (50) multDiv -> . expParen DIVIDE multDiv
    (51) expParen -> . OPAREN expRelational CPAREN
    (52) expParen -> . varCte
    (61) varCte -> . INT
    (62) varCte -> . DEC
    (63) varCte -> . STRING
    (64) varCte -> . ID

    OPAREN          shift and go to state 94
    INT             shift and go to state 98
    DEC             shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 107

    expRelational                  shift and go to state 109
    plusMinus                      shift and go to state 93
    multDiv                        shift and go to state 95
    expParen                       shift and go to state 96
    varCte                         shift and go to state 97

state 77

    (3) fxDef -> VOID FX ID OPAREN param CPAREN OBRACKET . body CBRACKET fxDef
    (13) body -> . varsDef body
    (14) body -> . statements body
    (15) body -> . epsilon
    (23) varsDef -> . VAR objType var EOF
    (24) varsDef -> . VAR simpleType var EOF
    (16) statements -> . assignmentDef
    (17) statements -> . input
    (18) statements -> . output
    (19) statements -> . voidCall
    (20) statements -> . whileCycle
    (21) statements -> . ifCond
    (22) statements -> . classCall
    (71) epsilon -> .
    (32) assignmentDef -> . ID ASSIGNMENT expAssignment
    (68) input -> . INPUT OPAREN ID CPAREN EOF
    (69) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (12) voidCall -> . ID OPAREN paramCall CPAREN EOF
    (65) whileCycle -> . WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (66) ifCond -> . IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (67) ifCond -> . ifCond ELSE OBRACKET statements CBRACKET
    (55) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF

    VAR             shift and go to state 41
    CBRACKET        reduce using rule 71 (epsilon -> .)
    ID              shift and go to state 54
    INPUT           shift and go to state 55
    OUTPUT          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 58

    body                           shift and go to state 110
    varsDef                        shift and go to state 44
    statements                     shift and go to state 45
    epsilon                        shift and go to state 46
    assignmentDef                  shift and go to state 47
    input                          shift and go to state 48
    output                         shift and go to state 49
    voidCall                       shift and go to state 50
    whileCycle                     shift and go to state 51
    ifCond                         shift and go to state 52
    classCall                      shift and go to state 53

state 78

    (7) param -> simpleType ID COMMA . param
    (6) param -> . simpleType ID
    (7) param -> . simpleType ID COMMA param
    (8) param -> . epsilon
    (56) simpleType -> . INT
    (57) simpleType -> . STRING
    (58) simpleType -> . DEC
    (59) simpleType -> . BOOL
    (71) epsilon -> .

    INT             shift and go to state 13
    STRING          shift and go to state 14
    DEC             shift and go to state 15
    BOOL            shift and go to state 16
    CPAREN          reduce using rule 71 (epsilon -> .)

    simpleType                     shift and go to state 37
    param                          shift and go to state 111
    epsilon                        shift and go to state 38

state 79

    (4) fxDef -> simpleType FX ID OPAREN param CPAREN OBRACKET . body RETURN ID EOF CBRACKET fxDef
    (13) body -> . varsDef body
    (14) body -> . statements body
    (15) body -> . epsilon
    (23) varsDef -> . VAR objType var EOF
    (24) varsDef -> . VAR simpleType var EOF
    (16) statements -> . assignmentDef
    (17) statements -> . input
    (18) statements -> . output
    (19) statements -> . voidCall
    (20) statements -> . whileCycle
    (21) statements -> . ifCond
    (22) statements -> . classCall
    (71) epsilon -> .
    (32) assignmentDef -> . ID ASSIGNMENT expAssignment
    (68) input -> . INPUT OPAREN ID CPAREN EOF
    (69) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (12) voidCall -> . ID OPAREN paramCall CPAREN EOF
    (65) whileCycle -> . WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (66) ifCond -> . IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (67) ifCond -> . ifCond ELSE OBRACKET statements CBRACKET
    (55) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF

    VAR             shift and go to state 41
    RETURN          reduce using rule 71 (epsilon -> .)
    ID              shift and go to state 54
    INPUT           shift and go to state 55
    OUTPUT          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 58

    body                           shift and go to state 112
    varsDef                        shift and go to state 44
    statements                     shift and go to state 45
    epsilon                        shift and go to state 46
    assignmentDef                  shift and go to state 47
    input                          shift and go to state 48
    output                         shift and go to state 49
    voidCall                       shift and go to state 50
    whileCycle                     shift and go to state 51
    ifCond                         shift and go to state 52
    classCall                      shift and go to state 53

state 80

    (53) classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON . fxDef CBRACKET classDef
    (3) fxDef -> . VOID FX ID OPAREN param CPAREN OBRACKET body CBRACKET fxDef
    (4) fxDef -> . simpleType FX ID OPAREN param CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef
    (5) fxDef -> . epsilon
    (56) simpleType -> . INT
    (57) simpleType -> . STRING
    (58) simpleType -> . DEC
    (59) simpleType -> . BOOL
    (71) epsilon -> .

    VOID            shift and go to state 10
    INT             shift and go to state 13
    STRING          shift and go to state 14
    DEC             shift and go to state 15
    BOOL            shift and go to state 16
    CBRACKET        reduce using rule 71 (epsilon -> .)

    fxDef                          shift and go to state 113
    simpleType                     shift and go to state 11
    epsilon                        shift and go to state 12

state 81

    (23) varsDef -> VAR objType var . EOF

    EOF             shift and go to state 114


state 82

    (25) var -> varsType .
    (26) var -> varsType . COMMA var

    EOF             reduce using rule 25 (var -> varsType .)
    COMMA           shift and go to state 115


state 83

    (27) varsType -> ID .
    (30) arrDef -> ID . OSQUAREBR varCte CSQUAREBR

    COMMA           reduce using rule 27 (varsType -> ID .)
    EOF             reduce using rule 27 (varsType -> ID .)
    OSQUAREBR       shift and go to state 116


state 84

    (28) varsType -> arrDef .
    (31) matrixDef -> arrDef . OSQUAREBR varCte CSQUAREBR

    COMMA           reduce using rule 28 (varsType -> arrDef .)
    EOF             reduce using rule 28 (varsType -> arrDef .)
    OSQUAREBR       shift and go to state 117


state 85

    (29) varsType -> matrixDef .

    COMMA           reduce using rule 29 (varsType -> matrixDef .)
    EOF             reduce using rule 29 (varsType -> matrixDef .)


state 86

    (24) varsDef -> VAR simpleType var . EOF

    EOF             shift and go to state 118


state 87

    (67) ifCond -> ifCond ELSE OBRACKET . statements CBRACKET
    (16) statements -> . assignmentDef
    (17) statements -> . input
    (18) statements -> . output
    (19) statements -> . voidCall
    (20) statements -> . whileCycle
    (21) statements -> . ifCond
    (22) statements -> . classCall
    (32) assignmentDef -> . ID ASSIGNMENT expAssignment
    (68) input -> . INPUT OPAREN ID CPAREN EOF
    (69) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (12) voidCall -> . ID OPAREN paramCall CPAREN EOF
    (65) whileCycle -> . WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (66) ifCond -> . IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (67) ifCond -> . ifCond ELSE OBRACKET statements CBRACKET
    (55) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF

    ID              shift and go to state 54
    INPUT           shift and go to state 55
    OUTPUT          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 58

    ifCond                         shift and go to state 52
    statements                     shift and go to state 119
    assignmentDef                  shift and go to state 47
    input                          shift and go to state 48
    output                         shift and go to state 49
    voidCall                       shift and go to state 50
    whileCycle                     shift and go to state 51
    classCall                      shift and go to state 53

state 88

    (36) returnCall -> ID . OPAREN paramCall CPAREN
    (55) classCall -> ID . MONEY ID OPAREN paramCall CPAREN EOF
    (64) varCte -> ID .

    OPAREN          shift and go to state 120
    MONEY           shift and go to state 72
    MULTIPLY        reduce using rule 64 (varCte -> ID .)
    DIVIDE          reduce using rule 64 (varCte -> ID .)
    PLUS            reduce using rule 64 (varCte -> ID .)
    MINUS           reduce using rule 64 (varCte -> ID .)
    EQUAL           reduce using rule 64 (varCte -> ID .)
    DIFFERENT       reduce using rule 64 (varCte -> ID .)
    GREATERTHAN     reduce using rule 64 (varCte -> ID .)
    GREATERTHANEQ   reduce using rule 64 (varCte -> ID .)
    LESSTHAN        reduce using rule 64 (varCte -> ID .)
    LESSTHANEQ      reduce using rule 64 (varCte -> ID .)
    EOF             reduce using rule 64 (varCte -> ID .)


state 89

    (32) assignmentDef -> ID ASSIGNMENT expAssignment .

    VAR             reduce using rule 32 (assignmentDef -> ID ASSIGNMENT expAssignment .)
    ID              reduce using rule 32 (assignmentDef -> ID ASSIGNMENT expAssignment .)
    INPUT           reduce using rule 32 (assignmentDef -> ID ASSIGNMENT expAssignment .)
    OUTPUT          reduce using rule 32 (assignmentDef -> ID ASSIGNMENT expAssignment .)
    WHILE           reduce using rule 32 (assignmentDef -> ID ASSIGNMENT expAssignment .)
    IF              reduce using rule 32 (assignmentDef -> ID ASSIGNMENT expAssignment .)
    CBRACKET        reduce using rule 32 (assignmentDef -> ID ASSIGNMENT expAssignment .)
    RETURN          reduce using rule 32 (assignmentDef -> ID ASSIGNMENT expAssignment .)


state 90

    (33) expAssignment -> expRelational . EOF

    EOF             shift and go to state 121


state 91

    (34) expAssignment -> returnCall . EOF

    EOF             shift and go to state 122


state 92

    (35) expAssignment -> classCall .

    VAR             reduce using rule 35 (expAssignment -> classCall .)
    ID              reduce using rule 35 (expAssignment -> classCall .)
    INPUT           reduce using rule 35 (expAssignment -> classCall .)
    OUTPUT          reduce using rule 35 (expAssignment -> classCall .)
    WHILE           reduce using rule 35 (expAssignment -> classCall .)
    IF              reduce using rule 35 (expAssignment -> classCall .)
    CBRACKET        reduce using rule 35 (expAssignment -> classCall .)
    RETURN          reduce using rule 35 (expAssignment -> classCall .)


state 93

    (37) expRelational -> plusMinus .
    (38) expRelational -> plusMinus . opRelational expRelational
    (39) opRelational -> . EQUAL
    (40) opRelational -> . DIFFERENT
    (41) opRelational -> . GREATERTHAN
    (42) opRelational -> . GREATERTHANEQ
    (43) opRelational -> . LESSTHAN
    (44) opRelational -> . LESSTHANEQ

    EOF             reduce using rule 37 (expRelational -> plusMinus .)
    CPAREN          reduce using rule 37 (expRelational -> plusMinus .)
    EQUAL           shift and go to state 124
    DIFFERENT       shift and go to state 125
    GREATERTHAN     shift and go to state 126
    GREATERTHANEQ   shift and go to state 127
    LESSTHAN        shift and go to state 128
    LESSTHANEQ      shift and go to state 129

    opRelational                   shift and go to state 123

state 94

    (51) expParen -> OPAREN . expRelational CPAREN
    (37) expRelational -> . plusMinus
    (38) expRelational -> . plusMinus opRelational expRelational
    (45) plusMinus -> . multDiv
    (46) plusMinus -> . multDiv PLUS plusMinus
    (47) plusMinus -> . multDiv MINUS plusMinus
    (48) multDiv -> . expParen
    (49) multDiv -> . expParen MULTIPLY multDiv
    (50) multDiv -> . expParen DIVIDE multDiv
    (51) expParen -> . OPAREN expRelational CPAREN
    (52) expParen -> . varCte
    (61) varCte -> . INT
    (62) varCte -> . DEC
    (63) varCte -> . STRING
    (64) varCte -> . ID

    OPAREN          shift and go to state 94
    INT             shift and go to state 98
    DEC             shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 107

    expRelational                  shift and go to state 130
    plusMinus                      shift and go to state 93
    multDiv                        shift and go to state 95
    expParen                       shift and go to state 96
    varCte                         shift and go to state 97

state 95

    (45) plusMinus -> multDiv .
    (46) plusMinus -> multDiv . PLUS plusMinus
    (47) plusMinus -> multDiv . MINUS plusMinus

    EQUAL           reduce using rule 45 (plusMinus -> multDiv .)
    DIFFERENT       reduce using rule 45 (plusMinus -> multDiv .)
    GREATERTHAN     reduce using rule 45 (plusMinus -> multDiv .)
    GREATERTHANEQ   reduce using rule 45 (plusMinus -> multDiv .)
    LESSTHAN        reduce using rule 45 (plusMinus -> multDiv .)
    LESSTHANEQ      reduce using rule 45 (plusMinus -> multDiv .)
    EOF             reduce using rule 45 (plusMinus -> multDiv .)
    CPAREN          reduce using rule 45 (plusMinus -> multDiv .)
    PLUS            shift and go to state 131
    MINUS           shift and go to state 132


state 96

    (48) multDiv -> expParen .
    (49) multDiv -> expParen . MULTIPLY multDiv
    (50) multDiv -> expParen . DIVIDE multDiv

    PLUS            reduce using rule 48 (multDiv -> expParen .)
    MINUS           reduce using rule 48 (multDiv -> expParen .)
    EQUAL           reduce using rule 48 (multDiv -> expParen .)
    DIFFERENT       reduce using rule 48 (multDiv -> expParen .)
    GREATERTHAN     reduce using rule 48 (multDiv -> expParen .)
    GREATERTHANEQ   reduce using rule 48 (multDiv -> expParen .)
    LESSTHAN        reduce using rule 48 (multDiv -> expParen .)
    LESSTHANEQ      reduce using rule 48 (multDiv -> expParen .)
    EOF             reduce using rule 48 (multDiv -> expParen .)
    CPAREN          reduce using rule 48 (multDiv -> expParen .)
    MULTIPLY        shift and go to state 133
    DIVIDE          shift and go to state 134


state 97

    (52) expParen -> varCte .

    MULTIPLY        reduce using rule 52 (expParen -> varCte .)
    DIVIDE          reduce using rule 52 (expParen -> varCte .)
    PLUS            reduce using rule 52 (expParen -> varCte .)
    MINUS           reduce using rule 52 (expParen -> varCte .)
    EQUAL           reduce using rule 52 (expParen -> varCte .)
    DIFFERENT       reduce using rule 52 (expParen -> varCte .)
    GREATERTHAN     reduce using rule 52 (expParen -> varCte .)
    GREATERTHANEQ   reduce using rule 52 (expParen -> varCte .)
    LESSTHAN        reduce using rule 52 (expParen -> varCte .)
    LESSTHANEQ      reduce using rule 52 (expParen -> varCte .)
    EOF             reduce using rule 52 (expParen -> varCte .)
    CPAREN          reduce using rule 52 (expParen -> varCte .)


state 98

    (61) varCte -> INT .

    MULTIPLY        reduce using rule 61 (varCte -> INT .)
    DIVIDE          reduce using rule 61 (varCte -> INT .)
    PLUS            reduce using rule 61 (varCte -> INT .)
    MINUS           reduce using rule 61 (varCte -> INT .)
    EQUAL           reduce using rule 61 (varCte -> INT .)
    DIFFERENT       reduce using rule 61 (varCte -> INT .)
    GREATERTHAN     reduce using rule 61 (varCte -> INT .)
    GREATERTHANEQ   reduce using rule 61 (varCte -> INT .)
    LESSTHAN        reduce using rule 61 (varCte -> INT .)
    LESSTHANEQ      reduce using rule 61 (varCte -> INT .)
    EOF             reduce using rule 61 (varCte -> INT .)
    CPAREN          reduce using rule 61 (varCte -> INT .)
    CSQUAREBR       reduce using rule 61 (varCte -> INT .)


state 99

    (62) varCte -> DEC .

    MULTIPLY        reduce using rule 62 (varCte -> DEC .)
    DIVIDE          reduce using rule 62 (varCte -> DEC .)
    PLUS            reduce using rule 62 (varCte -> DEC .)
    MINUS           reduce using rule 62 (varCte -> DEC .)
    EQUAL           reduce using rule 62 (varCte -> DEC .)
    DIFFERENT       reduce using rule 62 (varCte -> DEC .)
    GREATERTHAN     reduce using rule 62 (varCte -> DEC .)
    GREATERTHANEQ   reduce using rule 62 (varCte -> DEC .)
    LESSTHAN        reduce using rule 62 (varCte -> DEC .)
    LESSTHANEQ      reduce using rule 62 (varCte -> DEC .)
    EOF             reduce using rule 62 (varCte -> DEC .)
    CPAREN          reduce using rule 62 (varCte -> DEC .)
    CSQUAREBR       reduce using rule 62 (varCte -> DEC .)


state 100

    (63) varCte -> STRING .

    MULTIPLY        reduce using rule 63 (varCte -> STRING .)
    DIVIDE          reduce using rule 63 (varCte -> STRING .)
    PLUS            reduce using rule 63 (varCte -> STRING .)
    MINUS           reduce using rule 63 (varCte -> STRING .)
    EQUAL           reduce using rule 63 (varCte -> STRING .)
    DIFFERENT       reduce using rule 63 (varCte -> STRING .)
    GREATERTHAN     reduce using rule 63 (varCte -> STRING .)
    GREATERTHANEQ   reduce using rule 63 (varCte -> STRING .)
    LESSTHAN        reduce using rule 63 (varCte -> STRING .)
    LESSTHANEQ      reduce using rule 63 (varCte -> STRING .)
    EOF             reduce using rule 63 (varCte -> STRING .)
    CPAREN          reduce using rule 63 (varCte -> STRING .)
    CSQUAREBR       reduce using rule 63 (varCte -> STRING .)


state 101

    (9) paramCall -> ID .
    (10) paramCall -> ID . COMMA paramCall

    CPAREN          reduce using rule 9 (paramCall -> ID .)
    COMMA           shift and go to state 135


state 102

    (12) voidCall -> ID OPAREN paramCall . CPAREN EOF

    CPAREN          shift and go to state 136


state 103

    (11) paramCall -> epsilon .

    CPAREN          reduce using rule 11 (paramCall -> epsilon .)


state 104

    (55) classCall -> ID MONEY ID . OPAREN paramCall CPAREN EOF

    OPAREN          shift and go to state 137


state 105

    (68) input -> INPUT OPAREN ID . CPAREN EOF

    CPAREN          shift and go to state 138


state 106

    (69) output -> OUTPUT OPAREN expRelational . CPAREN EOF

    CPAREN          shift and go to state 139


state 107

    (64) varCte -> ID .

    MULTIPLY        reduce using rule 64 (varCte -> ID .)
    DIVIDE          reduce using rule 64 (varCte -> ID .)
    PLUS            reduce using rule 64 (varCte -> ID .)
    MINUS           reduce using rule 64 (varCte -> ID .)
    EQUAL           reduce using rule 64 (varCte -> ID .)
    DIFFERENT       reduce using rule 64 (varCte -> ID .)
    GREATERTHAN     reduce using rule 64 (varCte -> ID .)
    GREATERTHANEQ   reduce using rule 64 (varCte -> ID .)
    LESSTHAN        reduce using rule 64 (varCte -> ID .)
    LESSTHANEQ      reduce using rule 64 (varCte -> ID .)
    CPAREN          reduce using rule 64 (varCte -> ID .)
    CSQUAREBR       reduce using rule 64 (varCte -> ID .)
    EOF             reduce using rule 64 (varCte -> ID .)


state 108

    (65) whileCycle -> WHILE OPAREN expRelational . CPAREN OBRACKET statements CBRACKET

    CPAREN          shift and go to state 140


state 109

    (66) ifCond -> IF OPAREN expRelational . CPAREN OBRACKET statements CBRACKET

    CPAREN          shift and go to state 141


state 110

    (3) fxDef -> VOID FX ID OPAREN param CPAREN OBRACKET body . CBRACKET fxDef

    CBRACKET        shift and go to state 142


state 111

    (7) param -> simpleType ID COMMA param .

    CPAREN          reduce using rule 7 (param -> simpleType ID COMMA param .)


state 112

    (4) fxDef -> simpleType FX ID OPAREN param CPAREN OBRACKET body . RETURN ID EOF CBRACKET fxDef

    RETURN          shift and go to state 143


state 113

    (53) classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef . CBRACKET classDef

    CBRACKET        shift and go to state 144


state 114

    (23) varsDef -> VAR objType var EOF .

    METHODS         reduce using rule 23 (varsDef -> VAR objType var EOF .)
    VAR             reduce using rule 23 (varsDef -> VAR objType var EOF .)
    ID              reduce using rule 23 (varsDef -> VAR objType var EOF .)
    INPUT           reduce using rule 23 (varsDef -> VAR objType var EOF .)
    OUTPUT          reduce using rule 23 (varsDef -> VAR objType var EOF .)
    WHILE           reduce using rule 23 (varsDef -> VAR objType var EOF .)
    IF              reduce using rule 23 (varsDef -> VAR objType var EOF .)
    CBRACKET        reduce using rule 23 (varsDef -> VAR objType var EOF .)
    RETURN          reduce using rule 23 (varsDef -> VAR objType var EOF .)


state 115

    (26) var -> varsType COMMA . var
    (25) var -> . varsType
    (26) var -> . varsType COMMA var
    (27) varsType -> . ID
    (28) varsType -> . arrDef
    (29) varsType -> . matrixDef
    (30) arrDef -> . ID OSQUAREBR varCte CSQUAREBR
    (31) matrixDef -> . arrDef OSQUAREBR varCte CSQUAREBR

    ID              shift and go to state 83

    varsType                       shift and go to state 82
    var                            shift and go to state 145
    arrDef                         shift and go to state 84
    matrixDef                      shift and go to state 85

state 116

    (30) arrDef -> ID OSQUAREBR . varCte CSQUAREBR
    (61) varCte -> . INT
    (62) varCte -> . DEC
    (63) varCte -> . STRING
    (64) varCte -> . ID

    INT             shift and go to state 98
    DEC             shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 107

    varCte                         shift and go to state 146

state 117

    (31) matrixDef -> arrDef OSQUAREBR . varCte CSQUAREBR
    (61) varCte -> . INT
    (62) varCte -> . DEC
    (63) varCte -> . STRING
    (64) varCte -> . ID

    INT             shift and go to state 98
    DEC             shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 107

    varCte                         shift and go to state 147

state 118

    (24) varsDef -> VAR simpleType var EOF .

    METHODS         reduce using rule 24 (varsDef -> VAR simpleType var EOF .)
    VAR             reduce using rule 24 (varsDef -> VAR simpleType var EOF .)
    ID              reduce using rule 24 (varsDef -> VAR simpleType var EOF .)
    INPUT           reduce using rule 24 (varsDef -> VAR simpleType var EOF .)
    OUTPUT          reduce using rule 24 (varsDef -> VAR simpleType var EOF .)
    WHILE           reduce using rule 24 (varsDef -> VAR simpleType var EOF .)
    IF              reduce using rule 24 (varsDef -> VAR simpleType var EOF .)
    CBRACKET        reduce using rule 24 (varsDef -> VAR simpleType var EOF .)
    RETURN          reduce using rule 24 (varsDef -> VAR simpleType var EOF .)


state 119

    (67) ifCond -> ifCond ELSE OBRACKET statements . CBRACKET

    CBRACKET        shift and go to state 148


state 120

    (36) returnCall -> ID OPAREN . paramCall CPAREN
    (9) paramCall -> . ID
    (10) paramCall -> . ID COMMA paramCall
    (11) paramCall -> . epsilon
    (71) epsilon -> .

    ID              shift and go to state 101
    CPAREN          reduce using rule 71 (epsilon -> .)

    paramCall                      shift and go to state 149
    epsilon                        shift and go to state 103

state 121

    (33) expAssignment -> expRelational EOF .

    VAR             reduce using rule 33 (expAssignment -> expRelational EOF .)
    ID              reduce using rule 33 (expAssignment -> expRelational EOF .)
    INPUT           reduce using rule 33 (expAssignment -> expRelational EOF .)
    OUTPUT          reduce using rule 33 (expAssignment -> expRelational EOF .)
    WHILE           reduce using rule 33 (expAssignment -> expRelational EOF .)
    IF              reduce using rule 33 (expAssignment -> expRelational EOF .)
    CBRACKET        reduce using rule 33 (expAssignment -> expRelational EOF .)
    RETURN          reduce using rule 33 (expAssignment -> expRelational EOF .)


state 122

    (34) expAssignment -> returnCall EOF .

    VAR             reduce using rule 34 (expAssignment -> returnCall EOF .)
    ID              reduce using rule 34 (expAssignment -> returnCall EOF .)
    INPUT           reduce using rule 34 (expAssignment -> returnCall EOF .)
    OUTPUT          reduce using rule 34 (expAssignment -> returnCall EOF .)
    WHILE           reduce using rule 34 (expAssignment -> returnCall EOF .)
    IF              reduce using rule 34 (expAssignment -> returnCall EOF .)
    CBRACKET        reduce using rule 34 (expAssignment -> returnCall EOF .)
    RETURN          reduce using rule 34 (expAssignment -> returnCall EOF .)


state 123

    (38) expRelational -> plusMinus opRelational . expRelational
    (37) expRelational -> . plusMinus
    (38) expRelational -> . plusMinus opRelational expRelational
    (45) plusMinus -> . multDiv
    (46) plusMinus -> . multDiv PLUS plusMinus
    (47) plusMinus -> . multDiv MINUS plusMinus
    (48) multDiv -> . expParen
    (49) multDiv -> . expParen MULTIPLY multDiv
    (50) multDiv -> . expParen DIVIDE multDiv
    (51) expParen -> . OPAREN expRelational CPAREN
    (52) expParen -> . varCte
    (61) varCte -> . INT
    (62) varCte -> . DEC
    (63) varCte -> . STRING
    (64) varCte -> . ID

    OPAREN          shift and go to state 94
    INT             shift and go to state 98
    DEC             shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 107

    plusMinus                      shift and go to state 93
    expRelational                  shift and go to state 150
    multDiv                        shift and go to state 95
    expParen                       shift and go to state 96
    varCte                         shift and go to state 97

state 124

    (39) opRelational -> EQUAL .

    OPAREN          reduce using rule 39 (opRelational -> EQUAL .)
    INT             reduce using rule 39 (opRelational -> EQUAL .)
    DEC             reduce using rule 39 (opRelational -> EQUAL .)
    STRING          reduce using rule 39 (opRelational -> EQUAL .)
    ID              reduce using rule 39 (opRelational -> EQUAL .)


state 125

    (40) opRelational -> DIFFERENT .

    OPAREN          reduce using rule 40 (opRelational -> DIFFERENT .)
    INT             reduce using rule 40 (opRelational -> DIFFERENT .)
    DEC             reduce using rule 40 (opRelational -> DIFFERENT .)
    STRING          reduce using rule 40 (opRelational -> DIFFERENT .)
    ID              reduce using rule 40 (opRelational -> DIFFERENT .)


state 126

    (41) opRelational -> GREATERTHAN .

    OPAREN          reduce using rule 41 (opRelational -> GREATERTHAN .)
    INT             reduce using rule 41 (opRelational -> GREATERTHAN .)
    DEC             reduce using rule 41 (opRelational -> GREATERTHAN .)
    STRING          reduce using rule 41 (opRelational -> GREATERTHAN .)
    ID              reduce using rule 41 (opRelational -> GREATERTHAN .)


state 127

    (42) opRelational -> GREATERTHANEQ .

    OPAREN          reduce using rule 42 (opRelational -> GREATERTHANEQ .)
    INT             reduce using rule 42 (opRelational -> GREATERTHANEQ .)
    DEC             reduce using rule 42 (opRelational -> GREATERTHANEQ .)
    STRING          reduce using rule 42 (opRelational -> GREATERTHANEQ .)
    ID              reduce using rule 42 (opRelational -> GREATERTHANEQ .)


state 128

    (43) opRelational -> LESSTHAN .

    OPAREN          reduce using rule 43 (opRelational -> LESSTHAN .)
    INT             reduce using rule 43 (opRelational -> LESSTHAN .)
    DEC             reduce using rule 43 (opRelational -> LESSTHAN .)
    STRING          reduce using rule 43 (opRelational -> LESSTHAN .)
    ID              reduce using rule 43 (opRelational -> LESSTHAN .)


state 129

    (44) opRelational -> LESSTHANEQ .

    OPAREN          reduce using rule 44 (opRelational -> LESSTHANEQ .)
    INT             reduce using rule 44 (opRelational -> LESSTHANEQ .)
    DEC             reduce using rule 44 (opRelational -> LESSTHANEQ .)
    STRING          reduce using rule 44 (opRelational -> LESSTHANEQ .)
    ID              reduce using rule 44 (opRelational -> LESSTHANEQ .)


state 130

    (51) expParen -> OPAREN expRelational . CPAREN

    CPAREN          shift and go to state 151


state 131

    (46) plusMinus -> multDiv PLUS . plusMinus
    (45) plusMinus -> . multDiv
    (46) plusMinus -> . multDiv PLUS plusMinus
    (47) plusMinus -> . multDiv MINUS plusMinus
    (48) multDiv -> . expParen
    (49) multDiv -> . expParen MULTIPLY multDiv
    (50) multDiv -> . expParen DIVIDE multDiv
    (51) expParen -> . OPAREN expRelational CPAREN
    (52) expParen -> . varCte
    (61) varCte -> . INT
    (62) varCte -> . DEC
    (63) varCte -> . STRING
    (64) varCte -> . ID

    OPAREN          shift and go to state 94
    INT             shift and go to state 98
    DEC             shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 107

    multDiv                        shift and go to state 95
    plusMinus                      shift and go to state 152
    expParen                       shift and go to state 96
    varCte                         shift and go to state 97

state 132

    (47) plusMinus -> multDiv MINUS . plusMinus
    (45) plusMinus -> . multDiv
    (46) plusMinus -> . multDiv PLUS plusMinus
    (47) plusMinus -> . multDiv MINUS plusMinus
    (48) multDiv -> . expParen
    (49) multDiv -> . expParen MULTIPLY multDiv
    (50) multDiv -> . expParen DIVIDE multDiv
    (51) expParen -> . OPAREN expRelational CPAREN
    (52) expParen -> . varCte
    (61) varCte -> . INT
    (62) varCte -> . DEC
    (63) varCte -> . STRING
    (64) varCte -> . ID

    OPAREN          shift and go to state 94
    INT             shift and go to state 98
    DEC             shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 107

    multDiv                        shift and go to state 95
    plusMinus                      shift and go to state 153
    expParen                       shift and go to state 96
    varCte                         shift and go to state 97

state 133

    (49) multDiv -> expParen MULTIPLY . multDiv
    (48) multDiv -> . expParen
    (49) multDiv -> . expParen MULTIPLY multDiv
    (50) multDiv -> . expParen DIVIDE multDiv
    (51) expParen -> . OPAREN expRelational CPAREN
    (52) expParen -> . varCte
    (61) varCte -> . INT
    (62) varCte -> . DEC
    (63) varCte -> . STRING
    (64) varCte -> . ID

    OPAREN          shift and go to state 94
    INT             shift and go to state 98
    DEC             shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 107

    expParen                       shift and go to state 96
    multDiv                        shift and go to state 154
    varCte                         shift and go to state 97

state 134

    (50) multDiv -> expParen DIVIDE . multDiv
    (48) multDiv -> . expParen
    (49) multDiv -> . expParen MULTIPLY multDiv
    (50) multDiv -> . expParen DIVIDE multDiv
    (51) expParen -> . OPAREN expRelational CPAREN
    (52) expParen -> . varCte
    (61) varCte -> . INT
    (62) varCte -> . DEC
    (63) varCte -> . STRING
    (64) varCte -> . ID

    OPAREN          shift and go to state 94
    INT             shift and go to state 98
    DEC             shift and go to state 99
    STRING          shift and go to state 100
    ID              shift and go to state 107

    expParen                       shift and go to state 96
    multDiv                        shift and go to state 155
    varCte                         shift and go to state 97

state 135

    (10) paramCall -> ID COMMA . paramCall
    (9) paramCall -> . ID
    (10) paramCall -> . ID COMMA paramCall
    (11) paramCall -> . epsilon
    (71) epsilon -> .

    ID              shift and go to state 101
    CPAREN          reduce using rule 71 (epsilon -> .)

    paramCall                      shift and go to state 156
    epsilon                        shift and go to state 103

state 136

    (12) voidCall -> ID OPAREN paramCall CPAREN . EOF

    EOF             shift and go to state 157


state 137

    (55) classCall -> ID MONEY ID OPAREN . paramCall CPAREN EOF
    (9) paramCall -> . ID
    (10) paramCall -> . ID COMMA paramCall
    (11) paramCall -> . epsilon
    (71) epsilon -> .

    ID              shift and go to state 101
    CPAREN          reduce using rule 71 (epsilon -> .)

    paramCall                      shift and go to state 158
    epsilon                        shift and go to state 103

state 138

    (68) input -> INPUT OPAREN ID CPAREN . EOF

    EOF             shift and go to state 159


state 139

    (69) output -> OUTPUT OPAREN expRelational CPAREN . EOF

    EOF             shift and go to state 160


state 140

    (65) whileCycle -> WHILE OPAREN expRelational CPAREN . OBRACKET statements CBRACKET

    OBRACKET        shift and go to state 161


state 141

    (66) ifCond -> IF OPAREN expRelational CPAREN . OBRACKET statements CBRACKET

    OBRACKET        shift and go to state 162


state 142

    (3) fxDef -> VOID FX ID OPAREN param CPAREN OBRACKET body CBRACKET . fxDef
    (3) fxDef -> . VOID FX ID OPAREN param CPAREN OBRACKET body CBRACKET fxDef
    (4) fxDef -> . simpleType FX ID OPAREN param CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef
    (5) fxDef -> . epsilon
    (56) simpleType -> . INT
    (57) simpleType -> . STRING
    (58) simpleType -> . DEC
    (59) simpleType -> . BOOL
    (71) epsilon -> .

    VOID            shift and go to state 10
    INT             shift and go to state 13
    STRING          shift and go to state 14
    DEC             shift and go to state 15
    BOOL            shift and go to state 16
    MAIN            reduce using rule 71 (epsilon -> .)
    CBRACKET        reduce using rule 71 (epsilon -> .)

    fxDef                          shift and go to state 163
    simpleType                     shift and go to state 11
    epsilon                        shift and go to state 12

state 143

    (4) fxDef -> simpleType FX ID OPAREN param CPAREN OBRACKET body RETURN . ID EOF CBRACKET fxDef

    ID              shift and go to state 164


state 144

    (53) classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET . classDef
    (53) classDef -> . CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef
    (54) classDef -> . epsilon
    (71) epsilon -> .

    CLASS           shift and go to state 7
    VOID            reduce using rule 71 (epsilon -> .)
    INT             reduce using rule 71 (epsilon -> .)
    STRING          reduce using rule 71 (epsilon -> .)
    DEC             reduce using rule 71 (epsilon -> .)
    BOOL            reduce using rule 71 (epsilon -> .)
    MAIN            reduce using rule 71 (epsilon -> .)

    classDef                       shift and go to state 165
    epsilon                        shift and go to state 8

state 145

    (26) var -> varsType COMMA var .

    EOF             reduce using rule 26 (var -> varsType COMMA var .)


state 146

    (30) arrDef -> ID OSQUAREBR varCte . CSQUAREBR

    CSQUAREBR       shift and go to state 166


state 147

    (31) matrixDef -> arrDef OSQUAREBR varCte . CSQUAREBR

    CSQUAREBR       shift and go to state 167


state 148

    (67) ifCond -> ifCond ELSE OBRACKET statements CBRACKET .

    ELSE            reduce using rule 67 (ifCond -> ifCond ELSE OBRACKET statements CBRACKET .)
    VAR             reduce using rule 67 (ifCond -> ifCond ELSE OBRACKET statements CBRACKET .)
    ID              reduce using rule 67 (ifCond -> ifCond ELSE OBRACKET statements CBRACKET .)
    INPUT           reduce using rule 67 (ifCond -> ifCond ELSE OBRACKET statements CBRACKET .)
    OUTPUT          reduce using rule 67 (ifCond -> ifCond ELSE OBRACKET statements CBRACKET .)
    WHILE           reduce using rule 67 (ifCond -> ifCond ELSE OBRACKET statements CBRACKET .)
    IF              reduce using rule 67 (ifCond -> ifCond ELSE OBRACKET statements CBRACKET .)
    CBRACKET        reduce using rule 67 (ifCond -> ifCond ELSE OBRACKET statements CBRACKET .)
    RETURN          reduce using rule 67 (ifCond -> ifCond ELSE OBRACKET statements CBRACKET .)


state 149

    (36) returnCall -> ID OPAREN paramCall . CPAREN

    CPAREN          shift and go to state 168


state 150

    (38) expRelational -> plusMinus opRelational expRelational .

    EOF             reduce using rule 38 (expRelational -> plusMinus opRelational expRelational .)
    CPAREN          reduce using rule 38 (expRelational -> plusMinus opRelational expRelational .)


state 151

    (51) expParen -> OPAREN expRelational CPAREN .

    MULTIPLY        reduce using rule 51 (expParen -> OPAREN expRelational CPAREN .)
    DIVIDE          reduce using rule 51 (expParen -> OPAREN expRelational CPAREN .)
    PLUS            reduce using rule 51 (expParen -> OPAREN expRelational CPAREN .)
    MINUS           reduce using rule 51 (expParen -> OPAREN expRelational CPAREN .)
    EQUAL           reduce using rule 51 (expParen -> OPAREN expRelational CPAREN .)
    DIFFERENT       reduce using rule 51 (expParen -> OPAREN expRelational CPAREN .)
    GREATERTHAN     reduce using rule 51 (expParen -> OPAREN expRelational CPAREN .)
    GREATERTHANEQ   reduce using rule 51 (expParen -> OPAREN expRelational CPAREN .)
    LESSTHAN        reduce using rule 51 (expParen -> OPAREN expRelational CPAREN .)
    LESSTHANEQ      reduce using rule 51 (expParen -> OPAREN expRelational CPAREN .)
    EOF             reduce using rule 51 (expParen -> OPAREN expRelational CPAREN .)
    CPAREN          reduce using rule 51 (expParen -> OPAREN expRelational CPAREN .)


state 152

    (46) plusMinus -> multDiv PLUS plusMinus .

    EQUAL           reduce using rule 46 (plusMinus -> multDiv PLUS plusMinus .)
    DIFFERENT       reduce using rule 46 (plusMinus -> multDiv PLUS plusMinus .)
    GREATERTHAN     reduce using rule 46 (plusMinus -> multDiv PLUS plusMinus .)
    GREATERTHANEQ   reduce using rule 46 (plusMinus -> multDiv PLUS plusMinus .)
    LESSTHAN        reduce using rule 46 (plusMinus -> multDiv PLUS plusMinus .)
    LESSTHANEQ      reduce using rule 46 (plusMinus -> multDiv PLUS plusMinus .)
    EOF             reduce using rule 46 (plusMinus -> multDiv PLUS plusMinus .)
    CPAREN          reduce using rule 46 (plusMinus -> multDiv PLUS plusMinus .)


state 153

    (47) plusMinus -> multDiv MINUS plusMinus .

    EQUAL           reduce using rule 47 (plusMinus -> multDiv MINUS plusMinus .)
    DIFFERENT       reduce using rule 47 (plusMinus -> multDiv MINUS plusMinus .)
    GREATERTHAN     reduce using rule 47 (plusMinus -> multDiv MINUS plusMinus .)
    GREATERTHANEQ   reduce using rule 47 (plusMinus -> multDiv MINUS plusMinus .)
    LESSTHAN        reduce using rule 47 (plusMinus -> multDiv MINUS plusMinus .)
    LESSTHANEQ      reduce using rule 47 (plusMinus -> multDiv MINUS plusMinus .)
    EOF             reduce using rule 47 (plusMinus -> multDiv MINUS plusMinus .)
    CPAREN          reduce using rule 47 (plusMinus -> multDiv MINUS plusMinus .)


state 154

    (49) multDiv -> expParen MULTIPLY multDiv .

    PLUS            reduce using rule 49 (multDiv -> expParen MULTIPLY multDiv .)
    MINUS           reduce using rule 49 (multDiv -> expParen MULTIPLY multDiv .)
    EQUAL           reduce using rule 49 (multDiv -> expParen MULTIPLY multDiv .)
    DIFFERENT       reduce using rule 49 (multDiv -> expParen MULTIPLY multDiv .)
    GREATERTHAN     reduce using rule 49 (multDiv -> expParen MULTIPLY multDiv .)
    GREATERTHANEQ   reduce using rule 49 (multDiv -> expParen MULTIPLY multDiv .)
    LESSTHAN        reduce using rule 49 (multDiv -> expParen MULTIPLY multDiv .)
    LESSTHANEQ      reduce using rule 49 (multDiv -> expParen MULTIPLY multDiv .)
    EOF             reduce using rule 49 (multDiv -> expParen MULTIPLY multDiv .)
    CPAREN          reduce using rule 49 (multDiv -> expParen MULTIPLY multDiv .)


state 155

    (50) multDiv -> expParen DIVIDE multDiv .

    PLUS            reduce using rule 50 (multDiv -> expParen DIVIDE multDiv .)
    MINUS           reduce using rule 50 (multDiv -> expParen DIVIDE multDiv .)
    EQUAL           reduce using rule 50 (multDiv -> expParen DIVIDE multDiv .)
    DIFFERENT       reduce using rule 50 (multDiv -> expParen DIVIDE multDiv .)
    GREATERTHAN     reduce using rule 50 (multDiv -> expParen DIVIDE multDiv .)
    GREATERTHANEQ   reduce using rule 50 (multDiv -> expParen DIVIDE multDiv .)
    LESSTHAN        reduce using rule 50 (multDiv -> expParen DIVIDE multDiv .)
    LESSTHANEQ      reduce using rule 50 (multDiv -> expParen DIVIDE multDiv .)
    EOF             reduce using rule 50 (multDiv -> expParen DIVIDE multDiv .)
    CPAREN          reduce using rule 50 (multDiv -> expParen DIVIDE multDiv .)


state 156

    (10) paramCall -> ID COMMA paramCall .

    CPAREN          reduce using rule 10 (paramCall -> ID COMMA paramCall .)


state 157

    (12) voidCall -> ID OPAREN paramCall CPAREN EOF .

    VAR             reduce using rule 12 (voidCall -> ID OPAREN paramCall CPAREN EOF .)
    ID              reduce using rule 12 (voidCall -> ID OPAREN paramCall CPAREN EOF .)
    INPUT           reduce using rule 12 (voidCall -> ID OPAREN paramCall CPAREN EOF .)
    OUTPUT          reduce using rule 12 (voidCall -> ID OPAREN paramCall CPAREN EOF .)
    WHILE           reduce using rule 12 (voidCall -> ID OPAREN paramCall CPAREN EOF .)
    IF              reduce using rule 12 (voidCall -> ID OPAREN paramCall CPAREN EOF .)
    CBRACKET        reduce using rule 12 (voidCall -> ID OPAREN paramCall CPAREN EOF .)
    RETURN          reduce using rule 12 (voidCall -> ID OPAREN paramCall CPAREN EOF .)


state 158

    (55) classCall -> ID MONEY ID OPAREN paramCall . CPAREN EOF

    CPAREN          shift and go to state 169


state 159

    (68) input -> INPUT OPAREN ID CPAREN EOF .

    VAR             reduce using rule 68 (input -> INPUT OPAREN ID CPAREN EOF .)
    ID              reduce using rule 68 (input -> INPUT OPAREN ID CPAREN EOF .)
    INPUT           reduce using rule 68 (input -> INPUT OPAREN ID CPAREN EOF .)
    OUTPUT          reduce using rule 68 (input -> INPUT OPAREN ID CPAREN EOF .)
    WHILE           reduce using rule 68 (input -> INPUT OPAREN ID CPAREN EOF .)
    IF              reduce using rule 68 (input -> INPUT OPAREN ID CPAREN EOF .)
    CBRACKET        reduce using rule 68 (input -> INPUT OPAREN ID CPAREN EOF .)
    RETURN          reduce using rule 68 (input -> INPUT OPAREN ID CPAREN EOF .)


state 160

    (69) output -> OUTPUT OPAREN expRelational CPAREN EOF .

    VAR             reduce using rule 69 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    ID              reduce using rule 69 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    INPUT           reduce using rule 69 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    OUTPUT          reduce using rule 69 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    WHILE           reduce using rule 69 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    IF              reduce using rule 69 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    CBRACKET        reduce using rule 69 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    RETURN          reduce using rule 69 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)


state 161

    (65) whileCycle -> WHILE OPAREN expRelational CPAREN OBRACKET . statements CBRACKET
    (16) statements -> . assignmentDef
    (17) statements -> . input
    (18) statements -> . output
    (19) statements -> . voidCall
    (20) statements -> . whileCycle
    (21) statements -> . ifCond
    (22) statements -> . classCall
    (32) assignmentDef -> . ID ASSIGNMENT expAssignment
    (68) input -> . INPUT OPAREN ID CPAREN EOF
    (69) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (12) voidCall -> . ID OPAREN paramCall CPAREN EOF
    (65) whileCycle -> . WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (66) ifCond -> . IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (67) ifCond -> . ifCond ELSE OBRACKET statements CBRACKET
    (55) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF

    ID              shift and go to state 54
    INPUT           shift and go to state 55
    OUTPUT          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 58

    statements                     shift and go to state 170
    assignmentDef                  shift and go to state 47
    input                          shift and go to state 48
    output                         shift and go to state 49
    voidCall                       shift and go to state 50
    whileCycle                     shift and go to state 51
    ifCond                         shift and go to state 52
    classCall                      shift and go to state 53

state 162

    (66) ifCond -> IF OPAREN expRelational CPAREN OBRACKET . statements CBRACKET
    (16) statements -> . assignmentDef
    (17) statements -> . input
    (18) statements -> . output
    (19) statements -> . voidCall
    (20) statements -> . whileCycle
    (21) statements -> . ifCond
    (22) statements -> . classCall
    (32) assignmentDef -> . ID ASSIGNMENT expAssignment
    (68) input -> . INPUT OPAREN ID CPAREN EOF
    (69) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (12) voidCall -> . ID OPAREN paramCall CPAREN EOF
    (65) whileCycle -> . WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (66) ifCond -> . IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET
    (67) ifCond -> . ifCond ELSE OBRACKET statements CBRACKET
    (55) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF

    ID              shift and go to state 54
    INPUT           shift and go to state 55
    OUTPUT          shift and go to state 56
    WHILE           shift and go to state 57
    IF              shift and go to state 58

    statements                     shift and go to state 171
    assignmentDef                  shift and go to state 47
    input                          shift and go to state 48
    output                         shift and go to state 49
    voidCall                       shift and go to state 50
    whileCycle                     shift and go to state 51
    ifCond                         shift and go to state 52
    classCall                      shift and go to state 53

state 163

    (3) fxDef -> VOID FX ID OPAREN param CPAREN OBRACKET body CBRACKET fxDef .

    MAIN            reduce using rule 3 (fxDef -> VOID FX ID OPAREN param CPAREN OBRACKET body CBRACKET fxDef .)
    CBRACKET        reduce using rule 3 (fxDef -> VOID FX ID OPAREN param CPAREN OBRACKET body CBRACKET fxDef .)


state 164

    (4) fxDef -> simpleType FX ID OPAREN param CPAREN OBRACKET body RETURN ID . EOF CBRACKET fxDef

    EOF             shift and go to state 172


state 165

    (53) classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef .

    VOID            reduce using rule 53 (classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef .)
    INT             reduce using rule 53 (classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef .)
    STRING          reduce using rule 53 (classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef .)
    DEC             reduce using rule 53 (classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef .)
    BOOL            reduce using rule 53 (classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef .)
    MAIN            reduce using rule 53 (classDef -> CLASS ID OBRACKET ATTRIBUTES COLON varsDef METHODS COLON fxDef CBRACKET classDef .)


state 166

    (30) arrDef -> ID OSQUAREBR varCte CSQUAREBR .

    OSQUAREBR       reduce using rule 30 (arrDef -> ID OSQUAREBR varCte CSQUAREBR .)
    COMMA           reduce using rule 30 (arrDef -> ID OSQUAREBR varCte CSQUAREBR .)
    EOF             reduce using rule 30 (arrDef -> ID OSQUAREBR varCte CSQUAREBR .)


state 167

    (31) matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR .

    COMMA           reduce using rule 31 (matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR .)
    EOF             reduce using rule 31 (matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR .)


state 168

    (36) returnCall -> ID OPAREN paramCall CPAREN .

    EOF             reduce using rule 36 (returnCall -> ID OPAREN paramCall CPAREN .)


state 169

    (55) classCall -> ID MONEY ID OPAREN paramCall CPAREN . EOF

    EOF             shift and go to state 173


state 170

    (65) whileCycle -> WHILE OPAREN expRelational CPAREN OBRACKET statements . CBRACKET

    CBRACKET        shift and go to state 174


state 171

    (66) ifCond -> IF OPAREN expRelational CPAREN OBRACKET statements . CBRACKET

    CBRACKET        shift and go to state 175


state 172

    (4) fxDef -> simpleType FX ID OPAREN param CPAREN OBRACKET body RETURN ID EOF . CBRACKET fxDef

    CBRACKET        shift and go to state 176


state 173

    (55) classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .

    VAR             reduce using rule 55 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    ID              reduce using rule 55 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    INPUT           reduce using rule 55 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    OUTPUT          reduce using rule 55 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    WHILE           reduce using rule 55 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    IF              reduce using rule 55 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    CBRACKET        reduce using rule 55 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    RETURN          reduce using rule 55 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)


state 174

    (65) whileCycle -> WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET .

    VAR             reduce using rule 65 (whileCycle -> WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    ID              reduce using rule 65 (whileCycle -> WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    INPUT           reduce using rule 65 (whileCycle -> WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    OUTPUT          reduce using rule 65 (whileCycle -> WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    WHILE           reduce using rule 65 (whileCycle -> WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    IF              reduce using rule 65 (whileCycle -> WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    CBRACKET        reduce using rule 65 (whileCycle -> WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    RETURN          reduce using rule 65 (whileCycle -> WHILE OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)


state 175

    (66) ifCond -> IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET .

    ELSE            reduce using rule 66 (ifCond -> IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    VAR             reduce using rule 66 (ifCond -> IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    ID              reduce using rule 66 (ifCond -> IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    INPUT           reduce using rule 66 (ifCond -> IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    OUTPUT          reduce using rule 66 (ifCond -> IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    WHILE           reduce using rule 66 (ifCond -> IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    IF              reduce using rule 66 (ifCond -> IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    CBRACKET        reduce using rule 66 (ifCond -> IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)
    RETURN          reduce using rule 66 (ifCond -> IF OPAREN expRelational CPAREN OBRACKET statements CBRACKET .)


state 176

    (4) fxDef -> simpleType FX ID OPAREN param CPAREN OBRACKET body RETURN ID EOF CBRACKET . fxDef
    (3) fxDef -> . VOID FX ID OPAREN param CPAREN OBRACKET body CBRACKET fxDef
    (4) fxDef -> . simpleType FX ID OPAREN param CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef
    (5) fxDef -> . epsilon
    (56) simpleType -> . INT
    (57) simpleType -> . STRING
    (58) simpleType -> . DEC
    (59) simpleType -> . BOOL
    (71) epsilon -> .

    VOID            shift and go to state 10
    INT             shift and go to state 13
    STRING          shift and go to state 14
    DEC             shift and go to state 15
    BOOL            shift and go to state 16
    MAIN            reduce using rule 71 (epsilon -> .)
    CBRACKET        reduce using rule 71 (epsilon -> .)

    simpleType                     shift and go to state 11
    fxDef                          shift and go to state 177
    epsilon                        shift and go to state 12

state 177

    (4) fxDef -> simpleType FX ID OPAREN param CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef .

    MAIN            reduce using rule 4 (fxDef -> simpleType FX ID OPAREN param CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef .)
    CBRACKET        reduce using rule 4 (fxDef -> simpleType FX ID OPAREN param CPAREN OBRACKET body RETURN ID EOF CBRACKET fxDef .)

