Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> begin
Rule 1     begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end
Rule 2     pointCreateMainCuac -> <empty>
Rule 3     pointMain -> <empty>
Rule 4     main -> MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET
Rule 5     fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
Rule 6     fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
Rule 7     fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
Rule 8     fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
Rule 9     fxDef -> epsilon
Rule 10    fxType -> INT
Rule 11    fxType -> STRING
Rule 12    fxType -> DEC
Rule 13    fxType -> BOOL
Rule 14    pointFx -> <empty>
Rule 15    pointFxId -> <empty>
Rule 16    pointReturn -> <empty>
Rule 17    pointEndFunc -> <empty>
Rule 18    param -> paramType ID pointParam
Rule 19    param -> paramType ID pointParam COMMA param
Rule 20    paramType -> INT
Rule 21    paramType -> STRING
Rule 22    paramType -> DEC
Rule 23    paramType -> BOOL
Rule 24    pointParam -> <empty>
Rule 25    paramCall -> ID pointParamCall pointParamNum
Rule 26    paramCall -> ID pointParamCall COMMA paramCall
Rule 27    pointParamNum -> <empty>
Rule 28    pointParamCall -> <empty>
Rule 29    voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
Rule 30    voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
Rule 31    pointEra -> <empty>
Rule 32    pointGoSub -> <empty>
Rule 33    body -> varsDef body
Rule 34    body -> statements body
Rule 35    body -> epsilon
Rule 36    statements -> assignmentDef
Rule 37    statements -> input
Rule 38    statements -> output
Rule 39    statements -> voidCall
Rule 40    statements -> whileCycle
Rule 41    statements -> ifCond
Rule 42    statements -> classCall
Rule 43    varsDef -> VAR objType var EOF
Rule 44    varsDef -> VAR varSimpleType var EOF
Rule 45    varSimpleType -> INT
Rule 46    varSimpleType -> STRING
Rule 47    varSimpleType -> DEC
Rule 48    varSimpleType -> BOOL
Rule 49    var -> varsType
Rule 50    var -> varsType COMMA var
Rule 51    varsType -> ID
Rule 52    varsType -> arrDef
Rule 53    varsType -> matrixDef
Rule 54    arrDef -> ID OSQUAREBR varCte CSQUAREBR
Rule 55    matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR
Rule 56    assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment
Rule 57    pointPushAssignment -> <empty>
Rule 58    expAssignment -> expRelational EOF
Rule 59    expAssignment -> returnCall EOF
Rule 60    expAssignment -> classCall
Rule 61    returnCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN
Rule 62    returnCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN
Rule 63    expRelational -> plusMinus
Rule 64    expRelational -> plusMinus opRelational expRelational pointCheckOpRel
Rule 65    pointCheckOpRel -> <empty>
Rule 66    opRelational -> EQUAL
Rule 67    opRelational -> DIFFERENT
Rule 68    opRelational -> GREATERTHAN
Rule 69    opRelational -> GREATERTHANEQ
Rule 70    opRelational -> LESSTHAN
Rule 71    opRelational -> LESSTHANEQ
Rule 72    plusMinus -> multDiv pointCheckPlusMinus
Rule 73    plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
Rule 74    plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
Rule 75    pointCheckPlusMinus -> <empty>
Rule 76    pointPushPlusMinus -> <empty>
Rule 77    multDiv -> expParen pointCheckMultDiv
Rule 78    multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
Rule 79    multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
Rule 80    pointCheckMultDiv -> <empty>
Rule 81    pointPushMultDiv -> <empty>
Rule 82    expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
Rule 83    expParen -> varCte
Rule 84    pointFakeBackground -> <empty>
Rule 85    pointRemoveFakeBackground -> <empty>
Rule 86    classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
Rule 87    classDef -> epsilon
Rule 88    pointAtt -> varsDef
Rule 89    pointAtt -> varsDef pointAtt
Rule 90    pointScopeClass -> <empty>
Rule 91    pointScopeClass2 -> <empty>
Rule 92    pointClassName -> <empty>
Rule 93    pointClass -> <empty>
Rule 94    classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF
Rule 95    classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF
Rule 96    objType -> ID
Rule 97    varCte -> INT pointINT
Rule 98    varCte -> DEC pointDEC
Rule 99    varCte -> STRING pointSTRING
Rule 100   varCte -> ID
Rule 101   pointINT -> <empty>
Rule 102   pointDEC -> <empty>
Rule 103   pointSTRING -> <empty>
Rule 104   whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
Rule 105   pointWhile1 -> <empty>
Rule 106   pointWhile2 -> <empty>
Rule 107   pointWhile3 -> <empty>
Rule 108   ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
Rule 109   ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
Rule 110   pointIfCond1 -> <empty>
Rule 111   pointIfCond2 -> <empty>
Rule 112   pointIfCond3 -> <empty>
Rule 113   input -> INPUT OPAREN ID CPAREN EOF
Rule 114   output -> OUTPUT OPAREN expRelational CPAREN EOF
Rule 115   end -> END OPAREN ID CPAREN
Rule 116   epsilon -> <empty>

Terminals, with rules where they appear

ASSIGNMENT           : 56
ATTRIBUTES           : 86
BEGIN                : 1
BOOL                 : 13 23 48
CBRACKET             : 4 5 6 7 8 86 104 108 109 109
CLASS                : 86
COLON                : 86 86
COMMA                : 19 26 50
CPAREN               : 1 4 5 6 7 8 29 30 61 62 82 94 95 104 108 109 113 114 115
CSQUAREBR            : 54 55
DEC                  : 12 22 47 98
DIFFERENT            : 67
DIVIDE               : 79
ELSE                 : 109
END                  : 115
EOF                  : 7 8 29 30 43 44 58 59 94 95 113 114
EQUAL                : 66
FX                   : 5 6 7 8
GREATERTHAN          : 68
GREATERTHANEQ        : 69
ID                   : 1 5 6 7 7 8 8 18 19 25 26 29 30 51 54 56 61 62 86 94 94 95 95 96 100 113 115
IF                   : 108 109
INPUT                : 113
INT                  : 10 20 45 97
LESSTHAN             : 70
LESSTHANEQ           : 71
MAIN                 : 4
METHODS              : 86
MINUS                : 74
MONEY                : 94 95
MULTIPLY             : 78
OBRACKET             : 4 5 6 7 8 86 104 108 109 109
OPAREN               : 1 4 5 6 7 8 29 30 61 62 82 94 95 104 108 109 113 114 115
OSQUAREBR            : 54 55
OUTPUT               : 114
PLUS                 : 73
RETURN               : 7 8
STRING               : 11 21 46 99
VAR                  : 43 44
VOID                 : 5 6
WHILE                : 104
error                : 

Nonterminals, with rules where they appear

arrDef               : 52 55
assignmentDef        : 36
begin                : 0
body                 : 4 5 6 7 8 33 34 104 108 109 109
classCall            : 42 60
classDef             : 1 86
end                  : 1
epsilon              : 6 8 9 30 35 62 87 95
expAssignment        : 56
expParen             : 77 78 79
expRelational        : 58 64 82 104 108 109 114
fxDef                : 1 5 6 7 8 86
fxType               : 7 8
ifCond               : 41
input                : 37
main                 : 1
matrixDef            : 53
multDiv              : 72 73 74 78 79
objType              : 43
opRelational         : 64
output               : 38
param                : 5 7 19
paramCall            : 26 29 61 94
paramType            : 18 19
plusMinus            : 63 64 73 74
pointAtt             : 86 89
pointCheckMultDiv    : 77 78 79
pointCheckOpRel      : 64
pointCheckPlusMinus  : 72 73 74
pointClass           : 86
pointClassName       : 86
pointCreateMainCuac  : 1
pointDEC             : 98
pointEndFunc         : 5 6 7 8
pointEra             : 29 30 61 62
pointFakeBackground  : 82
pointFx              : 5 6 7 8
pointFxId            : 5 6 7 8
pointGoSub           : 29 30 61 62
pointINT             : 97
pointIfCond1         : 108 109
pointIfCond2         : 108 109
pointIfCond3         : 109
pointMain            : 4
pointParam           : 18 19
pointParamCall       : 25 26
pointParamNum        : 25
pointPushAssignment  : 56
pointPushMultDiv     : 78 79
pointPushPlusMinus   : 73 74
pointRemoveFakeBackground : 82
pointReturn          : 7 8
pointSTRING          : 99
pointScopeClass      : 86
pointScopeClass2     : 86
pointWhile1          : 104
pointWhile2          : 104
pointWhile3          : 104
returnCall           : 59
statements           : 34
var                  : 43 44 50
varCte               : 54 55 83
varSimpleType        : 44
varsDef              : 33 88 89
varsType             : 49 50
voidCall             : 39
whileCycle           : 40

Parsing method: LALR

state 0

    (0) S' -> . begin
    (1) begin -> . BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end

    BEGIN           shift and go to state 2

    begin                          shift and go to state 1

state 1

    (0) S' -> begin .



state 2

    (1) begin -> BEGIN . pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end
    (2) pointCreateMainCuac -> .

    OPAREN          reduce using rule 2 (pointCreateMainCuac -> .)

    pointCreateMainCuac            shift and go to state 3

state 3

    (1) begin -> BEGIN pointCreateMainCuac . OPAREN ID CPAREN classDef fxDef main end

    OPAREN          shift and go to state 4


state 4

    (1) begin -> BEGIN pointCreateMainCuac OPAREN . ID CPAREN classDef fxDef main end

    ID              shift and go to state 5


state 5

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID . CPAREN classDef fxDef main end

    CPAREN          shift and go to state 6


state 6

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN . classDef fxDef main end
    (86) classDef -> . CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (87) classDef -> . epsilon
    (116) epsilon -> .

    CLASS           shift and go to state 8
    VOID            reduce using rule 116 (epsilon -> .)
    INT             reduce using rule 116 (epsilon -> .)
    STRING          reduce using rule 116 (epsilon -> .)
    DEC             reduce using rule 116 (epsilon -> .)
    BOOL            reduce using rule 116 (epsilon -> .)
    MAIN            reduce using rule 116 (epsilon -> .)

    classDef                       shift and go to state 7
    epsilon                        shift and go to state 9

state 7

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef . fxDef main end
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (116) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 116 (epsilon -> .)

    fxDef                          shift and go to state 10
    epsilon                        shift and go to state 12
    fxType                         shift and go to state 13

state 8

    (86) classDef -> CLASS . pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (93) pointClass -> .

    ID              reduce using rule 93 (pointClass -> .)

    pointClass                     shift and go to state 18

state 9

    (87) classDef -> epsilon .

    VOID            reduce using rule 87 (classDef -> epsilon .)
    INT             reduce using rule 87 (classDef -> epsilon .)
    STRING          reduce using rule 87 (classDef -> epsilon .)
    DEC             reduce using rule 87 (classDef -> epsilon .)
    BOOL            reduce using rule 87 (classDef -> epsilon .)
    MAIN            reduce using rule 87 (classDef -> epsilon .)


state 10

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef . main end
    (4) main -> . MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET

    MAIN            shift and go to state 20

    main                           shift and go to state 19

state 11

    (5) fxDef -> VOID . FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID . FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef

    FX              shift and go to state 21


state 12

    (9) fxDef -> epsilon .

    MAIN            reduce using rule 9 (fxDef -> epsilon .)
    CBRACKET        reduce using rule 9 (fxDef -> epsilon .)


state 13

    (7) fxDef -> fxType . FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType . FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    FX              shift and go to state 22


state 14

    (10) fxType -> INT .

    FX              reduce using rule 10 (fxType -> INT .)


state 15

    (11) fxType -> STRING .

    FX              reduce using rule 11 (fxType -> STRING .)


state 16

    (12) fxType -> DEC .

    FX              reduce using rule 12 (fxType -> DEC .)


state 17

    (13) fxType -> BOOL .

    FX              reduce using rule 13 (fxType -> BOOL .)


state 18

    (86) classDef -> CLASS pointClass . ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    ID              shift and go to state 23


state 19

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main . end
    (115) end -> . END OPAREN ID CPAREN

    END             shift and go to state 25

    end                            shift and go to state 24

state 20

    (4) main -> MAIN . pointMain OPAREN CPAREN OBRACKET body CBRACKET
    (3) pointMain -> .

    OPAREN          reduce using rule 3 (pointMain -> .)

    pointMain                      shift and go to state 26

state 21

    (5) fxDef -> VOID FX . pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX . pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (14) pointFx -> .

    ID              reduce using rule 14 (pointFx -> .)

    pointFx                        shift and go to state 27

state 22

    (7) fxDef -> fxType FX . pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX . pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (14) pointFx -> .

    ID              reduce using rule 14 (pointFx -> .)

    pointFx                        shift and go to state 28

state 23

    (86) classDef -> CLASS pointClass ID . pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (92) pointClassName -> .

    OBRACKET        reduce using rule 92 (pointClassName -> .)

    pointClassName                 shift and go to state 29

state 24

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end .

    $end            reduce using rule 1 (begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end .)


state 25

    (115) end -> END . OPAREN ID CPAREN

    OPAREN          shift and go to state 30


state 26

    (4) main -> MAIN pointMain . OPAREN CPAREN OBRACKET body CBRACKET

    OPAREN          shift and go to state 31


state 27

    (5) fxDef -> VOID FX pointFx . ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx . ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef

    ID              shift and go to state 32


state 28

    (7) fxDef -> fxType FX pointFx . ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx . ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    ID              shift and go to state 33


state 29

    (86) classDef -> CLASS pointClass ID pointClassName . OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    OBRACKET        shift and go to state 34


state 30

    (115) end -> END OPAREN . ID CPAREN

    ID              shift and go to state 35


state 31

    (4) main -> MAIN pointMain OPAREN . CPAREN OBRACKET body CBRACKET

    CPAREN          shift and go to state 36


state 32

    (5) fxDef -> VOID FX pointFx ID . pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx ID . pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (15) pointFxId -> .

    OPAREN          reduce using rule 15 (pointFxId -> .)

    pointFxId                      shift and go to state 37

state 33

    (7) fxDef -> fxType FX pointFx ID . pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx ID . pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (15) pointFxId -> .

    OPAREN          reduce using rule 15 (pointFxId -> .)

    pointFxId                      shift and go to state 38

state 34

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET . ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    ATTRIBUTES      shift and go to state 39


state 35

    (115) end -> END OPAREN ID . CPAREN

    CPAREN          shift and go to state 40


state 36

    (4) main -> MAIN pointMain OPAREN CPAREN . OBRACKET body CBRACKET

    OBRACKET        shift and go to state 41


state 37

    (5) fxDef -> VOID FX pointFx ID pointFxId . OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx ID pointFxId . OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef

    OPAREN          shift and go to state 42


state 38

    (7) fxDef -> fxType FX pointFx ID pointFxId . OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx ID pointFxId . OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    OPAREN          shift and go to state 43


state 39

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES . COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    COLON           shift and go to state 44


state 40

    (115) end -> END OPAREN ID CPAREN .

    $end            reduce using rule 115 (end -> END OPAREN ID CPAREN .)


state 41

    (4) main -> MAIN pointMain OPAREN CPAREN OBRACKET . body CBRACKET
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (116) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (113) input -> . INPUT OPAREN ID CPAREN EOF
    (114) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (104) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (108) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 116 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 45
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 42

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN . param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN . epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (18) param -> . paramType ID pointParam
    (19) param -> . paramType ID pointParam COMMA param
    (116) epsilon -> .
    (20) paramType -> . INT
    (21) paramType -> . STRING
    (22) paramType -> . DEC
    (23) paramType -> . BOOL

    CPAREN          reduce using rule 116 (epsilon -> .)
    INT             shift and go to state 65
    STRING          shift and go to state 66
    DEC             shift and go to state 67
    BOOL            shift and go to state 68

    param                          shift and go to state 62
    epsilon                        shift and go to state 63
    paramType                      shift and go to state 64

state 43

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN . param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN . epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (18) param -> . paramType ID pointParam
    (19) param -> . paramType ID pointParam COMMA param
    (116) epsilon -> .
    (20) paramType -> . INT
    (21) paramType -> . STRING
    (22) paramType -> . DEC
    (23) paramType -> . BOOL

    CPAREN          reduce using rule 116 (epsilon -> .)
    INT             shift and go to state 65
    STRING          shift and go to state 66
    DEC             shift and go to state 67
    BOOL            shift and go to state 68

    param                          shift and go to state 69
    epsilon                        shift and go to state 70
    paramType                      shift and go to state 64

state 44

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON . pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (88) pointAtt -> . varsDef
    (89) pointAtt -> . varsDef pointAtt
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF

    VAR             shift and go to state 49

    pointAtt                       shift and go to state 71
    varsDef                        shift and go to state 72

state 45

    (4) main -> MAIN pointMain OPAREN CPAREN OBRACKET body . CBRACKET

    CBRACKET        shift and go to state 73


state 46

    (33) body -> varsDef . body
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (116) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (113) input -> . INPUT OPAREN ID CPAREN EOF
    (114) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (104) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (108) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 116 (epsilon -> .)
    RETURN          reduce using rule 116 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    varsDef                        shift and go to state 46
    body                           shift and go to state 74
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 47

    (34) body -> statements . body
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (116) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (113) input -> . INPUT OPAREN ID CPAREN EOF
    (114) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (104) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (108) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 116 (epsilon -> .)
    RETURN          reduce using rule 116 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    statements                     shift and go to state 47
    body                           shift and go to state 75
    varsDef                        shift and go to state 46
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 48

    (35) body -> epsilon .

    CBRACKET        reduce using rule 35 (body -> epsilon .)
    RETURN          reduce using rule 35 (body -> epsilon .)


state 49

    (43) varsDef -> VAR . objType var EOF
    (44) varsDef -> VAR . varSimpleType var EOF
    (96) objType -> . ID
    (45) varSimpleType -> . INT
    (46) varSimpleType -> . STRING
    (47) varSimpleType -> . DEC
    (48) varSimpleType -> . BOOL

    ID              shift and go to state 78
    INT             shift and go to state 79
    STRING          shift and go to state 80
    DEC             shift and go to state 81
    BOOL            shift and go to state 82

    objType                        shift and go to state 76
    varSimpleType                  shift and go to state 77

state 50

    (36) statements -> assignmentDef .

    VAR             reduce using rule 36 (statements -> assignmentDef .)
    ID              reduce using rule 36 (statements -> assignmentDef .)
    INPUT           reduce using rule 36 (statements -> assignmentDef .)
    OUTPUT          reduce using rule 36 (statements -> assignmentDef .)
    WHILE           reduce using rule 36 (statements -> assignmentDef .)
    IF              reduce using rule 36 (statements -> assignmentDef .)
    CBRACKET        reduce using rule 36 (statements -> assignmentDef .)
    RETURN          reduce using rule 36 (statements -> assignmentDef .)


state 51

    (37) statements -> input .

    VAR             reduce using rule 37 (statements -> input .)
    ID              reduce using rule 37 (statements -> input .)
    INPUT           reduce using rule 37 (statements -> input .)
    OUTPUT          reduce using rule 37 (statements -> input .)
    WHILE           reduce using rule 37 (statements -> input .)
    IF              reduce using rule 37 (statements -> input .)
    CBRACKET        reduce using rule 37 (statements -> input .)
    RETURN          reduce using rule 37 (statements -> input .)


state 52

    (38) statements -> output .

    VAR             reduce using rule 38 (statements -> output .)
    ID              reduce using rule 38 (statements -> output .)
    INPUT           reduce using rule 38 (statements -> output .)
    OUTPUT          reduce using rule 38 (statements -> output .)
    WHILE           reduce using rule 38 (statements -> output .)
    IF              reduce using rule 38 (statements -> output .)
    CBRACKET        reduce using rule 38 (statements -> output .)
    RETURN          reduce using rule 38 (statements -> output .)


state 53

    (39) statements -> voidCall .

    VAR             reduce using rule 39 (statements -> voidCall .)
    ID              reduce using rule 39 (statements -> voidCall .)
    INPUT           reduce using rule 39 (statements -> voidCall .)
    OUTPUT          reduce using rule 39 (statements -> voidCall .)
    WHILE           reduce using rule 39 (statements -> voidCall .)
    IF              reduce using rule 39 (statements -> voidCall .)
    CBRACKET        reduce using rule 39 (statements -> voidCall .)
    RETURN          reduce using rule 39 (statements -> voidCall .)


state 54

    (40) statements -> whileCycle .

    VAR             reduce using rule 40 (statements -> whileCycle .)
    ID              reduce using rule 40 (statements -> whileCycle .)
    INPUT           reduce using rule 40 (statements -> whileCycle .)
    OUTPUT          reduce using rule 40 (statements -> whileCycle .)
    WHILE           reduce using rule 40 (statements -> whileCycle .)
    IF              reduce using rule 40 (statements -> whileCycle .)
    CBRACKET        reduce using rule 40 (statements -> whileCycle .)
    RETURN          reduce using rule 40 (statements -> whileCycle .)


state 55

    (41) statements -> ifCond .

    VAR             reduce using rule 41 (statements -> ifCond .)
    ID              reduce using rule 41 (statements -> ifCond .)
    INPUT           reduce using rule 41 (statements -> ifCond .)
    OUTPUT          reduce using rule 41 (statements -> ifCond .)
    WHILE           reduce using rule 41 (statements -> ifCond .)
    IF              reduce using rule 41 (statements -> ifCond .)
    CBRACKET        reduce using rule 41 (statements -> ifCond .)
    RETURN          reduce using rule 41 (statements -> ifCond .)


state 56

    (42) statements -> classCall .

    VAR             reduce using rule 42 (statements -> classCall .)
    ID              reduce using rule 42 (statements -> classCall .)
    INPUT           reduce using rule 42 (statements -> classCall .)
    OUTPUT          reduce using rule 42 (statements -> classCall .)
    WHILE           reduce using rule 42 (statements -> classCall .)
    IF              reduce using rule 42 (statements -> classCall .)
    CBRACKET        reduce using rule 42 (statements -> classCall .)
    RETURN          reduce using rule 42 (statements -> classCall .)


state 57

    (56) assignmentDef -> ID . ASSIGNMENT pointPushAssignment expAssignment
    (29) voidCall -> ID . pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> ID . pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (94) classCall -> ID . MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> ID . MONEY ID OPAREN epsilon CPAREN EOF
    (31) pointEra -> .

    ASSIGNMENT      shift and go to state 83
    MONEY           shift and go to state 85
    OPAREN          reduce using rule 31 (pointEra -> .)

    pointEra                       shift and go to state 84

state 58

    (113) input -> INPUT . OPAREN ID CPAREN EOF

    OPAREN          shift and go to state 86


state 59

    (114) output -> OUTPUT . OPAREN expRelational CPAREN EOF

    OPAREN          shift and go to state 87


state 60

    (104) whileCycle -> WHILE . pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (105) pointWhile1 -> .

    OPAREN          reduce using rule 105 (pointWhile1 -> .)

    pointWhile1                    shift and go to state 88

state 61

    (108) ifCond -> IF . OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> IF . OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    OPAREN          shift and go to state 89


state 62

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param . CPAREN OBRACKET body CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 90


state 63

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon . CPAREN OBRACKET body CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 91


state 64

    (18) param -> paramType . ID pointParam
    (19) param -> paramType . ID pointParam COMMA param

    ID              shift and go to state 92


state 65

    (20) paramType -> INT .

    ID              reduce using rule 20 (paramType -> INT .)


state 66

    (21) paramType -> STRING .

    ID              reduce using rule 21 (paramType -> STRING .)


state 67

    (22) paramType -> DEC .

    ID              reduce using rule 22 (paramType -> DEC .)


state 68

    (23) paramType -> BOOL .

    ID              reduce using rule 23 (paramType -> BOOL .)


state 69

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param . CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 93


state 70

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon . CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 94


state 71

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt . METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    METHODS         shift and go to state 95


state 72

    (88) pointAtt -> varsDef .
    (89) pointAtt -> varsDef . pointAtt
    (88) pointAtt -> . varsDef
    (89) pointAtt -> . varsDef pointAtt
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF

    METHODS         reduce using rule 88 (pointAtt -> varsDef .)
    VAR             shift and go to state 49

    varsDef                        shift and go to state 72
    pointAtt                       shift and go to state 96

state 73

    (4) main -> MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET .

    END             reduce using rule 4 (main -> MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET .)


state 74

    (33) body -> varsDef body .

    CBRACKET        reduce using rule 33 (body -> varsDef body .)
    RETURN          reduce using rule 33 (body -> varsDef body .)


state 75

    (34) body -> statements body .

    CBRACKET        reduce using rule 34 (body -> statements body .)
    RETURN          reduce using rule 34 (body -> statements body .)


state 76

    (43) varsDef -> VAR objType . var EOF
    (49) var -> . varsType
    (50) var -> . varsType COMMA var
    (51) varsType -> . ID
    (52) varsType -> . arrDef
    (53) varsType -> . matrixDef
    (54) arrDef -> . ID OSQUAREBR varCte CSQUAREBR
    (55) matrixDef -> . arrDef OSQUAREBR varCte CSQUAREBR

    ID              shift and go to state 99

    var                            shift and go to state 97
    varsType                       shift and go to state 98
    arrDef                         shift and go to state 100
    matrixDef                      shift and go to state 101

state 77

    (44) varsDef -> VAR varSimpleType . var EOF
    (49) var -> . varsType
    (50) var -> . varsType COMMA var
    (51) varsType -> . ID
    (52) varsType -> . arrDef
    (53) varsType -> . matrixDef
    (54) arrDef -> . ID OSQUAREBR varCte CSQUAREBR
    (55) matrixDef -> . arrDef OSQUAREBR varCte CSQUAREBR

    ID              shift and go to state 99

    var                            shift and go to state 102
    varsType                       shift and go to state 98
    arrDef                         shift and go to state 100
    matrixDef                      shift and go to state 101

state 78

    (96) objType -> ID .

    ID              reduce using rule 96 (objType -> ID .)


state 79

    (45) varSimpleType -> INT .

    ID              reduce using rule 45 (varSimpleType -> INT .)


state 80

    (46) varSimpleType -> STRING .

    ID              reduce using rule 46 (varSimpleType -> STRING .)


state 81

    (47) varSimpleType -> DEC .

    ID              reduce using rule 47 (varSimpleType -> DEC .)


state 82

    (48) varSimpleType -> BOOL .

    ID              reduce using rule 48 (varSimpleType -> BOOL .)


state 83

    (56) assignmentDef -> ID ASSIGNMENT . pointPushAssignment expAssignment
    (57) pointPushAssignment -> .

    ID              reduce using rule 57 (pointPushAssignment -> .)
    OPAREN          reduce using rule 57 (pointPushAssignment -> .)
    INT             reduce using rule 57 (pointPushAssignment -> .)
    DEC             reduce using rule 57 (pointPushAssignment -> .)
    STRING          reduce using rule 57 (pointPushAssignment -> .)

    pointPushAssignment            shift and go to state 103

state 84

    (29) voidCall -> ID pointEra . OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> ID pointEra . OPAREN epsilon pointGoSub CPAREN EOF

    OPAREN          shift and go to state 104


state 85

    (94) classCall -> ID MONEY . ID OPAREN paramCall CPAREN EOF
    (95) classCall -> ID MONEY . ID OPAREN epsilon CPAREN EOF

    ID              shift and go to state 105


state 86

    (113) input -> INPUT OPAREN . ID CPAREN EOF

    ID              shift and go to state 106


state 87

    (114) output -> OUTPUT OPAREN . expRelational CPAREN EOF
    (63) expRelational -> . plusMinus
    (64) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    ID              shift and go to state 116

    expRelational                  shift and go to state 108
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 88

    (104) whileCycle -> WHILE pointWhile1 . OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3

    OPAREN          shift and go to state 117


state 89

    (108) ifCond -> IF OPAREN . expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> IF OPAREN . expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (63) expRelational -> . plusMinus
    (64) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    ID              shift and go to state 116

    expRelational                  shift and go to state 118
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 90

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN . OBRACKET body CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 119


state 91

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN . OBRACKET body CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 120


state 92

    (18) param -> paramType ID . pointParam
    (19) param -> paramType ID . pointParam COMMA param
    (24) pointParam -> .

    COMMA           reduce using rule 24 (pointParam -> .)
    CPAREN          reduce using rule 24 (pointParam -> .)

    pointParam                     shift and go to state 121

state 93

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN . OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 122


state 94

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN . OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 123


state 95

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS . COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    COLON           shift and go to state 124


state 96

    (89) pointAtt -> varsDef pointAtt .

    METHODS         reduce using rule 89 (pointAtt -> varsDef pointAtt .)


state 97

    (43) varsDef -> VAR objType var . EOF

    EOF             shift and go to state 125


state 98

    (49) var -> varsType .
    (50) var -> varsType . COMMA var

    EOF             reduce using rule 49 (var -> varsType .)
    COMMA           shift and go to state 126


state 99

    (51) varsType -> ID .
    (54) arrDef -> ID . OSQUAREBR varCte CSQUAREBR

    COMMA           reduce using rule 51 (varsType -> ID .)
    EOF             reduce using rule 51 (varsType -> ID .)
    OSQUAREBR       shift and go to state 127


state 100

    (52) varsType -> arrDef .
    (55) matrixDef -> arrDef . OSQUAREBR varCte CSQUAREBR

    COMMA           reduce using rule 52 (varsType -> arrDef .)
    EOF             reduce using rule 52 (varsType -> arrDef .)
    OSQUAREBR       shift and go to state 128


state 101

    (53) varsType -> matrixDef .

    COMMA           reduce using rule 53 (varsType -> matrixDef .)
    EOF             reduce using rule 53 (varsType -> matrixDef .)


state 102

    (44) varsDef -> VAR varSimpleType var . EOF

    EOF             shift and go to state 129


state 103

    (56) assignmentDef -> ID ASSIGNMENT pointPushAssignment . expAssignment
    (58) expAssignment -> . expRelational EOF
    (59) expAssignment -> . returnCall EOF
    (60) expAssignment -> . classCall
    (63) expRelational -> . plusMinus
    (64) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (61) returnCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN
    (62) returnCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . ID

    ID              shift and go to state 130
    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115

    expAssignment                  shift and go to state 131
    expRelational                  shift and go to state 132
    returnCall                     shift and go to state 133
    classCall                      shift and go to state 134
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 104

    (29) voidCall -> ID pointEra OPAREN . paramCall pointGoSub CPAREN EOF
    (30) voidCall -> ID pointEra OPAREN . epsilon pointGoSub CPAREN EOF
    (25) paramCall -> . ID pointParamCall pointParamNum
    (26) paramCall -> . ID pointParamCall COMMA paramCall
    (116) epsilon -> .

    ID              shift and go to state 135
    CPAREN          reduce using rule 116 (epsilon -> .)

    paramCall                      shift and go to state 136
    epsilon                        shift and go to state 137

state 105

    (94) classCall -> ID MONEY ID . OPAREN paramCall CPAREN EOF
    (95) classCall -> ID MONEY ID . OPAREN epsilon CPAREN EOF

    OPAREN          shift and go to state 138


state 106

    (113) input -> INPUT OPAREN ID . CPAREN EOF

    CPAREN          shift and go to state 139


state 107

    (82) expParen -> OPAREN . pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (84) pointFakeBackground -> .

    OPAREN          reduce using rule 84 (pointFakeBackground -> .)
    INT             reduce using rule 84 (pointFakeBackground -> .)
    DEC             reduce using rule 84 (pointFakeBackground -> .)
    STRING          reduce using rule 84 (pointFakeBackground -> .)
    ID              reduce using rule 84 (pointFakeBackground -> .)

    pointFakeBackground            shift and go to state 140

state 108

    (114) output -> OUTPUT OPAREN expRelational . CPAREN EOF

    CPAREN          shift and go to state 141


state 109

    (63) expRelational -> plusMinus .
    (64) expRelational -> plusMinus . opRelational expRelational pointCheckOpRel
    (66) opRelational -> . EQUAL
    (67) opRelational -> . DIFFERENT
    (68) opRelational -> . GREATERTHAN
    (69) opRelational -> . GREATERTHANEQ
    (70) opRelational -> . LESSTHAN
    (71) opRelational -> . LESSTHANEQ

    CPAREN          reduce using rule 63 (expRelational -> plusMinus .)
    EOF             reduce using rule 63 (expRelational -> plusMinus .)
    EQUAL           shift and go to state 143
    DIFFERENT       shift and go to state 144
    GREATERTHAN     shift and go to state 145
    GREATERTHANEQ   shift and go to state 146
    LESSTHAN        shift and go to state 147
    LESSTHANEQ      shift and go to state 148

    opRelational                   shift and go to state 142

state 110

    (72) plusMinus -> multDiv . pointCheckPlusMinus
    (73) plusMinus -> multDiv . pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> multDiv . pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (75) pointCheckPlusMinus -> .

    PLUS            reduce using rule 75 (pointCheckPlusMinus -> .)
    MINUS           reduce using rule 75 (pointCheckPlusMinus -> .)
    EQUAL           reduce using rule 75 (pointCheckPlusMinus -> .)
    DIFFERENT       reduce using rule 75 (pointCheckPlusMinus -> .)
    GREATERTHAN     reduce using rule 75 (pointCheckPlusMinus -> .)
    GREATERTHANEQ   reduce using rule 75 (pointCheckPlusMinus -> .)
    LESSTHAN        reduce using rule 75 (pointCheckPlusMinus -> .)
    LESSTHANEQ      reduce using rule 75 (pointCheckPlusMinus -> .)
    CPAREN          reduce using rule 75 (pointCheckPlusMinus -> .)
    EOF             reduce using rule 75 (pointCheckPlusMinus -> .)

    pointCheckPlusMinus            shift and go to state 149

state 111

    (77) multDiv -> expParen . pointCheckMultDiv
    (78) multDiv -> expParen . pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> expParen . pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (80) pointCheckMultDiv -> .

    MULTIPLY        reduce using rule 80 (pointCheckMultDiv -> .)
    DIVIDE          reduce using rule 80 (pointCheckMultDiv -> .)
    PLUS            reduce using rule 80 (pointCheckMultDiv -> .)
    MINUS           reduce using rule 80 (pointCheckMultDiv -> .)
    EQUAL           reduce using rule 80 (pointCheckMultDiv -> .)
    DIFFERENT       reduce using rule 80 (pointCheckMultDiv -> .)
    GREATERTHAN     reduce using rule 80 (pointCheckMultDiv -> .)
    GREATERTHANEQ   reduce using rule 80 (pointCheckMultDiv -> .)
    LESSTHAN        reduce using rule 80 (pointCheckMultDiv -> .)
    LESSTHANEQ      reduce using rule 80 (pointCheckMultDiv -> .)
    CPAREN          reduce using rule 80 (pointCheckMultDiv -> .)
    EOF             reduce using rule 80 (pointCheckMultDiv -> .)

    pointCheckMultDiv              shift and go to state 150

state 112

    (83) expParen -> varCte .

    MULTIPLY        reduce using rule 83 (expParen -> varCte .)
    DIVIDE          reduce using rule 83 (expParen -> varCte .)
    PLUS            reduce using rule 83 (expParen -> varCte .)
    MINUS           reduce using rule 83 (expParen -> varCte .)
    EQUAL           reduce using rule 83 (expParen -> varCte .)
    DIFFERENT       reduce using rule 83 (expParen -> varCte .)
    GREATERTHAN     reduce using rule 83 (expParen -> varCte .)
    GREATERTHANEQ   reduce using rule 83 (expParen -> varCte .)
    LESSTHAN        reduce using rule 83 (expParen -> varCte .)
    LESSTHANEQ      reduce using rule 83 (expParen -> varCte .)
    CPAREN          reduce using rule 83 (expParen -> varCte .)
    EOF             reduce using rule 83 (expParen -> varCte .)


state 113

    (97) varCte -> INT . pointINT
    (101) pointINT -> .

    MULTIPLY        reduce using rule 101 (pointINT -> .)
    DIVIDE          reduce using rule 101 (pointINT -> .)
    PLUS            reduce using rule 101 (pointINT -> .)
    MINUS           reduce using rule 101 (pointINT -> .)
    EQUAL           reduce using rule 101 (pointINT -> .)
    DIFFERENT       reduce using rule 101 (pointINT -> .)
    GREATERTHAN     reduce using rule 101 (pointINT -> .)
    GREATERTHANEQ   reduce using rule 101 (pointINT -> .)
    LESSTHAN        reduce using rule 101 (pointINT -> .)
    LESSTHANEQ      reduce using rule 101 (pointINT -> .)
    CPAREN          reduce using rule 101 (pointINT -> .)
    EOF             reduce using rule 101 (pointINT -> .)
    CSQUAREBR       reduce using rule 101 (pointINT -> .)

    pointINT                       shift and go to state 151

state 114

    (98) varCte -> DEC . pointDEC
    (102) pointDEC -> .

    MULTIPLY        reduce using rule 102 (pointDEC -> .)
    DIVIDE          reduce using rule 102 (pointDEC -> .)
    PLUS            reduce using rule 102 (pointDEC -> .)
    MINUS           reduce using rule 102 (pointDEC -> .)
    EQUAL           reduce using rule 102 (pointDEC -> .)
    DIFFERENT       reduce using rule 102 (pointDEC -> .)
    GREATERTHAN     reduce using rule 102 (pointDEC -> .)
    GREATERTHANEQ   reduce using rule 102 (pointDEC -> .)
    LESSTHAN        reduce using rule 102 (pointDEC -> .)
    LESSTHANEQ      reduce using rule 102 (pointDEC -> .)
    CPAREN          reduce using rule 102 (pointDEC -> .)
    EOF             reduce using rule 102 (pointDEC -> .)
    CSQUAREBR       reduce using rule 102 (pointDEC -> .)

    pointDEC                       shift and go to state 152

state 115

    (99) varCte -> STRING . pointSTRING
    (103) pointSTRING -> .

    MULTIPLY        reduce using rule 103 (pointSTRING -> .)
    DIVIDE          reduce using rule 103 (pointSTRING -> .)
    PLUS            reduce using rule 103 (pointSTRING -> .)
    MINUS           reduce using rule 103 (pointSTRING -> .)
    EQUAL           reduce using rule 103 (pointSTRING -> .)
    DIFFERENT       reduce using rule 103 (pointSTRING -> .)
    GREATERTHAN     reduce using rule 103 (pointSTRING -> .)
    GREATERTHANEQ   reduce using rule 103 (pointSTRING -> .)
    LESSTHAN        reduce using rule 103 (pointSTRING -> .)
    LESSTHANEQ      reduce using rule 103 (pointSTRING -> .)
    CPAREN          reduce using rule 103 (pointSTRING -> .)
    EOF             reduce using rule 103 (pointSTRING -> .)
    CSQUAREBR       reduce using rule 103 (pointSTRING -> .)

    pointSTRING                    shift and go to state 153

state 116

    (100) varCte -> ID .

    MULTIPLY        reduce using rule 100 (varCte -> ID .)
    DIVIDE          reduce using rule 100 (varCte -> ID .)
    PLUS            reduce using rule 100 (varCte -> ID .)
    MINUS           reduce using rule 100 (varCte -> ID .)
    EQUAL           reduce using rule 100 (varCte -> ID .)
    DIFFERENT       reduce using rule 100 (varCte -> ID .)
    GREATERTHAN     reduce using rule 100 (varCte -> ID .)
    GREATERTHANEQ   reduce using rule 100 (varCte -> ID .)
    LESSTHAN        reduce using rule 100 (varCte -> ID .)
    LESSTHANEQ      reduce using rule 100 (varCte -> ID .)
    CPAREN          reduce using rule 100 (varCte -> ID .)
    CSQUAREBR       reduce using rule 100 (varCte -> ID .)
    EOF             reduce using rule 100 (varCte -> ID .)


state 117

    (104) whileCycle -> WHILE pointWhile1 OPAREN . expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (63) expRelational -> . plusMinus
    (64) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    ID              shift and go to state 116

    expRelational                  shift and go to state 154
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 118

    (108) ifCond -> IF OPAREN expRelational . CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> IF OPAREN expRelational . CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    CPAREN          shift and go to state 155


state 119

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET . body CBRACKET pointEndFunc fxDef
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (116) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (113) input -> . INPUT OPAREN ID CPAREN EOF
    (114) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (104) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (108) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 116 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 156
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 120

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET . body CBRACKET pointEndFunc fxDef
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (116) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (113) input -> . INPUT OPAREN ID CPAREN EOF
    (114) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (104) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (108) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 116 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    epsilon                        shift and go to state 48
    body                           shift and go to state 157
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 121

    (18) param -> paramType ID pointParam .
    (19) param -> paramType ID pointParam . COMMA param

    CPAREN          reduce using rule 18 (param -> paramType ID pointParam .)
    COMMA           shift and go to state 158


state 122

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET . body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (116) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (113) input -> . INPUT OPAREN ID CPAREN EOF
    (114) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (104) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (108) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    RETURN          reduce using rule 116 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 159
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 123

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET . body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (116) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (113) input -> . INPUT OPAREN ID CPAREN EOF
    (114) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (104) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (108) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    RETURN          reduce using rule 116 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    epsilon                        shift and go to state 48
    body                           shift and go to state 160
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 124

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON . pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (90) pointScopeClass -> .

    VOID            reduce using rule 90 (pointScopeClass -> .)
    INT             reduce using rule 90 (pointScopeClass -> .)
    STRING          reduce using rule 90 (pointScopeClass -> .)
    DEC             reduce using rule 90 (pointScopeClass -> .)
    BOOL            reduce using rule 90 (pointScopeClass -> .)
    CBRACKET        reduce using rule 90 (pointScopeClass -> .)

    pointScopeClass                shift and go to state 161

state 125

    (43) varsDef -> VAR objType var EOF .

    VAR             reduce using rule 43 (varsDef -> VAR objType var EOF .)
    ID              reduce using rule 43 (varsDef -> VAR objType var EOF .)
    INPUT           reduce using rule 43 (varsDef -> VAR objType var EOF .)
    OUTPUT          reduce using rule 43 (varsDef -> VAR objType var EOF .)
    WHILE           reduce using rule 43 (varsDef -> VAR objType var EOF .)
    IF              reduce using rule 43 (varsDef -> VAR objType var EOF .)
    CBRACKET        reduce using rule 43 (varsDef -> VAR objType var EOF .)
    METHODS         reduce using rule 43 (varsDef -> VAR objType var EOF .)
    RETURN          reduce using rule 43 (varsDef -> VAR objType var EOF .)


state 126

    (50) var -> varsType COMMA . var
    (49) var -> . varsType
    (50) var -> . varsType COMMA var
    (51) varsType -> . ID
    (52) varsType -> . arrDef
    (53) varsType -> . matrixDef
    (54) arrDef -> . ID OSQUAREBR varCte CSQUAREBR
    (55) matrixDef -> . arrDef OSQUAREBR varCte CSQUAREBR

    ID              shift and go to state 99

    varsType                       shift and go to state 98
    var                            shift and go to state 162
    arrDef                         shift and go to state 100
    matrixDef                      shift and go to state 101

state 127

    (54) arrDef -> ID OSQUAREBR . varCte CSQUAREBR
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . ID

    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    ID              shift and go to state 116

    varCte                         shift and go to state 163

state 128

    (55) matrixDef -> arrDef OSQUAREBR . varCte CSQUAREBR
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . ID

    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    ID              shift and go to state 116

    varCte                         shift and go to state 164

state 129

    (44) varsDef -> VAR varSimpleType var EOF .

    VAR             reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    ID              reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    INPUT           reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    OUTPUT          reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    WHILE           reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    IF              reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    CBRACKET        reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    METHODS         reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    RETURN          reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)


state 130

    (61) returnCall -> ID . pointEra OPAREN paramCall pointGoSub CPAREN
    (62) returnCall -> ID . pointEra OPAREN epsilon pointGoSub CPAREN
    (94) classCall -> ID . MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> ID . MONEY ID OPAREN epsilon CPAREN EOF
    (100) varCte -> ID .
    (31) pointEra -> .

    MONEY           shift and go to state 85
    MULTIPLY        reduce using rule 100 (varCte -> ID .)
    DIVIDE          reduce using rule 100 (varCte -> ID .)
    PLUS            reduce using rule 100 (varCte -> ID .)
    MINUS           reduce using rule 100 (varCte -> ID .)
    EQUAL           reduce using rule 100 (varCte -> ID .)
    DIFFERENT       reduce using rule 100 (varCte -> ID .)
    GREATERTHAN     reduce using rule 100 (varCte -> ID .)
    GREATERTHANEQ   reduce using rule 100 (varCte -> ID .)
    LESSTHAN        reduce using rule 100 (varCte -> ID .)
    LESSTHANEQ      reduce using rule 100 (varCte -> ID .)
    EOF             reduce using rule 100 (varCte -> ID .)
    OPAREN          reduce using rule 31 (pointEra -> .)

    pointEra                       shift and go to state 165

state 131

    (56) assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .

    VAR             reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    ID              reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    INPUT           reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    OUTPUT          reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    WHILE           reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    IF              reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    CBRACKET        reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    RETURN          reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)


state 132

    (58) expAssignment -> expRelational . EOF

    EOF             shift and go to state 166


state 133

    (59) expAssignment -> returnCall . EOF

    EOF             shift and go to state 167


state 134

    (60) expAssignment -> classCall .

    VAR             reduce using rule 60 (expAssignment -> classCall .)
    ID              reduce using rule 60 (expAssignment -> classCall .)
    INPUT           reduce using rule 60 (expAssignment -> classCall .)
    OUTPUT          reduce using rule 60 (expAssignment -> classCall .)
    WHILE           reduce using rule 60 (expAssignment -> classCall .)
    IF              reduce using rule 60 (expAssignment -> classCall .)
    CBRACKET        reduce using rule 60 (expAssignment -> classCall .)
    RETURN          reduce using rule 60 (expAssignment -> classCall .)


state 135

    (25) paramCall -> ID . pointParamCall pointParamNum
    (26) paramCall -> ID . pointParamCall COMMA paramCall
    (28) pointParamCall -> .

    COMMA           reduce using rule 28 (pointParamCall -> .)
    CPAREN          reduce using rule 28 (pointParamCall -> .)

    pointParamCall                 shift and go to state 168

state 136

    (29) voidCall -> ID pointEra OPAREN paramCall . pointGoSub CPAREN EOF
    (32) pointGoSub -> .

    CPAREN          reduce using rule 32 (pointGoSub -> .)

    pointGoSub                     shift and go to state 169

state 137

    (30) voidCall -> ID pointEra OPAREN epsilon . pointGoSub CPAREN EOF
    (32) pointGoSub -> .

    CPAREN          reduce using rule 32 (pointGoSub -> .)

    pointGoSub                     shift and go to state 170

state 138

    (94) classCall -> ID MONEY ID OPAREN . paramCall CPAREN EOF
    (95) classCall -> ID MONEY ID OPAREN . epsilon CPAREN EOF
    (25) paramCall -> . ID pointParamCall pointParamNum
    (26) paramCall -> . ID pointParamCall COMMA paramCall
    (116) epsilon -> .

    ID              shift and go to state 135
    CPAREN          reduce using rule 116 (epsilon -> .)

    paramCall                      shift and go to state 171
    epsilon                        shift and go to state 172

state 139

    (113) input -> INPUT OPAREN ID CPAREN . EOF

    EOF             shift and go to state 173


state 140

    (82) expParen -> OPAREN pointFakeBackground . expRelational CPAREN pointRemoveFakeBackground
    (63) expRelational -> . plusMinus
    (64) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    ID              shift and go to state 116

    expRelational                  shift and go to state 174
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 141

    (114) output -> OUTPUT OPAREN expRelational CPAREN . EOF

    EOF             shift and go to state 175


state 142

    (64) expRelational -> plusMinus opRelational . expRelational pointCheckOpRel
    (63) expRelational -> . plusMinus
    (64) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    ID              shift and go to state 116

    plusMinus                      shift and go to state 109
    expRelational                  shift and go to state 176
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 143

    (66) opRelational -> EQUAL .

    OPAREN          reduce using rule 66 (opRelational -> EQUAL .)
    INT             reduce using rule 66 (opRelational -> EQUAL .)
    DEC             reduce using rule 66 (opRelational -> EQUAL .)
    STRING          reduce using rule 66 (opRelational -> EQUAL .)
    ID              reduce using rule 66 (opRelational -> EQUAL .)


state 144

    (67) opRelational -> DIFFERENT .

    OPAREN          reduce using rule 67 (opRelational -> DIFFERENT .)
    INT             reduce using rule 67 (opRelational -> DIFFERENT .)
    DEC             reduce using rule 67 (opRelational -> DIFFERENT .)
    STRING          reduce using rule 67 (opRelational -> DIFFERENT .)
    ID              reduce using rule 67 (opRelational -> DIFFERENT .)


state 145

    (68) opRelational -> GREATERTHAN .

    OPAREN          reduce using rule 68 (opRelational -> GREATERTHAN .)
    INT             reduce using rule 68 (opRelational -> GREATERTHAN .)
    DEC             reduce using rule 68 (opRelational -> GREATERTHAN .)
    STRING          reduce using rule 68 (opRelational -> GREATERTHAN .)
    ID              reduce using rule 68 (opRelational -> GREATERTHAN .)


state 146

    (69) opRelational -> GREATERTHANEQ .

    OPAREN          reduce using rule 69 (opRelational -> GREATERTHANEQ .)
    INT             reduce using rule 69 (opRelational -> GREATERTHANEQ .)
    DEC             reduce using rule 69 (opRelational -> GREATERTHANEQ .)
    STRING          reduce using rule 69 (opRelational -> GREATERTHANEQ .)
    ID              reduce using rule 69 (opRelational -> GREATERTHANEQ .)


state 147

    (70) opRelational -> LESSTHAN .

    OPAREN          reduce using rule 70 (opRelational -> LESSTHAN .)
    INT             reduce using rule 70 (opRelational -> LESSTHAN .)
    DEC             reduce using rule 70 (opRelational -> LESSTHAN .)
    STRING          reduce using rule 70 (opRelational -> LESSTHAN .)
    ID              reduce using rule 70 (opRelational -> LESSTHAN .)


state 148

    (71) opRelational -> LESSTHANEQ .

    OPAREN          reduce using rule 71 (opRelational -> LESSTHANEQ .)
    INT             reduce using rule 71 (opRelational -> LESSTHANEQ .)
    DEC             reduce using rule 71 (opRelational -> LESSTHANEQ .)
    STRING          reduce using rule 71 (opRelational -> LESSTHANEQ .)
    ID              reduce using rule 71 (opRelational -> LESSTHANEQ .)


state 149

    (72) plusMinus -> multDiv pointCheckPlusMinus .
    (73) plusMinus -> multDiv pointCheckPlusMinus . PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> multDiv pointCheckPlusMinus . MINUS pointPushPlusMinus plusMinus

    EQUAL           reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    DIFFERENT       reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    GREATERTHAN     reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    GREATERTHANEQ   reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    LESSTHAN        reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    LESSTHANEQ      reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    CPAREN          reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    EOF             reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    PLUS            shift and go to state 177
    MINUS           shift and go to state 178


state 150

    (77) multDiv -> expParen pointCheckMultDiv .
    (78) multDiv -> expParen pointCheckMultDiv . MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> expParen pointCheckMultDiv . DIVIDE pointPushMultDiv multDiv

    PLUS            reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    MINUS           reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    EQUAL           reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    DIFFERENT       reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    GREATERTHAN     reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    GREATERTHANEQ   reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    LESSTHAN        reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    LESSTHANEQ      reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    CPAREN          reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    EOF             reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    MULTIPLY        shift and go to state 179
    DIVIDE          shift and go to state 180


state 151

    (97) varCte -> INT pointINT .

    MULTIPLY        reduce using rule 97 (varCte -> INT pointINT .)
    DIVIDE          reduce using rule 97 (varCte -> INT pointINT .)
    PLUS            reduce using rule 97 (varCte -> INT pointINT .)
    MINUS           reduce using rule 97 (varCte -> INT pointINT .)
    EQUAL           reduce using rule 97 (varCte -> INT pointINT .)
    DIFFERENT       reduce using rule 97 (varCte -> INT pointINT .)
    GREATERTHAN     reduce using rule 97 (varCte -> INT pointINT .)
    GREATERTHANEQ   reduce using rule 97 (varCte -> INT pointINT .)
    LESSTHAN        reduce using rule 97 (varCte -> INT pointINT .)
    LESSTHANEQ      reduce using rule 97 (varCte -> INT pointINT .)
    CPAREN          reduce using rule 97 (varCte -> INT pointINT .)
    EOF             reduce using rule 97 (varCte -> INT pointINT .)
    CSQUAREBR       reduce using rule 97 (varCte -> INT pointINT .)


state 152

    (98) varCte -> DEC pointDEC .

    MULTIPLY        reduce using rule 98 (varCte -> DEC pointDEC .)
    DIVIDE          reduce using rule 98 (varCte -> DEC pointDEC .)
    PLUS            reduce using rule 98 (varCte -> DEC pointDEC .)
    MINUS           reduce using rule 98 (varCte -> DEC pointDEC .)
    EQUAL           reduce using rule 98 (varCte -> DEC pointDEC .)
    DIFFERENT       reduce using rule 98 (varCte -> DEC pointDEC .)
    GREATERTHAN     reduce using rule 98 (varCte -> DEC pointDEC .)
    GREATERTHANEQ   reduce using rule 98 (varCte -> DEC pointDEC .)
    LESSTHAN        reduce using rule 98 (varCte -> DEC pointDEC .)
    LESSTHANEQ      reduce using rule 98 (varCte -> DEC pointDEC .)
    CPAREN          reduce using rule 98 (varCte -> DEC pointDEC .)
    EOF             reduce using rule 98 (varCte -> DEC pointDEC .)
    CSQUAREBR       reduce using rule 98 (varCte -> DEC pointDEC .)


state 153

    (99) varCte -> STRING pointSTRING .

    MULTIPLY        reduce using rule 99 (varCte -> STRING pointSTRING .)
    DIVIDE          reduce using rule 99 (varCte -> STRING pointSTRING .)
    PLUS            reduce using rule 99 (varCte -> STRING pointSTRING .)
    MINUS           reduce using rule 99 (varCte -> STRING pointSTRING .)
    EQUAL           reduce using rule 99 (varCte -> STRING pointSTRING .)
    DIFFERENT       reduce using rule 99 (varCte -> STRING pointSTRING .)
    GREATERTHAN     reduce using rule 99 (varCte -> STRING pointSTRING .)
    GREATERTHANEQ   reduce using rule 99 (varCte -> STRING pointSTRING .)
    LESSTHAN        reduce using rule 99 (varCte -> STRING pointSTRING .)
    LESSTHANEQ      reduce using rule 99 (varCte -> STRING pointSTRING .)
    CPAREN          reduce using rule 99 (varCte -> STRING pointSTRING .)
    EOF             reduce using rule 99 (varCte -> STRING pointSTRING .)
    CSQUAREBR       reduce using rule 99 (varCte -> STRING pointSTRING .)


state 154

    (104) whileCycle -> WHILE pointWhile1 OPAREN expRelational . CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3

    CPAREN          shift and go to state 181


state 155

    (108) ifCond -> IF OPAREN expRelational CPAREN . pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> IF OPAREN expRelational CPAREN . pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (110) pointIfCond1 -> .

    OBRACKET        reduce using rule 110 (pointIfCond1 -> .)

    pointIfCond1                   shift and go to state 182

state 156

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 183


state 157

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 184


state 158

    (19) param -> paramType ID pointParam COMMA . param
    (18) param -> . paramType ID pointParam
    (19) param -> . paramType ID pointParam COMMA param
    (20) paramType -> . INT
    (21) paramType -> . STRING
    (22) paramType -> . DEC
    (23) paramType -> . BOOL

    INT             shift and go to state 65
    STRING          shift and go to state 66
    DEC             shift and go to state 67
    BOOL            shift and go to state 68

    paramType                      shift and go to state 64
    param                          shift and go to state 185

state 159

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body . RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    RETURN          shift and go to state 186


state 160

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body . RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    RETURN          shift and go to state 187


state 161

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass . fxDef pointScopeClass2 CBRACKET classDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (116) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    CBRACKET        reduce using rule 116 (epsilon -> .)

    fxDef                          shift and go to state 188
    epsilon                        shift and go to state 12
    fxType                         shift and go to state 13

state 162

    (50) var -> varsType COMMA var .

    EOF             reduce using rule 50 (var -> varsType COMMA var .)


state 163

    (54) arrDef -> ID OSQUAREBR varCte . CSQUAREBR

    CSQUAREBR       shift and go to state 189


state 164

    (55) matrixDef -> arrDef OSQUAREBR varCte . CSQUAREBR

    CSQUAREBR       shift and go to state 190


state 165

    (61) returnCall -> ID pointEra . OPAREN paramCall pointGoSub CPAREN
    (62) returnCall -> ID pointEra . OPAREN epsilon pointGoSub CPAREN

    OPAREN          shift and go to state 191


state 166

    (58) expAssignment -> expRelational EOF .

    VAR             reduce using rule 58 (expAssignment -> expRelational EOF .)
    ID              reduce using rule 58 (expAssignment -> expRelational EOF .)
    INPUT           reduce using rule 58 (expAssignment -> expRelational EOF .)
    OUTPUT          reduce using rule 58 (expAssignment -> expRelational EOF .)
    WHILE           reduce using rule 58 (expAssignment -> expRelational EOF .)
    IF              reduce using rule 58 (expAssignment -> expRelational EOF .)
    CBRACKET        reduce using rule 58 (expAssignment -> expRelational EOF .)
    RETURN          reduce using rule 58 (expAssignment -> expRelational EOF .)


state 167

    (59) expAssignment -> returnCall EOF .

    VAR             reduce using rule 59 (expAssignment -> returnCall EOF .)
    ID              reduce using rule 59 (expAssignment -> returnCall EOF .)
    INPUT           reduce using rule 59 (expAssignment -> returnCall EOF .)
    OUTPUT          reduce using rule 59 (expAssignment -> returnCall EOF .)
    WHILE           reduce using rule 59 (expAssignment -> returnCall EOF .)
    IF              reduce using rule 59 (expAssignment -> returnCall EOF .)
    CBRACKET        reduce using rule 59 (expAssignment -> returnCall EOF .)
    RETURN          reduce using rule 59 (expAssignment -> returnCall EOF .)


state 168

    (25) paramCall -> ID pointParamCall . pointParamNum
    (26) paramCall -> ID pointParamCall . COMMA paramCall
    (27) pointParamNum -> .

    COMMA           shift and go to state 193
    CPAREN          reduce using rule 27 (pointParamNum -> .)

    pointParamNum                  shift and go to state 192

state 169

    (29) voidCall -> ID pointEra OPAREN paramCall pointGoSub . CPAREN EOF

    CPAREN          shift and go to state 194


state 170

    (30) voidCall -> ID pointEra OPAREN epsilon pointGoSub . CPAREN EOF

    CPAREN          shift and go to state 195


state 171

    (94) classCall -> ID MONEY ID OPAREN paramCall . CPAREN EOF

    CPAREN          shift and go to state 196


state 172

    (95) classCall -> ID MONEY ID OPAREN epsilon . CPAREN EOF

    CPAREN          shift and go to state 197


state 173

    (113) input -> INPUT OPAREN ID CPAREN EOF .

    VAR             reduce using rule 113 (input -> INPUT OPAREN ID CPAREN EOF .)
    ID              reduce using rule 113 (input -> INPUT OPAREN ID CPAREN EOF .)
    INPUT           reduce using rule 113 (input -> INPUT OPAREN ID CPAREN EOF .)
    OUTPUT          reduce using rule 113 (input -> INPUT OPAREN ID CPAREN EOF .)
    WHILE           reduce using rule 113 (input -> INPUT OPAREN ID CPAREN EOF .)
    IF              reduce using rule 113 (input -> INPUT OPAREN ID CPAREN EOF .)
    CBRACKET        reduce using rule 113 (input -> INPUT OPAREN ID CPAREN EOF .)
    RETURN          reduce using rule 113 (input -> INPUT OPAREN ID CPAREN EOF .)


state 174

    (82) expParen -> OPAREN pointFakeBackground expRelational . CPAREN pointRemoveFakeBackground

    CPAREN          shift and go to state 198


state 175

    (114) output -> OUTPUT OPAREN expRelational CPAREN EOF .

    VAR             reduce using rule 114 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    ID              reduce using rule 114 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    INPUT           reduce using rule 114 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    OUTPUT          reduce using rule 114 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    WHILE           reduce using rule 114 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    IF              reduce using rule 114 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    CBRACKET        reduce using rule 114 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    RETURN          reduce using rule 114 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)


state 176

    (64) expRelational -> plusMinus opRelational expRelational . pointCheckOpRel
    (65) pointCheckOpRel -> .

    CPAREN          reduce using rule 65 (pointCheckOpRel -> .)
    EOF             reduce using rule 65 (pointCheckOpRel -> .)

    pointCheckOpRel                shift and go to state 199

state 177

    (73) plusMinus -> multDiv pointCheckPlusMinus PLUS . pointPushPlusMinus plusMinus
    (76) pointPushPlusMinus -> .

    OPAREN          reduce using rule 76 (pointPushPlusMinus -> .)
    INT             reduce using rule 76 (pointPushPlusMinus -> .)
    DEC             reduce using rule 76 (pointPushPlusMinus -> .)
    STRING          reduce using rule 76 (pointPushPlusMinus -> .)
    ID              reduce using rule 76 (pointPushPlusMinus -> .)

    pointPushPlusMinus             shift and go to state 200

state 178

    (74) plusMinus -> multDiv pointCheckPlusMinus MINUS . pointPushPlusMinus plusMinus
    (76) pointPushPlusMinus -> .

    OPAREN          reduce using rule 76 (pointPushPlusMinus -> .)
    INT             reduce using rule 76 (pointPushPlusMinus -> .)
    DEC             reduce using rule 76 (pointPushPlusMinus -> .)
    STRING          reduce using rule 76 (pointPushPlusMinus -> .)
    ID              reduce using rule 76 (pointPushPlusMinus -> .)

    pointPushPlusMinus             shift and go to state 201

state 179

    (78) multDiv -> expParen pointCheckMultDiv MULTIPLY . pointPushMultDiv multDiv
    (81) pointPushMultDiv -> .

    OPAREN          reduce using rule 81 (pointPushMultDiv -> .)
    INT             reduce using rule 81 (pointPushMultDiv -> .)
    DEC             reduce using rule 81 (pointPushMultDiv -> .)
    STRING          reduce using rule 81 (pointPushMultDiv -> .)
    ID              reduce using rule 81 (pointPushMultDiv -> .)

    pointPushMultDiv               shift and go to state 202

state 180

    (79) multDiv -> expParen pointCheckMultDiv DIVIDE . pointPushMultDiv multDiv
    (81) pointPushMultDiv -> .

    OPAREN          reduce using rule 81 (pointPushMultDiv -> .)
    INT             reduce using rule 81 (pointPushMultDiv -> .)
    DEC             reduce using rule 81 (pointPushMultDiv -> .)
    STRING          reduce using rule 81 (pointPushMultDiv -> .)
    ID              reduce using rule 81 (pointPushMultDiv -> .)

    pointPushMultDiv               shift and go to state 203

state 181

    (104) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN . pointWhile2 OBRACKET body CBRACKET pointWhile3
    (106) pointWhile2 -> .

    OBRACKET        reduce using rule 106 (pointWhile2 -> .)

    pointWhile2                    shift and go to state 204

state 182

    (108) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 . OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 . OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    OBRACKET        shift and go to state 205


state 183

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET . pointEndFunc fxDef
    (17) pointEndFunc -> .

    VOID            reduce using rule 17 (pointEndFunc -> .)
    INT             reduce using rule 17 (pointEndFunc -> .)
    STRING          reduce using rule 17 (pointEndFunc -> .)
    DEC             reduce using rule 17 (pointEndFunc -> .)
    BOOL            reduce using rule 17 (pointEndFunc -> .)
    MAIN            reduce using rule 17 (pointEndFunc -> .)
    CBRACKET        reduce using rule 17 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 206

state 184

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET . pointEndFunc fxDef
    (17) pointEndFunc -> .

    VOID            reduce using rule 17 (pointEndFunc -> .)
    INT             reduce using rule 17 (pointEndFunc -> .)
    STRING          reduce using rule 17 (pointEndFunc -> .)
    DEC             reduce using rule 17 (pointEndFunc -> .)
    BOOL            reduce using rule 17 (pointEndFunc -> .)
    MAIN            reduce using rule 17 (pointEndFunc -> .)
    CBRACKET        reduce using rule 17 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 207

state 185

    (19) param -> paramType ID pointParam COMMA param .

    CPAREN          reduce using rule 19 (param -> paramType ID pointParam COMMA param .)


state 186

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN . ID pointReturn EOF CBRACKET pointEndFunc fxDef

    ID              shift and go to state 208


state 187

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN . ID pointReturn EOF CBRACKET pointEndFunc fxDef

    ID              shift and go to state 209


state 188

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef . pointScopeClass2 CBRACKET classDef
    (91) pointScopeClass2 -> .

    CBRACKET        reduce using rule 91 (pointScopeClass2 -> .)

    pointScopeClass2               shift and go to state 210

state 189

    (54) arrDef -> ID OSQUAREBR varCte CSQUAREBR .

    OSQUAREBR       reduce using rule 54 (arrDef -> ID OSQUAREBR varCte CSQUAREBR .)
    COMMA           reduce using rule 54 (arrDef -> ID OSQUAREBR varCte CSQUAREBR .)
    EOF             reduce using rule 54 (arrDef -> ID OSQUAREBR varCte CSQUAREBR .)


state 190

    (55) matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR .

    COMMA           reduce using rule 55 (matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR .)
    EOF             reduce using rule 55 (matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR .)


state 191

    (61) returnCall -> ID pointEra OPAREN . paramCall pointGoSub CPAREN
    (62) returnCall -> ID pointEra OPAREN . epsilon pointGoSub CPAREN
    (25) paramCall -> . ID pointParamCall pointParamNum
    (26) paramCall -> . ID pointParamCall COMMA paramCall
    (116) epsilon -> .

    ID              shift and go to state 135
    CPAREN          reduce using rule 116 (epsilon -> .)

    paramCall                      shift and go to state 211
    epsilon                        shift and go to state 212

state 192

    (25) paramCall -> ID pointParamCall pointParamNum .

    CPAREN          reduce using rule 25 (paramCall -> ID pointParamCall pointParamNum .)


state 193

    (26) paramCall -> ID pointParamCall COMMA . paramCall
    (25) paramCall -> . ID pointParamCall pointParamNum
    (26) paramCall -> . ID pointParamCall COMMA paramCall

    ID              shift and go to state 135

    paramCall                      shift and go to state 213

state 194

    (29) voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN . EOF

    EOF             shift and go to state 214


state 195

    (30) voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN . EOF

    EOF             shift and go to state 215


state 196

    (94) classCall -> ID MONEY ID OPAREN paramCall CPAREN . EOF

    EOF             shift and go to state 216


state 197

    (95) classCall -> ID MONEY ID OPAREN epsilon CPAREN . EOF

    EOF             shift and go to state 217


state 198

    (82) expParen -> OPAREN pointFakeBackground expRelational CPAREN . pointRemoveFakeBackground
    (85) pointRemoveFakeBackground -> .

    MULTIPLY        reduce using rule 85 (pointRemoveFakeBackground -> .)
    DIVIDE          reduce using rule 85 (pointRemoveFakeBackground -> .)
    PLUS            reduce using rule 85 (pointRemoveFakeBackground -> .)
    MINUS           reduce using rule 85 (pointRemoveFakeBackground -> .)
    EQUAL           reduce using rule 85 (pointRemoveFakeBackground -> .)
    DIFFERENT       reduce using rule 85 (pointRemoveFakeBackground -> .)
    GREATERTHAN     reduce using rule 85 (pointRemoveFakeBackground -> .)
    GREATERTHANEQ   reduce using rule 85 (pointRemoveFakeBackground -> .)
    LESSTHAN        reduce using rule 85 (pointRemoveFakeBackground -> .)
    LESSTHANEQ      reduce using rule 85 (pointRemoveFakeBackground -> .)
    CPAREN          reduce using rule 85 (pointRemoveFakeBackground -> .)
    EOF             reduce using rule 85 (pointRemoveFakeBackground -> .)

    pointRemoveFakeBackground      shift and go to state 218

state 199

    (64) expRelational -> plusMinus opRelational expRelational pointCheckOpRel .

    CPAREN          reduce using rule 64 (expRelational -> plusMinus opRelational expRelational pointCheckOpRel .)
    EOF             reduce using rule 64 (expRelational -> plusMinus opRelational expRelational pointCheckOpRel .)


state 200

    (73) plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus . plusMinus
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    ID              shift and go to state 116

    multDiv                        shift and go to state 110
    plusMinus                      shift and go to state 219
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 201

    (74) plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus . plusMinus
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    ID              shift and go to state 116

    multDiv                        shift and go to state 110
    plusMinus                      shift and go to state 220
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 202

    (78) multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv . multDiv
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    ID              shift and go to state 116

    expParen                       shift and go to state 111
    multDiv                        shift and go to state 221
    varCte                         shift and go to state 112

state 203

    (79) multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv . multDiv
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    ID              shift and go to state 116

    expParen                       shift and go to state 111
    multDiv                        shift and go to state 222
    varCte                         shift and go to state 112

state 204

    (104) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 . OBRACKET body CBRACKET pointWhile3

    OBRACKET        shift and go to state 223


state 205

    (108) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET . body CBRACKET pointIfCond2
    (109) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET . body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (116) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (113) input -> . INPUT OPAREN ID CPAREN EOF
    (114) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (104) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (108) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 116 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 224
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 206

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (116) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 116 (epsilon -> .)
    CBRACKET        reduce using rule 116 (epsilon -> .)

    fxDef                          shift and go to state 225
    epsilon                        shift and go to state 12
    fxType                         shift and go to state 13

state 207

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (116) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 116 (epsilon -> .)
    CBRACKET        reduce using rule 116 (epsilon -> .)

    epsilon                        shift and go to state 12
    fxDef                          shift and go to state 226
    fxType                         shift and go to state 13

state 208

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID . pointReturn EOF CBRACKET pointEndFunc fxDef
    (16) pointReturn -> .

    EOF             reduce using rule 16 (pointReturn -> .)

    pointReturn                    shift and go to state 227

state 209

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID . pointReturn EOF CBRACKET pointEndFunc fxDef
    (16) pointReturn -> .

    EOF             reduce using rule 16 (pointReturn -> .)

    pointReturn                    shift and go to state 228

state 210

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 . CBRACKET classDef

    CBRACKET        shift and go to state 229


state 211

    (61) returnCall -> ID pointEra OPAREN paramCall . pointGoSub CPAREN
    (32) pointGoSub -> .

    CPAREN          reduce using rule 32 (pointGoSub -> .)

    pointGoSub                     shift and go to state 230

state 212

    (62) returnCall -> ID pointEra OPAREN epsilon . pointGoSub CPAREN
    (32) pointGoSub -> .

    CPAREN          reduce using rule 32 (pointGoSub -> .)

    pointGoSub                     shift and go to state 231

state 213

    (26) paramCall -> ID pointParamCall COMMA paramCall .

    CPAREN          reduce using rule 26 (paramCall -> ID pointParamCall COMMA paramCall .)


state 214

    (29) voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .

    VAR             reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    ID              reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    INPUT           reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    OUTPUT          reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    WHILE           reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    IF              reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    CBRACKET        reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    RETURN          reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)


state 215

    (30) voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .

    VAR             reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    ID              reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    INPUT           reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    OUTPUT          reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    WHILE           reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    IF              reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    CBRACKET        reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    RETURN          reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)


state 216

    (94) classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .

    VAR             reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    ID              reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    INPUT           reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    OUTPUT          reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    WHILE           reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    IF              reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    CBRACKET        reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    RETURN          reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)


state 217

    (95) classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .

    VAR             reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    ID              reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    INPUT           reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    OUTPUT          reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    WHILE           reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    IF              reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    CBRACKET        reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    RETURN          reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)


state 218

    (82) expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .

    MULTIPLY        reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    DIVIDE          reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    PLUS            reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    MINUS           reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    EQUAL           reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    DIFFERENT       reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    GREATERTHAN     reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    GREATERTHANEQ   reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    LESSTHAN        reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    LESSTHANEQ      reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    CPAREN          reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    EOF             reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)


state 219

    (73) plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .

    EQUAL           reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    DIFFERENT       reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    GREATERTHAN     reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    GREATERTHANEQ   reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    LESSTHAN        reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    LESSTHANEQ      reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    CPAREN          reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    EOF             reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)


state 220

    (74) plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .

    EQUAL           reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    DIFFERENT       reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    GREATERTHAN     reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    GREATERTHANEQ   reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    LESSTHAN        reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    LESSTHANEQ      reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    CPAREN          reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    EOF             reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)


state 221

    (78) multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .

    PLUS            reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    MINUS           reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    EQUAL           reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    DIFFERENT       reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    GREATERTHAN     reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    GREATERTHANEQ   reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    LESSTHAN        reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    LESSTHANEQ      reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    CPAREN          reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    EOF             reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)


state 222

    (79) multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .

    PLUS            reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    MINUS           reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    EQUAL           reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    DIFFERENT       reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    GREATERTHAN     reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    GREATERTHANEQ   reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    LESSTHAN        reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    LESSTHANEQ      reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    CPAREN          reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    EOF             reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)


state 223

    (104) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET . body CBRACKET pointWhile3
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (116) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (113) input -> . INPUT OPAREN ID CPAREN EOF
    (114) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (104) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (108) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 116 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 232
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 224

    (108) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body . CBRACKET pointIfCond2
    (109) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body . CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    CBRACKET        shift and go to state 233


state 225

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 5 (fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 5 (fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef .)


state 226

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 6 (fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 6 (fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef .)


state 227

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn . EOF CBRACKET pointEndFunc fxDef

    EOF             shift and go to state 234


state 228

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn . EOF CBRACKET pointEndFunc fxDef

    EOF             shift and go to state 235


state 229

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET . classDef
    (86) classDef -> . CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (87) classDef -> . epsilon
    (116) epsilon -> .

    CLASS           shift and go to state 8
    VOID            reduce using rule 116 (epsilon -> .)
    INT             reduce using rule 116 (epsilon -> .)
    STRING          reduce using rule 116 (epsilon -> .)
    DEC             reduce using rule 116 (epsilon -> .)
    BOOL            reduce using rule 116 (epsilon -> .)
    MAIN            reduce using rule 116 (epsilon -> .)

    classDef                       shift and go to state 236
    epsilon                        shift and go to state 9

state 230

    (61) returnCall -> ID pointEra OPAREN paramCall pointGoSub . CPAREN

    CPAREN          shift and go to state 237


state 231

    (62) returnCall -> ID pointEra OPAREN epsilon pointGoSub . CPAREN

    CPAREN          shift and go to state 238


state 232

    (104) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body . CBRACKET pointWhile3

    CBRACKET        shift and go to state 239


state 233

    (108) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET . pointIfCond2
    (109) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET . ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (111) pointIfCond2 -> .

    ELSE            shift and go to state 241
    VAR             reduce using rule 111 (pointIfCond2 -> .)
    ID              reduce using rule 111 (pointIfCond2 -> .)
    INPUT           reduce using rule 111 (pointIfCond2 -> .)
    OUTPUT          reduce using rule 111 (pointIfCond2 -> .)
    WHILE           reduce using rule 111 (pointIfCond2 -> .)
    IF              reduce using rule 111 (pointIfCond2 -> .)
    CBRACKET        reduce using rule 111 (pointIfCond2 -> .)
    RETURN          reduce using rule 111 (pointIfCond2 -> .)

    pointIfCond2                   shift and go to state 240

state 234

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 242


state 235

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 243


state 236

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .

    VOID            reduce using rule 86 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    INT             reduce using rule 86 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    STRING          reduce using rule 86 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    DEC             reduce using rule 86 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    BOOL            reduce using rule 86 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    MAIN            reduce using rule 86 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)


state 237

    (61) returnCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN .

    EOF             reduce using rule 61 (returnCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN .)


state 238

    (62) returnCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN .

    EOF             reduce using rule 62 (returnCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN .)


state 239

    (104) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET . pointWhile3
    (107) pointWhile3 -> .

    VAR             reduce using rule 107 (pointWhile3 -> .)
    ID              reduce using rule 107 (pointWhile3 -> .)
    INPUT           reduce using rule 107 (pointWhile3 -> .)
    OUTPUT          reduce using rule 107 (pointWhile3 -> .)
    WHILE           reduce using rule 107 (pointWhile3 -> .)
    IF              reduce using rule 107 (pointWhile3 -> .)
    CBRACKET        reduce using rule 107 (pointWhile3 -> .)
    RETURN          reduce using rule 107 (pointWhile3 -> .)

    pointWhile3                    shift and go to state 244

state 240

    (108) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .

    VAR             reduce using rule 108 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    ID              reduce using rule 108 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    INPUT           reduce using rule 108 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    OUTPUT          reduce using rule 108 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    WHILE           reduce using rule 108 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    IF              reduce using rule 108 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    CBRACKET        reduce using rule 108 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    RETURN          reduce using rule 108 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)


state 241

    (109) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE . pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (112) pointIfCond3 -> .

    OBRACKET        reduce using rule 112 (pointIfCond3 -> .)

    pointIfCond3                   shift and go to state 245

state 242

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET . pointEndFunc fxDef
    (17) pointEndFunc -> .

    VOID            reduce using rule 17 (pointEndFunc -> .)
    INT             reduce using rule 17 (pointEndFunc -> .)
    STRING          reduce using rule 17 (pointEndFunc -> .)
    DEC             reduce using rule 17 (pointEndFunc -> .)
    BOOL            reduce using rule 17 (pointEndFunc -> .)
    MAIN            reduce using rule 17 (pointEndFunc -> .)
    CBRACKET        reduce using rule 17 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 246

state 243

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET . pointEndFunc fxDef
    (17) pointEndFunc -> .

    VOID            reduce using rule 17 (pointEndFunc -> .)
    INT             reduce using rule 17 (pointEndFunc -> .)
    STRING          reduce using rule 17 (pointEndFunc -> .)
    DEC             reduce using rule 17 (pointEndFunc -> .)
    BOOL            reduce using rule 17 (pointEndFunc -> .)
    MAIN            reduce using rule 17 (pointEndFunc -> .)
    CBRACKET        reduce using rule 17 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 247

state 244

    (104) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .

    VAR             reduce using rule 104 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    ID              reduce using rule 104 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    INPUT           reduce using rule 104 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    OUTPUT          reduce using rule 104 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    WHILE           reduce using rule 104 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    IF              reduce using rule 104 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    CBRACKET        reduce using rule 104 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    RETURN          reduce using rule 104 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)


state 245

    (109) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 . OBRACKET body CBRACKET pointIfCond2

    OBRACKET        shift and go to state 248


state 246

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (116) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 116 (epsilon -> .)
    CBRACKET        reduce using rule 116 (epsilon -> .)

    fxType                         shift and go to state 13
    fxDef                          shift and go to state 249
    epsilon                        shift and go to state 12

state 247

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (116) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 116 (epsilon -> .)
    CBRACKET        reduce using rule 116 (epsilon -> .)

    fxType                         shift and go to state 13
    epsilon                        shift and go to state 12
    fxDef                          shift and go to state 250

state 248

    (109) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET . body CBRACKET pointIfCond2
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (116) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (113) input -> . INPUT OPAREN ID CPAREN EOF
    (114) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (104) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (108) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (109) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 116 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 251
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 249

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 7 (fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 7 (fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)


state 250

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 8 (fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 8 (fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)


state 251

    (109) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body . CBRACKET pointIfCond2

    CBRACKET        shift and go to state 252


state 252

    (109) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET . pointIfCond2
    (111) pointIfCond2 -> .

    VAR             reduce using rule 111 (pointIfCond2 -> .)
    ID              reduce using rule 111 (pointIfCond2 -> .)
    INPUT           reduce using rule 111 (pointIfCond2 -> .)
    OUTPUT          reduce using rule 111 (pointIfCond2 -> .)
    WHILE           reduce using rule 111 (pointIfCond2 -> .)
    IF              reduce using rule 111 (pointIfCond2 -> .)
    CBRACKET        reduce using rule 111 (pointIfCond2 -> .)
    RETURN          reduce using rule 111 (pointIfCond2 -> .)

    pointIfCond2                   shift and go to state 253

state 253

    (109) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .

    VAR             reduce using rule 109 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    ID              reduce using rule 109 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    INPUT           reduce using rule 109 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    OUTPUT          reduce using rule 109 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    WHILE           reduce using rule 109 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    IF              reduce using rule 109 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    CBRACKET        reduce using rule 109 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    RETURN          reduce using rule 109 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)

