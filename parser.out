Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> begin
Rule 1     begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end
Rule 2     pointCreateMainCuac -> <empty>
Rule 3     pointMain -> <empty>
Rule 4     main -> MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET
Rule 5     fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
Rule 6     fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
Rule 7     fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
Rule 8     fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
Rule 9     fxDef -> epsilon
Rule 10    fxType -> INT
Rule 11    fxType -> STRING
Rule 12    fxType -> DEC
Rule 13    fxType -> BOOL
Rule 14    pointFx -> <empty>
Rule 15    pointFxId -> <empty>
Rule 16    pointReturn -> <empty>
Rule 17    pointEndFunc -> <empty>
Rule 18    param -> paramType ID pointParam
Rule 19    param -> paramType ID pointParam COMMA param
Rule 20    paramType -> INT
Rule 21    paramType -> STRING
Rule 22    paramType -> DEC
Rule 23    paramType -> BOOL
Rule 24    pointParam -> <empty>
Rule 25    paramCall -> ID pointParamCall pointParamNum
Rule 26    paramCall -> ID pointParamCall COMMA paramCall
Rule 27    pointParamNum -> <empty>
Rule 28    pointParamCall -> <empty>
Rule 29    voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
Rule 30    voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
Rule 31    pointEra -> <empty>
Rule 32    pointGoSub -> <empty>
Rule 33    body -> varsDef body
Rule 34    body -> statements body
Rule 35    body -> epsilon
Rule 36    statements -> assignmentDef
Rule 37    statements -> input
Rule 38    statements -> output
Rule 39    statements -> voidCall
Rule 40    statements -> whileCycle
Rule 41    statements -> ifCond
Rule 42    statements -> classCall
Rule 43    varsDef -> VAR objType var EOF
Rule 44    varsDef -> VAR varSimpleType var EOF
Rule 45    varSimpleType -> INT
Rule 46    varSimpleType -> STRING
Rule 47    varSimpleType -> DEC
Rule 48    varSimpleType -> BOOL
Rule 49    var -> varsType
Rule 50    var -> varsType COMMA var
Rule 51    varsType -> ID
Rule 52    varsType -> arrDef
Rule 53    varsType -> matrixDef
Rule 54    arrDef -> ID OSQUAREBR varCte CSQUAREBR
Rule 55    matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR
Rule 56    assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment
Rule 57    pointPushAssignment -> <empty>
Rule 58    expAssignment -> expRelational EOF
Rule 59    expAssignment -> returnCall EOF
Rule 60    expAssignment -> classCall
Rule 61    returnCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN
Rule 62    returnCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN
Rule 63    expRelational -> plusMinus
Rule 64    expRelational -> plusMinus opRelational expRelational pointCheckOpRel
Rule 65    pointCheckOpRel -> <empty>
Rule 66    opRelational -> EQUAL
Rule 67    opRelational -> DIFFERENT
Rule 68    opRelational -> GREATERTHAN
Rule 69    opRelational -> GREATERTHANEQ
Rule 70    opRelational -> LESSTHAN
Rule 71    opRelational -> LESSTHANEQ
Rule 72    plusMinus -> multDiv pointCheckPlusMinus
Rule 73    plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
Rule 74    plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
Rule 75    pointCheckPlusMinus -> <empty>
Rule 76    pointPushPlusMinus -> <empty>
Rule 77    multDiv -> expParen pointCheckMultDiv
Rule 78    multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
Rule 79    multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
Rule 80    pointCheckMultDiv -> <empty>
Rule 81    pointPushMultDiv -> <empty>
Rule 82    expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
Rule 83    expParen -> varCte
Rule 84    pointFakeBackground -> <empty>
Rule 85    pointRemoveFakeBackground -> <empty>
Rule 86    classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
Rule 87    classDef -> epsilon
Rule 88    pointAtt -> varsDef
Rule 89    pointAtt -> varsDef pointAtt
Rule 90    pointScopeClass -> <empty>
Rule 91    pointScopeClass2 -> <empty>
Rule 92    pointClassName -> <empty>
Rule 93    pointClass -> <empty>
Rule 94    classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF
Rule 95    classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF
Rule 96    objType -> ID
Rule 97    varCte -> INT pointINT
Rule 98    varCte -> DEC pointDEC
Rule 99    varCte -> STRING pointSTRING
Rule 100   varCte -> TRUE pointBOOL
Rule 101   varCte -> FALSE pointBOOL
Rule 102   varCte -> ID
Rule 103   pointINT -> <empty>
Rule 104   pointDEC -> <empty>
Rule 105   pointSTRING -> <empty>
Rule 106   pointBOOL -> <empty>
Rule 107   whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
Rule 108   pointWhile1 -> <empty>
Rule 109   pointWhile2 -> <empty>
Rule 110   pointWhile3 -> <empty>
Rule 111   ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
Rule 112   ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
Rule 113   pointIfCond1 -> <empty>
Rule 114   pointIfCond2 -> <empty>
Rule 115   pointIfCond3 -> <empty>
Rule 116   input -> INPUT OPAREN ID CPAREN EOF
Rule 117   output -> OUTPUT OPAREN expRelational CPAREN EOF
Rule 118   end -> END OPAREN ID CPAREN
Rule 119   epsilon -> <empty>

Terminals, with rules where they appear

ASSIGNMENT           : 56
ATTRIBUTES           : 86
BEGIN                : 1
BOOL                 : 13 23 48
CBRACKET             : 4 5 6 7 8 86 107 111 112 112
CLASS                : 86
COLON                : 86 86
COMMA                : 19 26 50
CPAREN               : 1 4 5 6 7 8 29 30 61 62 82 94 95 107 111 112 116 117 118
CSQUAREBR            : 54 55
DEC                  : 12 22 47 98
DIFFERENT            : 67
DIVIDE               : 79
ELSE                 : 112
END                  : 118
EOF                  : 7 8 29 30 43 44 58 59 94 95 116 117
EQUAL                : 66
FALSE                : 101
FX                   : 5 6 7 8
GREATERTHAN          : 68
GREATERTHANEQ        : 69
ID                   : 1 5 6 7 7 8 8 18 19 25 26 29 30 51 54 56 61 62 86 94 94 95 95 96 102 116 118
IF                   : 111 112
INPUT                : 116
INT                  : 10 20 45 97
LESSTHAN             : 70
LESSTHANEQ           : 71
MAIN                 : 4
METHODS              : 86
MINUS                : 74
MONEY                : 94 95
MULTIPLY             : 78
OBRACKET             : 4 5 6 7 8 86 107 111 112 112
OPAREN               : 1 4 5 6 7 8 29 30 61 62 82 94 95 107 111 112 116 117 118
OSQUAREBR            : 54 55
OUTPUT               : 117
PLUS                 : 73
RETURN               : 7 8
STRING               : 11 21 46 99
TRUE                 : 100
VAR                  : 43 44
VOID                 : 5 6
WHILE                : 107
error                : 

Nonterminals, with rules where they appear

arrDef               : 52 55
assignmentDef        : 36
begin                : 0
body                 : 4 5 6 7 8 33 34 107 111 112 112
classCall            : 42 60
classDef             : 1 86
end                  : 1
epsilon              : 6 8 9 30 35 62 87 95
expAssignment        : 56
expParen             : 77 78 79
expRelational        : 58 64 82 107 111 112 117
fxDef                : 1 5 6 7 8 86
fxType               : 7 8
ifCond               : 41
input                : 37
main                 : 1
matrixDef            : 53
multDiv              : 72 73 74 78 79
objType              : 43
opRelational         : 64
output               : 38
param                : 5 7 19
paramCall            : 26 29 61 94
paramType            : 18 19
plusMinus            : 63 64 73 74
pointAtt             : 86 89
pointBOOL            : 100 101
pointCheckMultDiv    : 77 78 79
pointCheckOpRel      : 64
pointCheckPlusMinus  : 72 73 74
pointClass           : 86
pointClassName       : 86
pointCreateMainCuac  : 1
pointDEC             : 98
pointEndFunc         : 5 6 7 8
pointEra             : 29 30 61 62
pointFakeBackground  : 82
pointFx              : 5 6 7 8
pointFxId            : 5 6 7 8
pointGoSub           : 29 30 61 62
pointINT             : 97
pointIfCond1         : 111 112
pointIfCond2         : 111 112
pointIfCond3         : 112
pointMain            : 4
pointParam           : 18 19
pointParamCall       : 25 26
pointParamNum        : 25
pointPushAssignment  : 56
pointPushMultDiv     : 78 79
pointPushPlusMinus   : 73 74
pointRemoveFakeBackground : 82
pointReturn          : 7 8
pointSTRING          : 99
pointScopeClass      : 86
pointScopeClass2     : 86
pointWhile1          : 107
pointWhile2          : 107
pointWhile3          : 107
returnCall           : 59
statements           : 34
var                  : 43 44 50
varCte               : 54 55 83
varSimpleType        : 44
varsDef              : 33 88 89
varsType             : 49 50
voidCall             : 39
whileCycle           : 40

Parsing method: LALR

state 0

    (0) S' -> . begin
    (1) begin -> . BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end

    BEGIN           shift and go to state 2

    begin                          shift and go to state 1

state 1

    (0) S' -> begin .



state 2

    (1) begin -> BEGIN . pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end
    (2) pointCreateMainCuac -> .

    OPAREN          reduce using rule 2 (pointCreateMainCuac -> .)

    pointCreateMainCuac            shift and go to state 3

state 3

    (1) begin -> BEGIN pointCreateMainCuac . OPAREN ID CPAREN classDef fxDef main end

    OPAREN          shift and go to state 4


state 4

    (1) begin -> BEGIN pointCreateMainCuac OPAREN . ID CPAREN classDef fxDef main end

    ID              shift and go to state 5


state 5

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID . CPAREN classDef fxDef main end

    CPAREN          shift and go to state 6


state 6

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN . classDef fxDef main end
    (86) classDef -> . CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (87) classDef -> . epsilon
    (119) epsilon -> .

    CLASS           shift and go to state 8
    VOID            reduce using rule 119 (epsilon -> .)
    INT             reduce using rule 119 (epsilon -> .)
    STRING          reduce using rule 119 (epsilon -> .)
    DEC             reduce using rule 119 (epsilon -> .)
    BOOL            reduce using rule 119 (epsilon -> .)
    MAIN            reduce using rule 119 (epsilon -> .)

    classDef                       shift and go to state 7
    epsilon                        shift and go to state 9

state 7

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef . fxDef main end
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (119) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 119 (epsilon -> .)

    fxDef                          shift and go to state 10
    epsilon                        shift and go to state 12
    fxType                         shift and go to state 13

state 8

    (86) classDef -> CLASS . pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (93) pointClass -> .

    ID              reduce using rule 93 (pointClass -> .)

    pointClass                     shift and go to state 18

state 9

    (87) classDef -> epsilon .

    VOID            reduce using rule 87 (classDef -> epsilon .)
    INT             reduce using rule 87 (classDef -> epsilon .)
    STRING          reduce using rule 87 (classDef -> epsilon .)
    DEC             reduce using rule 87 (classDef -> epsilon .)
    BOOL            reduce using rule 87 (classDef -> epsilon .)
    MAIN            reduce using rule 87 (classDef -> epsilon .)


state 10

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef . main end
    (4) main -> . MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET

    MAIN            shift and go to state 20

    main                           shift and go to state 19

state 11

    (5) fxDef -> VOID . FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID . FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef

    FX              shift and go to state 21


state 12

    (9) fxDef -> epsilon .

    MAIN            reduce using rule 9 (fxDef -> epsilon .)
    CBRACKET        reduce using rule 9 (fxDef -> epsilon .)


state 13

    (7) fxDef -> fxType . FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType . FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    FX              shift and go to state 22


state 14

    (10) fxType -> INT .

    FX              reduce using rule 10 (fxType -> INT .)


state 15

    (11) fxType -> STRING .

    FX              reduce using rule 11 (fxType -> STRING .)


state 16

    (12) fxType -> DEC .

    FX              reduce using rule 12 (fxType -> DEC .)


state 17

    (13) fxType -> BOOL .

    FX              reduce using rule 13 (fxType -> BOOL .)


state 18

    (86) classDef -> CLASS pointClass . ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    ID              shift and go to state 23


state 19

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main . end
    (118) end -> . END OPAREN ID CPAREN

    END             shift and go to state 25

    end                            shift and go to state 24

state 20

    (4) main -> MAIN . pointMain OPAREN CPAREN OBRACKET body CBRACKET
    (3) pointMain -> .

    OPAREN          reduce using rule 3 (pointMain -> .)

    pointMain                      shift and go to state 26

state 21

    (5) fxDef -> VOID FX . pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX . pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (14) pointFx -> .

    ID              reduce using rule 14 (pointFx -> .)

    pointFx                        shift and go to state 27

state 22

    (7) fxDef -> fxType FX . pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX . pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (14) pointFx -> .

    ID              reduce using rule 14 (pointFx -> .)

    pointFx                        shift and go to state 28

state 23

    (86) classDef -> CLASS pointClass ID . pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (92) pointClassName -> .

    OBRACKET        reduce using rule 92 (pointClassName -> .)

    pointClassName                 shift and go to state 29

state 24

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end .

    $end            reduce using rule 1 (begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end .)


state 25

    (118) end -> END . OPAREN ID CPAREN

    OPAREN          shift and go to state 30


state 26

    (4) main -> MAIN pointMain . OPAREN CPAREN OBRACKET body CBRACKET

    OPAREN          shift and go to state 31


state 27

    (5) fxDef -> VOID FX pointFx . ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx . ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef

    ID              shift and go to state 32


state 28

    (7) fxDef -> fxType FX pointFx . ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx . ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    ID              shift and go to state 33


state 29

    (86) classDef -> CLASS pointClass ID pointClassName . OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    OBRACKET        shift and go to state 34


state 30

    (118) end -> END OPAREN . ID CPAREN

    ID              shift and go to state 35


state 31

    (4) main -> MAIN pointMain OPAREN . CPAREN OBRACKET body CBRACKET

    CPAREN          shift and go to state 36


state 32

    (5) fxDef -> VOID FX pointFx ID . pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx ID . pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (15) pointFxId -> .

    OPAREN          reduce using rule 15 (pointFxId -> .)

    pointFxId                      shift and go to state 37

state 33

    (7) fxDef -> fxType FX pointFx ID . pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx ID . pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (15) pointFxId -> .

    OPAREN          reduce using rule 15 (pointFxId -> .)

    pointFxId                      shift and go to state 38

state 34

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET . ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    ATTRIBUTES      shift and go to state 39


state 35

    (118) end -> END OPAREN ID . CPAREN

    CPAREN          shift and go to state 40


state 36

    (4) main -> MAIN pointMain OPAREN CPAREN . OBRACKET body CBRACKET

    OBRACKET        shift and go to state 41


state 37

    (5) fxDef -> VOID FX pointFx ID pointFxId . OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx ID pointFxId . OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef

    OPAREN          shift and go to state 42


state 38

    (7) fxDef -> fxType FX pointFx ID pointFxId . OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx ID pointFxId . OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    OPAREN          shift and go to state 43


state 39

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES . COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    COLON           shift and go to state 44


state 40

    (118) end -> END OPAREN ID CPAREN .

    $end            reduce using rule 118 (end -> END OPAREN ID CPAREN .)


state 41

    (4) main -> MAIN pointMain OPAREN CPAREN OBRACKET . body CBRACKET
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (119) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (116) input -> . INPUT OPAREN ID CPAREN EOF
    (117) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (107) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (111) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 119 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 45
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 42

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN . param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN . epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (18) param -> . paramType ID pointParam
    (19) param -> . paramType ID pointParam COMMA param
    (119) epsilon -> .
    (20) paramType -> . INT
    (21) paramType -> . STRING
    (22) paramType -> . DEC
    (23) paramType -> . BOOL

    CPAREN          reduce using rule 119 (epsilon -> .)
    INT             shift and go to state 65
    STRING          shift and go to state 66
    DEC             shift and go to state 67
    BOOL            shift and go to state 68

    param                          shift and go to state 62
    epsilon                        shift and go to state 63
    paramType                      shift and go to state 64

state 43

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN . param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN . epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (18) param -> . paramType ID pointParam
    (19) param -> . paramType ID pointParam COMMA param
    (119) epsilon -> .
    (20) paramType -> . INT
    (21) paramType -> . STRING
    (22) paramType -> . DEC
    (23) paramType -> . BOOL

    CPAREN          reduce using rule 119 (epsilon -> .)
    INT             shift and go to state 65
    STRING          shift and go to state 66
    DEC             shift and go to state 67
    BOOL            shift and go to state 68

    param                          shift and go to state 69
    epsilon                        shift and go to state 70
    paramType                      shift and go to state 64

state 44

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON . pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (88) pointAtt -> . varsDef
    (89) pointAtt -> . varsDef pointAtt
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF

    VAR             shift and go to state 49

    pointAtt                       shift and go to state 71
    varsDef                        shift and go to state 72

state 45

    (4) main -> MAIN pointMain OPAREN CPAREN OBRACKET body . CBRACKET

    CBRACKET        shift and go to state 73


state 46

    (33) body -> varsDef . body
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (119) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (116) input -> . INPUT OPAREN ID CPAREN EOF
    (117) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (107) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (111) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 119 (epsilon -> .)
    RETURN          reduce using rule 119 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    varsDef                        shift and go to state 46
    body                           shift and go to state 74
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 47

    (34) body -> statements . body
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (119) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (116) input -> . INPUT OPAREN ID CPAREN EOF
    (117) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (107) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (111) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 119 (epsilon -> .)
    RETURN          reduce using rule 119 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    statements                     shift and go to state 47
    body                           shift and go to state 75
    varsDef                        shift and go to state 46
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 48

    (35) body -> epsilon .

    CBRACKET        reduce using rule 35 (body -> epsilon .)
    RETURN          reduce using rule 35 (body -> epsilon .)


state 49

    (43) varsDef -> VAR . objType var EOF
    (44) varsDef -> VAR . varSimpleType var EOF
    (96) objType -> . ID
    (45) varSimpleType -> . INT
    (46) varSimpleType -> . STRING
    (47) varSimpleType -> . DEC
    (48) varSimpleType -> . BOOL

    ID              shift and go to state 78
    INT             shift and go to state 79
    STRING          shift and go to state 80
    DEC             shift and go to state 81
    BOOL            shift and go to state 82

    objType                        shift and go to state 76
    varSimpleType                  shift and go to state 77

state 50

    (36) statements -> assignmentDef .

    VAR             reduce using rule 36 (statements -> assignmentDef .)
    ID              reduce using rule 36 (statements -> assignmentDef .)
    INPUT           reduce using rule 36 (statements -> assignmentDef .)
    OUTPUT          reduce using rule 36 (statements -> assignmentDef .)
    WHILE           reduce using rule 36 (statements -> assignmentDef .)
    IF              reduce using rule 36 (statements -> assignmentDef .)
    CBRACKET        reduce using rule 36 (statements -> assignmentDef .)
    RETURN          reduce using rule 36 (statements -> assignmentDef .)


state 51

    (37) statements -> input .

    VAR             reduce using rule 37 (statements -> input .)
    ID              reduce using rule 37 (statements -> input .)
    INPUT           reduce using rule 37 (statements -> input .)
    OUTPUT          reduce using rule 37 (statements -> input .)
    WHILE           reduce using rule 37 (statements -> input .)
    IF              reduce using rule 37 (statements -> input .)
    CBRACKET        reduce using rule 37 (statements -> input .)
    RETURN          reduce using rule 37 (statements -> input .)


state 52

    (38) statements -> output .

    VAR             reduce using rule 38 (statements -> output .)
    ID              reduce using rule 38 (statements -> output .)
    INPUT           reduce using rule 38 (statements -> output .)
    OUTPUT          reduce using rule 38 (statements -> output .)
    WHILE           reduce using rule 38 (statements -> output .)
    IF              reduce using rule 38 (statements -> output .)
    CBRACKET        reduce using rule 38 (statements -> output .)
    RETURN          reduce using rule 38 (statements -> output .)


state 53

    (39) statements -> voidCall .

    VAR             reduce using rule 39 (statements -> voidCall .)
    ID              reduce using rule 39 (statements -> voidCall .)
    INPUT           reduce using rule 39 (statements -> voidCall .)
    OUTPUT          reduce using rule 39 (statements -> voidCall .)
    WHILE           reduce using rule 39 (statements -> voidCall .)
    IF              reduce using rule 39 (statements -> voidCall .)
    CBRACKET        reduce using rule 39 (statements -> voidCall .)
    RETURN          reduce using rule 39 (statements -> voidCall .)


state 54

    (40) statements -> whileCycle .

    VAR             reduce using rule 40 (statements -> whileCycle .)
    ID              reduce using rule 40 (statements -> whileCycle .)
    INPUT           reduce using rule 40 (statements -> whileCycle .)
    OUTPUT          reduce using rule 40 (statements -> whileCycle .)
    WHILE           reduce using rule 40 (statements -> whileCycle .)
    IF              reduce using rule 40 (statements -> whileCycle .)
    CBRACKET        reduce using rule 40 (statements -> whileCycle .)
    RETURN          reduce using rule 40 (statements -> whileCycle .)


state 55

    (41) statements -> ifCond .

    VAR             reduce using rule 41 (statements -> ifCond .)
    ID              reduce using rule 41 (statements -> ifCond .)
    INPUT           reduce using rule 41 (statements -> ifCond .)
    OUTPUT          reduce using rule 41 (statements -> ifCond .)
    WHILE           reduce using rule 41 (statements -> ifCond .)
    IF              reduce using rule 41 (statements -> ifCond .)
    CBRACKET        reduce using rule 41 (statements -> ifCond .)
    RETURN          reduce using rule 41 (statements -> ifCond .)


state 56

    (42) statements -> classCall .

    VAR             reduce using rule 42 (statements -> classCall .)
    ID              reduce using rule 42 (statements -> classCall .)
    INPUT           reduce using rule 42 (statements -> classCall .)
    OUTPUT          reduce using rule 42 (statements -> classCall .)
    WHILE           reduce using rule 42 (statements -> classCall .)
    IF              reduce using rule 42 (statements -> classCall .)
    CBRACKET        reduce using rule 42 (statements -> classCall .)
    RETURN          reduce using rule 42 (statements -> classCall .)


state 57

    (56) assignmentDef -> ID . ASSIGNMENT pointPushAssignment expAssignment
    (29) voidCall -> ID . pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> ID . pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (94) classCall -> ID . MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> ID . MONEY ID OPAREN epsilon CPAREN EOF
    (31) pointEra -> .

    ASSIGNMENT      shift and go to state 83
    MONEY           shift and go to state 85
    OPAREN          reduce using rule 31 (pointEra -> .)

    pointEra                       shift and go to state 84

state 58

    (116) input -> INPUT . OPAREN ID CPAREN EOF

    OPAREN          shift and go to state 86


state 59

    (117) output -> OUTPUT . OPAREN expRelational CPAREN EOF

    OPAREN          shift and go to state 87


state 60

    (107) whileCycle -> WHILE . pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (108) pointWhile1 -> .

    OPAREN          reduce using rule 108 (pointWhile1 -> .)

    pointWhile1                    shift and go to state 88

state 61

    (111) ifCond -> IF . OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> IF . OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    OPAREN          shift and go to state 89


state 62

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param . CPAREN OBRACKET body CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 90


state 63

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon . CPAREN OBRACKET body CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 91


state 64

    (18) param -> paramType . ID pointParam
    (19) param -> paramType . ID pointParam COMMA param

    ID              shift and go to state 92


state 65

    (20) paramType -> INT .

    ID              reduce using rule 20 (paramType -> INT .)


state 66

    (21) paramType -> STRING .

    ID              reduce using rule 21 (paramType -> STRING .)


state 67

    (22) paramType -> DEC .

    ID              reduce using rule 22 (paramType -> DEC .)


state 68

    (23) paramType -> BOOL .

    ID              reduce using rule 23 (paramType -> BOOL .)


state 69

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param . CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 93


state 70

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon . CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 94


state 71

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt . METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    METHODS         shift and go to state 95


state 72

    (88) pointAtt -> varsDef .
    (89) pointAtt -> varsDef . pointAtt
    (88) pointAtt -> . varsDef
    (89) pointAtt -> . varsDef pointAtt
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF

    METHODS         reduce using rule 88 (pointAtt -> varsDef .)
    VAR             shift and go to state 49

    varsDef                        shift and go to state 72
    pointAtt                       shift and go to state 96

state 73

    (4) main -> MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET .

    END             reduce using rule 4 (main -> MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET .)


state 74

    (33) body -> varsDef body .

    CBRACKET        reduce using rule 33 (body -> varsDef body .)
    RETURN          reduce using rule 33 (body -> varsDef body .)


state 75

    (34) body -> statements body .

    CBRACKET        reduce using rule 34 (body -> statements body .)
    RETURN          reduce using rule 34 (body -> statements body .)


state 76

    (43) varsDef -> VAR objType . var EOF
    (49) var -> . varsType
    (50) var -> . varsType COMMA var
    (51) varsType -> . ID
    (52) varsType -> . arrDef
    (53) varsType -> . matrixDef
    (54) arrDef -> . ID OSQUAREBR varCte CSQUAREBR
    (55) matrixDef -> . arrDef OSQUAREBR varCte CSQUAREBR

    ID              shift and go to state 99

    var                            shift and go to state 97
    varsType                       shift and go to state 98
    arrDef                         shift and go to state 100
    matrixDef                      shift and go to state 101

state 77

    (44) varsDef -> VAR varSimpleType . var EOF
    (49) var -> . varsType
    (50) var -> . varsType COMMA var
    (51) varsType -> . ID
    (52) varsType -> . arrDef
    (53) varsType -> . matrixDef
    (54) arrDef -> . ID OSQUAREBR varCte CSQUAREBR
    (55) matrixDef -> . arrDef OSQUAREBR varCte CSQUAREBR

    ID              shift and go to state 99

    var                            shift and go to state 102
    varsType                       shift and go to state 98
    arrDef                         shift and go to state 100
    matrixDef                      shift and go to state 101

state 78

    (96) objType -> ID .

    ID              reduce using rule 96 (objType -> ID .)


state 79

    (45) varSimpleType -> INT .

    ID              reduce using rule 45 (varSimpleType -> INT .)


state 80

    (46) varSimpleType -> STRING .

    ID              reduce using rule 46 (varSimpleType -> STRING .)


state 81

    (47) varSimpleType -> DEC .

    ID              reduce using rule 47 (varSimpleType -> DEC .)


state 82

    (48) varSimpleType -> BOOL .

    ID              reduce using rule 48 (varSimpleType -> BOOL .)


state 83

    (56) assignmentDef -> ID ASSIGNMENT . pointPushAssignment expAssignment
    (57) pointPushAssignment -> .

    ID              reduce using rule 57 (pointPushAssignment -> .)
    OPAREN          reduce using rule 57 (pointPushAssignment -> .)
    INT             reduce using rule 57 (pointPushAssignment -> .)
    DEC             reduce using rule 57 (pointPushAssignment -> .)
    STRING          reduce using rule 57 (pointPushAssignment -> .)
    TRUE            reduce using rule 57 (pointPushAssignment -> .)
    FALSE           reduce using rule 57 (pointPushAssignment -> .)

    pointPushAssignment            shift and go to state 103

state 84

    (29) voidCall -> ID pointEra . OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> ID pointEra . OPAREN epsilon pointGoSub CPAREN EOF

    OPAREN          shift and go to state 104


state 85

    (94) classCall -> ID MONEY . ID OPAREN paramCall CPAREN EOF
    (95) classCall -> ID MONEY . ID OPAREN epsilon CPAREN EOF

    ID              shift and go to state 105


state 86

    (116) input -> INPUT OPAREN . ID CPAREN EOF

    ID              shift and go to state 106


state 87

    (117) output -> OUTPUT OPAREN . expRelational CPAREN EOF
    (63) expRelational -> . plusMinus
    (64) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . TRUE pointBOOL
    (101) varCte -> . FALSE pointBOOL
    (102) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    expRelational                  shift and go to state 108
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 88

    (107) whileCycle -> WHILE pointWhile1 . OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3

    OPAREN          shift and go to state 119


state 89

    (111) ifCond -> IF OPAREN . expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> IF OPAREN . expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (63) expRelational -> . plusMinus
    (64) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . TRUE pointBOOL
    (101) varCte -> . FALSE pointBOOL
    (102) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    expRelational                  shift and go to state 120
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 90

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN . OBRACKET body CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 121


state 91

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN . OBRACKET body CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 122


state 92

    (18) param -> paramType ID . pointParam
    (19) param -> paramType ID . pointParam COMMA param
    (24) pointParam -> .

    COMMA           reduce using rule 24 (pointParam -> .)
    CPAREN          reduce using rule 24 (pointParam -> .)

    pointParam                     shift and go to state 123

state 93

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN . OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 124


state 94

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN . OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 125


state 95

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS . COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    COLON           shift and go to state 126


state 96

    (89) pointAtt -> varsDef pointAtt .

    METHODS         reduce using rule 89 (pointAtt -> varsDef pointAtt .)


state 97

    (43) varsDef -> VAR objType var . EOF

    EOF             shift and go to state 127


state 98

    (49) var -> varsType .
    (50) var -> varsType . COMMA var

    EOF             reduce using rule 49 (var -> varsType .)
    COMMA           shift and go to state 128


state 99

    (51) varsType -> ID .
    (54) arrDef -> ID . OSQUAREBR varCte CSQUAREBR

    COMMA           reduce using rule 51 (varsType -> ID .)
    EOF             reduce using rule 51 (varsType -> ID .)
    OSQUAREBR       shift and go to state 129


state 100

    (52) varsType -> arrDef .
    (55) matrixDef -> arrDef . OSQUAREBR varCte CSQUAREBR

    COMMA           reduce using rule 52 (varsType -> arrDef .)
    EOF             reduce using rule 52 (varsType -> arrDef .)
    OSQUAREBR       shift and go to state 130


state 101

    (53) varsType -> matrixDef .

    COMMA           reduce using rule 53 (varsType -> matrixDef .)
    EOF             reduce using rule 53 (varsType -> matrixDef .)


state 102

    (44) varsDef -> VAR varSimpleType var . EOF

    EOF             shift and go to state 131


state 103

    (56) assignmentDef -> ID ASSIGNMENT pointPushAssignment . expAssignment
    (58) expAssignment -> . expRelational EOF
    (59) expAssignment -> . returnCall EOF
    (60) expAssignment -> . classCall
    (63) expRelational -> . plusMinus
    (64) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (61) returnCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN
    (62) returnCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . TRUE pointBOOL
    (101) varCte -> . FALSE pointBOOL
    (102) varCte -> . ID

    ID              shift and go to state 132
    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117

    expAssignment                  shift and go to state 133
    expRelational                  shift and go to state 134
    returnCall                     shift and go to state 135
    classCall                      shift and go to state 136
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 104

    (29) voidCall -> ID pointEra OPAREN . paramCall pointGoSub CPAREN EOF
    (30) voidCall -> ID pointEra OPAREN . epsilon pointGoSub CPAREN EOF
    (25) paramCall -> . ID pointParamCall pointParamNum
    (26) paramCall -> . ID pointParamCall COMMA paramCall
    (119) epsilon -> .

    ID              shift and go to state 137
    CPAREN          reduce using rule 119 (epsilon -> .)

    paramCall                      shift and go to state 138
    epsilon                        shift and go to state 139

state 105

    (94) classCall -> ID MONEY ID . OPAREN paramCall CPAREN EOF
    (95) classCall -> ID MONEY ID . OPAREN epsilon CPAREN EOF

    OPAREN          shift and go to state 140


state 106

    (116) input -> INPUT OPAREN ID . CPAREN EOF

    CPAREN          shift and go to state 141


state 107

    (82) expParen -> OPAREN . pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (84) pointFakeBackground -> .

    OPAREN          reduce using rule 84 (pointFakeBackground -> .)
    INT             reduce using rule 84 (pointFakeBackground -> .)
    DEC             reduce using rule 84 (pointFakeBackground -> .)
    STRING          reduce using rule 84 (pointFakeBackground -> .)
    TRUE            reduce using rule 84 (pointFakeBackground -> .)
    FALSE           reduce using rule 84 (pointFakeBackground -> .)
    ID              reduce using rule 84 (pointFakeBackground -> .)

    pointFakeBackground            shift and go to state 142

state 108

    (117) output -> OUTPUT OPAREN expRelational . CPAREN EOF

    CPAREN          shift and go to state 143


state 109

    (63) expRelational -> plusMinus .
    (64) expRelational -> plusMinus . opRelational expRelational pointCheckOpRel
    (66) opRelational -> . EQUAL
    (67) opRelational -> . DIFFERENT
    (68) opRelational -> . GREATERTHAN
    (69) opRelational -> . GREATERTHANEQ
    (70) opRelational -> . LESSTHAN
    (71) opRelational -> . LESSTHANEQ

    CPAREN          reduce using rule 63 (expRelational -> plusMinus .)
    EOF             reduce using rule 63 (expRelational -> plusMinus .)
    EQUAL           shift and go to state 145
    DIFFERENT       shift and go to state 146
    GREATERTHAN     shift and go to state 147
    GREATERTHANEQ   shift and go to state 148
    LESSTHAN        shift and go to state 149
    LESSTHANEQ      shift and go to state 150

    opRelational                   shift and go to state 144

state 110

    (72) plusMinus -> multDiv . pointCheckPlusMinus
    (73) plusMinus -> multDiv . pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> multDiv . pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (75) pointCheckPlusMinus -> .

    PLUS            reduce using rule 75 (pointCheckPlusMinus -> .)
    MINUS           reduce using rule 75 (pointCheckPlusMinus -> .)
    EQUAL           reduce using rule 75 (pointCheckPlusMinus -> .)
    DIFFERENT       reduce using rule 75 (pointCheckPlusMinus -> .)
    GREATERTHAN     reduce using rule 75 (pointCheckPlusMinus -> .)
    GREATERTHANEQ   reduce using rule 75 (pointCheckPlusMinus -> .)
    LESSTHAN        reduce using rule 75 (pointCheckPlusMinus -> .)
    LESSTHANEQ      reduce using rule 75 (pointCheckPlusMinus -> .)
    CPAREN          reduce using rule 75 (pointCheckPlusMinus -> .)
    EOF             reduce using rule 75 (pointCheckPlusMinus -> .)

    pointCheckPlusMinus            shift and go to state 151

state 111

    (77) multDiv -> expParen . pointCheckMultDiv
    (78) multDiv -> expParen . pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> expParen . pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (80) pointCheckMultDiv -> .

    MULTIPLY        reduce using rule 80 (pointCheckMultDiv -> .)
    DIVIDE          reduce using rule 80 (pointCheckMultDiv -> .)
    PLUS            reduce using rule 80 (pointCheckMultDiv -> .)
    MINUS           reduce using rule 80 (pointCheckMultDiv -> .)
    EQUAL           reduce using rule 80 (pointCheckMultDiv -> .)
    DIFFERENT       reduce using rule 80 (pointCheckMultDiv -> .)
    GREATERTHAN     reduce using rule 80 (pointCheckMultDiv -> .)
    GREATERTHANEQ   reduce using rule 80 (pointCheckMultDiv -> .)
    LESSTHAN        reduce using rule 80 (pointCheckMultDiv -> .)
    LESSTHANEQ      reduce using rule 80 (pointCheckMultDiv -> .)
    CPAREN          reduce using rule 80 (pointCheckMultDiv -> .)
    EOF             reduce using rule 80 (pointCheckMultDiv -> .)

    pointCheckMultDiv              shift and go to state 152

state 112

    (83) expParen -> varCte .

    MULTIPLY        reduce using rule 83 (expParen -> varCte .)
    DIVIDE          reduce using rule 83 (expParen -> varCte .)
    PLUS            reduce using rule 83 (expParen -> varCte .)
    MINUS           reduce using rule 83 (expParen -> varCte .)
    EQUAL           reduce using rule 83 (expParen -> varCte .)
    DIFFERENT       reduce using rule 83 (expParen -> varCte .)
    GREATERTHAN     reduce using rule 83 (expParen -> varCte .)
    GREATERTHANEQ   reduce using rule 83 (expParen -> varCte .)
    LESSTHAN        reduce using rule 83 (expParen -> varCte .)
    LESSTHANEQ      reduce using rule 83 (expParen -> varCte .)
    CPAREN          reduce using rule 83 (expParen -> varCte .)
    EOF             reduce using rule 83 (expParen -> varCte .)


state 113

    (97) varCte -> INT . pointINT
    (103) pointINT -> .

    MULTIPLY        reduce using rule 103 (pointINT -> .)
    DIVIDE          reduce using rule 103 (pointINT -> .)
    PLUS            reduce using rule 103 (pointINT -> .)
    MINUS           reduce using rule 103 (pointINT -> .)
    EQUAL           reduce using rule 103 (pointINT -> .)
    DIFFERENT       reduce using rule 103 (pointINT -> .)
    GREATERTHAN     reduce using rule 103 (pointINT -> .)
    GREATERTHANEQ   reduce using rule 103 (pointINT -> .)
    LESSTHAN        reduce using rule 103 (pointINT -> .)
    LESSTHANEQ      reduce using rule 103 (pointINT -> .)
    CPAREN          reduce using rule 103 (pointINT -> .)
    EOF             reduce using rule 103 (pointINT -> .)
    CSQUAREBR       reduce using rule 103 (pointINT -> .)

    pointINT                       shift and go to state 153

state 114

    (98) varCte -> DEC . pointDEC
    (104) pointDEC -> .

    MULTIPLY        reduce using rule 104 (pointDEC -> .)
    DIVIDE          reduce using rule 104 (pointDEC -> .)
    PLUS            reduce using rule 104 (pointDEC -> .)
    MINUS           reduce using rule 104 (pointDEC -> .)
    EQUAL           reduce using rule 104 (pointDEC -> .)
    DIFFERENT       reduce using rule 104 (pointDEC -> .)
    GREATERTHAN     reduce using rule 104 (pointDEC -> .)
    GREATERTHANEQ   reduce using rule 104 (pointDEC -> .)
    LESSTHAN        reduce using rule 104 (pointDEC -> .)
    LESSTHANEQ      reduce using rule 104 (pointDEC -> .)
    CPAREN          reduce using rule 104 (pointDEC -> .)
    EOF             reduce using rule 104 (pointDEC -> .)
    CSQUAREBR       reduce using rule 104 (pointDEC -> .)

    pointDEC                       shift and go to state 154

state 115

    (99) varCte -> STRING . pointSTRING
    (105) pointSTRING -> .

    MULTIPLY        reduce using rule 105 (pointSTRING -> .)
    DIVIDE          reduce using rule 105 (pointSTRING -> .)
    PLUS            reduce using rule 105 (pointSTRING -> .)
    MINUS           reduce using rule 105 (pointSTRING -> .)
    EQUAL           reduce using rule 105 (pointSTRING -> .)
    DIFFERENT       reduce using rule 105 (pointSTRING -> .)
    GREATERTHAN     reduce using rule 105 (pointSTRING -> .)
    GREATERTHANEQ   reduce using rule 105 (pointSTRING -> .)
    LESSTHAN        reduce using rule 105 (pointSTRING -> .)
    LESSTHANEQ      reduce using rule 105 (pointSTRING -> .)
    CPAREN          reduce using rule 105 (pointSTRING -> .)
    EOF             reduce using rule 105 (pointSTRING -> .)
    CSQUAREBR       reduce using rule 105 (pointSTRING -> .)

    pointSTRING                    shift and go to state 155

state 116

    (100) varCte -> TRUE . pointBOOL
    (106) pointBOOL -> .

    MULTIPLY        reduce using rule 106 (pointBOOL -> .)
    DIVIDE          reduce using rule 106 (pointBOOL -> .)
    PLUS            reduce using rule 106 (pointBOOL -> .)
    MINUS           reduce using rule 106 (pointBOOL -> .)
    EQUAL           reduce using rule 106 (pointBOOL -> .)
    DIFFERENT       reduce using rule 106 (pointBOOL -> .)
    GREATERTHAN     reduce using rule 106 (pointBOOL -> .)
    GREATERTHANEQ   reduce using rule 106 (pointBOOL -> .)
    LESSTHAN        reduce using rule 106 (pointBOOL -> .)
    LESSTHANEQ      reduce using rule 106 (pointBOOL -> .)
    CPAREN          reduce using rule 106 (pointBOOL -> .)
    EOF             reduce using rule 106 (pointBOOL -> .)
    CSQUAREBR       reduce using rule 106 (pointBOOL -> .)

    pointBOOL                      shift and go to state 156

state 117

    (101) varCte -> FALSE . pointBOOL
    (106) pointBOOL -> .

    MULTIPLY        reduce using rule 106 (pointBOOL -> .)
    DIVIDE          reduce using rule 106 (pointBOOL -> .)
    PLUS            reduce using rule 106 (pointBOOL -> .)
    MINUS           reduce using rule 106 (pointBOOL -> .)
    EQUAL           reduce using rule 106 (pointBOOL -> .)
    DIFFERENT       reduce using rule 106 (pointBOOL -> .)
    GREATERTHAN     reduce using rule 106 (pointBOOL -> .)
    GREATERTHANEQ   reduce using rule 106 (pointBOOL -> .)
    LESSTHAN        reduce using rule 106 (pointBOOL -> .)
    LESSTHANEQ      reduce using rule 106 (pointBOOL -> .)
    CPAREN          reduce using rule 106 (pointBOOL -> .)
    EOF             reduce using rule 106 (pointBOOL -> .)
    CSQUAREBR       reduce using rule 106 (pointBOOL -> .)

    pointBOOL                      shift and go to state 157

state 118

    (102) varCte -> ID .

    MULTIPLY        reduce using rule 102 (varCte -> ID .)
    DIVIDE          reduce using rule 102 (varCte -> ID .)
    PLUS            reduce using rule 102 (varCte -> ID .)
    MINUS           reduce using rule 102 (varCte -> ID .)
    EQUAL           reduce using rule 102 (varCte -> ID .)
    DIFFERENT       reduce using rule 102 (varCte -> ID .)
    GREATERTHAN     reduce using rule 102 (varCte -> ID .)
    GREATERTHANEQ   reduce using rule 102 (varCte -> ID .)
    LESSTHAN        reduce using rule 102 (varCte -> ID .)
    LESSTHANEQ      reduce using rule 102 (varCte -> ID .)
    CPAREN          reduce using rule 102 (varCte -> ID .)
    CSQUAREBR       reduce using rule 102 (varCte -> ID .)
    EOF             reduce using rule 102 (varCte -> ID .)


state 119

    (107) whileCycle -> WHILE pointWhile1 OPAREN . expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (63) expRelational -> . plusMinus
    (64) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . TRUE pointBOOL
    (101) varCte -> . FALSE pointBOOL
    (102) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    expRelational                  shift and go to state 158
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 120

    (111) ifCond -> IF OPAREN expRelational . CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> IF OPAREN expRelational . CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    CPAREN          shift and go to state 159


state 121

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET . body CBRACKET pointEndFunc fxDef
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (119) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (116) input -> . INPUT OPAREN ID CPAREN EOF
    (117) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (107) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (111) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 119 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 160
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 122

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET . body CBRACKET pointEndFunc fxDef
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (119) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (116) input -> . INPUT OPAREN ID CPAREN EOF
    (117) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (107) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (111) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 119 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    epsilon                        shift and go to state 48
    body                           shift and go to state 161
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 123

    (18) param -> paramType ID pointParam .
    (19) param -> paramType ID pointParam . COMMA param

    CPAREN          reduce using rule 18 (param -> paramType ID pointParam .)
    COMMA           shift and go to state 162


state 124

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET . body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (119) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (116) input -> . INPUT OPAREN ID CPAREN EOF
    (117) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (107) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (111) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    RETURN          reduce using rule 119 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 163
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 125

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET . body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (119) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (116) input -> . INPUT OPAREN ID CPAREN EOF
    (117) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (107) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (111) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    RETURN          reduce using rule 119 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    epsilon                        shift and go to state 48
    body                           shift and go to state 164
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 126

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON . pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (90) pointScopeClass -> .

    VOID            reduce using rule 90 (pointScopeClass -> .)
    INT             reduce using rule 90 (pointScopeClass -> .)
    STRING          reduce using rule 90 (pointScopeClass -> .)
    DEC             reduce using rule 90 (pointScopeClass -> .)
    BOOL            reduce using rule 90 (pointScopeClass -> .)
    CBRACKET        reduce using rule 90 (pointScopeClass -> .)

    pointScopeClass                shift and go to state 165

state 127

    (43) varsDef -> VAR objType var EOF .

    VAR             reduce using rule 43 (varsDef -> VAR objType var EOF .)
    ID              reduce using rule 43 (varsDef -> VAR objType var EOF .)
    INPUT           reduce using rule 43 (varsDef -> VAR objType var EOF .)
    OUTPUT          reduce using rule 43 (varsDef -> VAR objType var EOF .)
    WHILE           reduce using rule 43 (varsDef -> VAR objType var EOF .)
    IF              reduce using rule 43 (varsDef -> VAR objType var EOF .)
    CBRACKET        reduce using rule 43 (varsDef -> VAR objType var EOF .)
    METHODS         reduce using rule 43 (varsDef -> VAR objType var EOF .)
    RETURN          reduce using rule 43 (varsDef -> VAR objType var EOF .)


state 128

    (50) var -> varsType COMMA . var
    (49) var -> . varsType
    (50) var -> . varsType COMMA var
    (51) varsType -> . ID
    (52) varsType -> . arrDef
    (53) varsType -> . matrixDef
    (54) arrDef -> . ID OSQUAREBR varCte CSQUAREBR
    (55) matrixDef -> . arrDef OSQUAREBR varCte CSQUAREBR

    ID              shift and go to state 99

    varsType                       shift and go to state 98
    var                            shift and go to state 166
    arrDef                         shift and go to state 100
    matrixDef                      shift and go to state 101

state 129

    (54) arrDef -> ID OSQUAREBR . varCte CSQUAREBR
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . TRUE pointBOOL
    (101) varCte -> . FALSE pointBOOL
    (102) varCte -> . ID

    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    varCte                         shift and go to state 167

state 130

    (55) matrixDef -> arrDef OSQUAREBR . varCte CSQUAREBR
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . TRUE pointBOOL
    (101) varCte -> . FALSE pointBOOL
    (102) varCte -> . ID

    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    varCte                         shift and go to state 168

state 131

    (44) varsDef -> VAR varSimpleType var EOF .

    VAR             reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    ID              reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    INPUT           reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    OUTPUT          reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    WHILE           reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    IF              reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    CBRACKET        reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    METHODS         reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)
    RETURN          reduce using rule 44 (varsDef -> VAR varSimpleType var EOF .)


state 132

    (61) returnCall -> ID . pointEra OPAREN paramCall pointGoSub CPAREN
    (62) returnCall -> ID . pointEra OPAREN epsilon pointGoSub CPAREN
    (94) classCall -> ID . MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> ID . MONEY ID OPAREN epsilon CPAREN EOF
    (102) varCte -> ID .
    (31) pointEra -> .

    MONEY           shift and go to state 85
    MULTIPLY        reduce using rule 102 (varCte -> ID .)
    DIVIDE          reduce using rule 102 (varCte -> ID .)
    PLUS            reduce using rule 102 (varCte -> ID .)
    MINUS           reduce using rule 102 (varCte -> ID .)
    EQUAL           reduce using rule 102 (varCte -> ID .)
    DIFFERENT       reduce using rule 102 (varCte -> ID .)
    GREATERTHAN     reduce using rule 102 (varCte -> ID .)
    GREATERTHANEQ   reduce using rule 102 (varCte -> ID .)
    LESSTHAN        reduce using rule 102 (varCte -> ID .)
    LESSTHANEQ      reduce using rule 102 (varCte -> ID .)
    EOF             reduce using rule 102 (varCte -> ID .)
    OPAREN          reduce using rule 31 (pointEra -> .)

    pointEra                       shift and go to state 169

state 133

    (56) assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .

    VAR             reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    ID              reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    INPUT           reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    OUTPUT          reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    WHILE           reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    IF              reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    CBRACKET        reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    RETURN          reduce using rule 56 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)


state 134

    (58) expAssignment -> expRelational . EOF

    EOF             shift and go to state 170


state 135

    (59) expAssignment -> returnCall . EOF

    EOF             shift and go to state 171


state 136

    (60) expAssignment -> classCall .

    VAR             reduce using rule 60 (expAssignment -> classCall .)
    ID              reduce using rule 60 (expAssignment -> classCall .)
    INPUT           reduce using rule 60 (expAssignment -> classCall .)
    OUTPUT          reduce using rule 60 (expAssignment -> classCall .)
    WHILE           reduce using rule 60 (expAssignment -> classCall .)
    IF              reduce using rule 60 (expAssignment -> classCall .)
    CBRACKET        reduce using rule 60 (expAssignment -> classCall .)
    RETURN          reduce using rule 60 (expAssignment -> classCall .)


state 137

    (25) paramCall -> ID . pointParamCall pointParamNum
    (26) paramCall -> ID . pointParamCall COMMA paramCall
    (28) pointParamCall -> .

    COMMA           reduce using rule 28 (pointParamCall -> .)
    CPAREN          reduce using rule 28 (pointParamCall -> .)

    pointParamCall                 shift and go to state 172

state 138

    (29) voidCall -> ID pointEra OPAREN paramCall . pointGoSub CPAREN EOF
    (32) pointGoSub -> .

    CPAREN          reduce using rule 32 (pointGoSub -> .)

    pointGoSub                     shift and go to state 173

state 139

    (30) voidCall -> ID pointEra OPAREN epsilon . pointGoSub CPAREN EOF
    (32) pointGoSub -> .

    CPAREN          reduce using rule 32 (pointGoSub -> .)

    pointGoSub                     shift and go to state 174

state 140

    (94) classCall -> ID MONEY ID OPAREN . paramCall CPAREN EOF
    (95) classCall -> ID MONEY ID OPAREN . epsilon CPAREN EOF
    (25) paramCall -> . ID pointParamCall pointParamNum
    (26) paramCall -> . ID pointParamCall COMMA paramCall
    (119) epsilon -> .

    ID              shift and go to state 137
    CPAREN          reduce using rule 119 (epsilon -> .)

    paramCall                      shift and go to state 175
    epsilon                        shift and go to state 176

state 141

    (116) input -> INPUT OPAREN ID CPAREN . EOF

    EOF             shift and go to state 177


state 142

    (82) expParen -> OPAREN pointFakeBackground . expRelational CPAREN pointRemoveFakeBackground
    (63) expRelational -> . plusMinus
    (64) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . TRUE pointBOOL
    (101) varCte -> . FALSE pointBOOL
    (102) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    expRelational                  shift and go to state 178
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 143

    (117) output -> OUTPUT OPAREN expRelational CPAREN . EOF

    EOF             shift and go to state 179


state 144

    (64) expRelational -> plusMinus opRelational . expRelational pointCheckOpRel
    (63) expRelational -> . plusMinus
    (64) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . TRUE pointBOOL
    (101) varCte -> . FALSE pointBOOL
    (102) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    plusMinus                      shift and go to state 109
    expRelational                  shift and go to state 180
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 145

    (66) opRelational -> EQUAL .

    OPAREN          reduce using rule 66 (opRelational -> EQUAL .)
    INT             reduce using rule 66 (opRelational -> EQUAL .)
    DEC             reduce using rule 66 (opRelational -> EQUAL .)
    STRING          reduce using rule 66 (opRelational -> EQUAL .)
    TRUE            reduce using rule 66 (opRelational -> EQUAL .)
    FALSE           reduce using rule 66 (opRelational -> EQUAL .)
    ID              reduce using rule 66 (opRelational -> EQUAL .)


state 146

    (67) opRelational -> DIFFERENT .

    OPAREN          reduce using rule 67 (opRelational -> DIFFERENT .)
    INT             reduce using rule 67 (opRelational -> DIFFERENT .)
    DEC             reduce using rule 67 (opRelational -> DIFFERENT .)
    STRING          reduce using rule 67 (opRelational -> DIFFERENT .)
    TRUE            reduce using rule 67 (opRelational -> DIFFERENT .)
    FALSE           reduce using rule 67 (opRelational -> DIFFERENT .)
    ID              reduce using rule 67 (opRelational -> DIFFERENT .)


state 147

    (68) opRelational -> GREATERTHAN .

    OPAREN          reduce using rule 68 (opRelational -> GREATERTHAN .)
    INT             reduce using rule 68 (opRelational -> GREATERTHAN .)
    DEC             reduce using rule 68 (opRelational -> GREATERTHAN .)
    STRING          reduce using rule 68 (opRelational -> GREATERTHAN .)
    TRUE            reduce using rule 68 (opRelational -> GREATERTHAN .)
    FALSE           reduce using rule 68 (opRelational -> GREATERTHAN .)
    ID              reduce using rule 68 (opRelational -> GREATERTHAN .)


state 148

    (69) opRelational -> GREATERTHANEQ .

    OPAREN          reduce using rule 69 (opRelational -> GREATERTHANEQ .)
    INT             reduce using rule 69 (opRelational -> GREATERTHANEQ .)
    DEC             reduce using rule 69 (opRelational -> GREATERTHANEQ .)
    STRING          reduce using rule 69 (opRelational -> GREATERTHANEQ .)
    TRUE            reduce using rule 69 (opRelational -> GREATERTHANEQ .)
    FALSE           reduce using rule 69 (opRelational -> GREATERTHANEQ .)
    ID              reduce using rule 69 (opRelational -> GREATERTHANEQ .)


state 149

    (70) opRelational -> LESSTHAN .

    OPAREN          reduce using rule 70 (opRelational -> LESSTHAN .)
    INT             reduce using rule 70 (opRelational -> LESSTHAN .)
    DEC             reduce using rule 70 (opRelational -> LESSTHAN .)
    STRING          reduce using rule 70 (opRelational -> LESSTHAN .)
    TRUE            reduce using rule 70 (opRelational -> LESSTHAN .)
    FALSE           reduce using rule 70 (opRelational -> LESSTHAN .)
    ID              reduce using rule 70 (opRelational -> LESSTHAN .)


state 150

    (71) opRelational -> LESSTHANEQ .

    OPAREN          reduce using rule 71 (opRelational -> LESSTHANEQ .)
    INT             reduce using rule 71 (opRelational -> LESSTHANEQ .)
    DEC             reduce using rule 71 (opRelational -> LESSTHANEQ .)
    STRING          reduce using rule 71 (opRelational -> LESSTHANEQ .)
    TRUE            reduce using rule 71 (opRelational -> LESSTHANEQ .)
    FALSE           reduce using rule 71 (opRelational -> LESSTHANEQ .)
    ID              reduce using rule 71 (opRelational -> LESSTHANEQ .)


state 151

    (72) plusMinus -> multDiv pointCheckPlusMinus .
    (73) plusMinus -> multDiv pointCheckPlusMinus . PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> multDiv pointCheckPlusMinus . MINUS pointPushPlusMinus plusMinus

    EQUAL           reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    DIFFERENT       reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    GREATERTHAN     reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    GREATERTHANEQ   reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    LESSTHAN        reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    LESSTHANEQ      reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    CPAREN          reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    EOF             reduce using rule 72 (plusMinus -> multDiv pointCheckPlusMinus .)
    PLUS            shift and go to state 181
    MINUS           shift and go to state 182


state 152

    (77) multDiv -> expParen pointCheckMultDiv .
    (78) multDiv -> expParen pointCheckMultDiv . MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> expParen pointCheckMultDiv . DIVIDE pointPushMultDiv multDiv

    PLUS            reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    MINUS           reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    EQUAL           reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    DIFFERENT       reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    GREATERTHAN     reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    GREATERTHANEQ   reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    LESSTHAN        reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    LESSTHANEQ      reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    CPAREN          reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    EOF             reduce using rule 77 (multDiv -> expParen pointCheckMultDiv .)
    MULTIPLY        shift and go to state 183
    DIVIDE          shift and go to state 184


state 153

    (97) varCte -> INT pointINT .

    MULTIPLY        reduce using rule 97 (varCte -> INT pointINT .)
    DIVIDE          reduce using rule 97 (varCte -> INT pointINT .)
    PLUS            reduce using rule 97 (varCte -> INT pointINT .)
    MINUS           reduce using rule 97 (varCte -> INT pointINT .)
    EQUAL           reduce using rule 97 (varCte -> INT pointINT .)
    DIFFERENT       reduce using rule 97 (varCte -> INT pointINT .)
    GREATERTHAN     reduce using rule 97 (varCte -> INT pointINT .)
    GREATERTHANEQ   reduce using rule 97 (varCte -> INT pointINT .)
    LESSTHAN        reduce using rule 97 (varCte -> INT pointINT .)
    LESSTHANEQ      reduce using rule 97 (varCte -> INT pointINT .)
    CPAREN          reduce using rule 97 (varCte -> INT pointINT .)
    EOF             reduce using rule 97 (varCte -> INT pointINT .)
    CSQUAREBR       reduce using rule 97 (varCte -> INT pointINT .)


state 154

    (98) varCte -> DEC pointDEC .

    MULTIPLY        reduce using rule 98 (varCte -> DEC pointDEC .)
    DIVIDE          reduce using rule 98 (varCte -> DEC pointDEC .)
    PLUS            reduce using rule 98 (varCte -> DEC pointDEC .)
    MINUS           reduce using rule 98 (varCte -> DEC pointDEC .)
    EQUAL           reduce using rule 98 (varCte -> DEC pointDEC .)
    DIFFERENT       reduce using rule 98 (varCte -> DEC pointDEC .)
    GREATERTHAN     reduce using rule 98 (varCte -> DEC pointDEC .)
    GREATERTHANEQ   reduce using rule 98 (varCte -> DEC pointDEC .)
    LESSTHAN        reduce using rule 98 (varCte -> DEC pointDEC .)
    LESSTHANEQ      reduce using rule 98 (varCte -> DEC pointDEC .)
    CPAREN          reduce using rule 98 (varCte -> DEC pointDEC .)
    EOF             reduce using rule 98 (varCte -> DEC pointDEC .)
    CSQUAREBR       reduce using rule 98 (varCte -> DEC pointDEC .)


state 155

    (99) varCte -> STRING pointSTRING .

    MULTIPLY        reduce using rule 99 (varCte -> STRING pointSTRING .)
    DIVIDE          reduce using rule 99 (varCte -> STRING pointSTRING .)
    PLUS            reduce using rule 99 (varCte -> STRING pointSTRING .)
    MINUS           reduce using rule 99 (varCte -> STRING pointSTRING .)
    EQUAL           reduce using rule 99 (varCte -> STRING pointSTRING .)
    DIFFERENT       reduce using rule 99 (varCte -> STRING pointSTRING .)
    GREATERTHAN     reduce using rule 99 (varCte -> STRING pointSTRING .)
    GREATERTHANEQ   reduce using rule 99 (varCte -> STRING pointSTRING .)
    LESSTHAN        reduce using rule 99 (varCte -> STRING pointSTRING .)
    LESSTHANEQ      reduce using rule 99 (varCte -> STRING pointSTRING .)
    CPAREN          reduce using rule 99 (varCte -> STRING pointSTRING .)
    EOF             reduce using rule 99 (varCte -> STRING pointSTRING .)
    CSQUAREBR       reduce using rule 99 (varCte -> STRING pointSTRING .)


state 156

    (100) varCte -> TRUE pointBOOL .

    MULTIPLY        reduce using rule 100 (varCte -> TRUE pointBOOL .)
    DIVIDE          reduce using rule 100 (varCte -> TRUE pointBOOL .)
    PLUS            reduce using rule 100 (varCte -> TRUE pointBOOL .)
    MINUS           reduce using rule 100 (varCte -> TRUE pointBOOL .)
    EQUAL           reduce using rule 100 (varCte -> TRUE pointBOOL .)
    DIFFERENT       reduce using rule 100 (varCte -> TRUE pointBOOL .)
    GREATERTHAN     reduce using rule 100 (varCte -> TRUE pointBOOL .)
    GREATERTHANEQ   reduce using rule 100 (varCte -> TRUE pointBOOL .)
    LESSTHAN        reduce using rule 100 (varCte -> TRUE pointBOOL .)
    LESSTHANEQ      reduce using rule 100 (varCte -> TRUE pointBOOL .)
    CPAREN          reduce using rule 100 (varCte -> TRUE pointBOOL .)
    EOF             reduce using rule 100 (varCte -> TRUE pointBOOL .)
    CSQUAREBR       reduce using rule 100 (varCte -> TRUE pointBOOL .)


state 157

    (101) varCte -> FALSE pointBOOL .

    MULTIPLY        reduce using rule 101 (varCte -> FALSE pointBOOL .)
    DIVIDE          reduce using rule 101 (varCte -> FALSE pointBOOL .)
    PLUS            reduce using rule 101 (varCte -> FALSE pointBOOL .)
    MINUS           reduce using rule 101 (varCte -> FALSE pointBOOL .)
    EQUAL           reduce using rule 101 (varCte -> FALSE pointBOOL .)
    DIFFERENT       reduce using rule 101 (varCte -> FALSE pointBOOL .)
    GREATERTHAN     reduce using rule 101 (varCte -> FALSE pointBOOL .)
    GREATERTHANEQ   reduce using rule 101 (varCte -> FALSE pointBOOL .)
    LESSTHAN        reduce using rule 101 (varCte -> FALSE pointBOOL .)
    LESSTHANEQ      reduce using rule 101 (varCte -> FALSE pointBOOL .)
    CPAREN          reduce using rule 101 (varCte -> FALSE pointBOOL .)
    EOF             reduce using rule 101 (varCte -> FALSE pointBOOL .)
    CSQUAREBR       reduce using rule 101 (varCte -> FALSE pointBOOL .)


state 158

    (107) whileCycle -> WHILE pointWhile1 OPAREN expRelational . CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3

    CPAREN          shift and go to state 185


state 159

    (111) ifCond -> IF OPAREN expRelational CPAREN . pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> IF OPAREN expRelational CPAREN . pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (113) pointIfCond1 -> .

    OBRACKET        reduce using rule 113 (pointIfCond1 -> .)

    pointIfCond1                   shift and go to state 186

state 160

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 187


state 161

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 188


state 162

    (19) param -> paramType ID pointParam COMMA . param
    (18) param -> . paramType ID pointParam
    (19) param -> . paramType ID pointParam COMMA param
    (20) paramType -> . INT
    (21) paramType -> . STRING
    (22) paramType -> . DEC
    (23) paramType -> . BOOL

    INT             shift and go to state 65
    STRING          shift and go to state 66
    DEC             shift and go to state 67
    BOOL            shift and go to state 68

    paramType                      shift and go to state 64
    param                          shift and go to state 189

state 163

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body . RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    RETURN          shift and go to state 190


state 164

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body . RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    RETURN          shift and go to state 191


state 165

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass . fxDef pointScopeClass2 CBRACKET classDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (119) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    CBRACKET        reduce using rule 119 (epsilon -> .)

    fxDef                          shift and go to state 192
    epsilon                        shift and go to state 12
    fxType                         shift and go to state 13

state 166

    (50) var -> varsType COMMA var .

    EOF             reduce using rule 50 (var -> varsType COMMA var .)


state 167

    (54) arrDef -> ID OSQUAREBR varCte . CSQUAREBR

    CSQUAREBR       shift and go to state 193


state 168

    (55) matrixDef -> arrDef OSQUAREBR varCte . CSQUAREBR

    CSQUAREBR       shift and go to state 194


state 169

    (61) returnCall -> ID pointEra . OPAREN paramCall pointGoSub CPAREN
    (62) returnCall -> ID pointEra . OPAREN epsilon pointGoSub CPAREN

    OPAREN          shift and go to state 195


state 170

    (58) expAssignment -> expRelational EOF .

    VAR             reduce using rule 58 (expAssignment -> expRelational EOF .)
    ID              reduce using rule 58 (expAssignment -> expRelational EOF .)
    INPUT           reduce using rule 58 (expAssignment -> expRelational EOF .)
    OUTPUT          reduce using rule 58 (expAssignment -> expRelational EOF .)
    WHILE           reduce using rule 58 (expAssignment -> expRelational EOF .)
    IF              reduce using rule 58 (expAssignment -> expRelational EOF .)
    CBRACKET        reduce using rule 58 (expAssignment -> expRelational EOF .)
    RETURN          reduce using rule 58 (expAssignment -> expRelational EOF .)


state 171

    (59) expAssignment -> returnCall EOF .

    VAR             reduce using rule 59 (expAssignment -> returnCall EOF .)
    ID              reduce using rule 59 (expAssignment -> returnCall EOF .)
    INPUT           reduce using rule 59 (expAssignment -> returnCall EOF .)
    OUTPUT          reduce using rule 59 (expAssignment -> returnCall EOF .)
    WHILE           reduce using rule 59 (expAssignment -> returnCall EOF .)
    IF              reduce using rule 59 (expAssignment -> returnCall EOF .)
    CBRACKET        reduce using rule 59 (expAssignment -> returnCall EOF .)
    RETURN          reduce using rule 59 (expAssignment -> returnCall EOF .)


state 172

    (25) paramCall -> ID pointParamCall . pointParamNum
    (26) paramCall -> ID pointParamCall . COMMA paramCall
    (27) pointParamNum -> .

    COMMA           shift and go to state 197
    CPAREN          reduce using rule 27 (pointParamNum -> .)

    pointParamNum                  shift and go to state 196

state 173

    (29) voidCall -> ID pointEra OPAREN paramCall pointGoSub . CPAREN EOF

    CPAREN          shift and go to state 198


state 174

    (30) voidCall -> ID pointEra OPAREN epsilon pointGoSub . CPAREN EOF

    CPAREN          shift and go to state 199


state 175

    (94) classCall -> ID MONEY ID OPAREN paramCall . CPAREN EOF

    CPAREN          shift and go to state 200


state 176

    (95) classCall -> ID MONEY ID OPAREN epsilon . CPAREN EOF

    CPAREN          shift and go to state 201


state 177

    (116) input -> INPUT OPAREN ID CPAREN EOF .

    VAR             reduce using rule 116 (input -> INPUT OPAREN ID CPAREN EOF .)
    ID              reduce using rule 116 (input -> INPUT OPAREN ID CPAREN EOF .)
    INPUT           reduce using rule 116 (input -> INPUT OPAREN ID CPAREN EOF .)
    OUTPUT          reduce using rule 116 (input -> INPUT OPAREN ID CPAREN EOF .)
    WHILE           reduce using rule 116 (input -> INPUT OPAREN ID CPAREN EOF .)
    IF              reduce using rule 116 (input -> INPUT OPAREN ID CPAREN EOF .)
    CBRACKET        reduce using rule 116 (input -> INPUT OPAREN ID CPAREN EOF .)
    RETURN          reduce using rule 116 (input -> INPUT OPAREN ID CPAREN EOF .)


state 178

    (82) expParen -> OPAREN pointFakeBackground expRelational . CPAREN pointRemoveFakeBackground

    CPAREN          shift and go to state 202


state 179

    (117) output -> OUTPUT OPAREN expRelational CPAREN EOF .

    VAR             reduce using rule 117 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    ID              reduce using rule 117 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    INPUT           reduce using rule 117 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    OUTPUT          reduce using rule 117 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    WHILE           reduce using rule 117 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    IF              reduce using rule 117 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    CBRACKET        reduce using rule 117 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    RETURN          reduce using rule 117 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)


state 180

    (64) expRelational -> plusMinus opRelational expRelational . pointCheckOpRel
    (65) pointCheckOpRel -> .

    CPAREN          reduce using rule 65 (pointCheckOpRel -> .)
    EOF             reduce using rule 65 (pointCheckOpRel -> .)

    pointCheckOpRel                shift and go to state 203

state 181

    (73) plusMinus -> multDiv pointCheckPlusMinus PLUS . pointPushPlusMinus plusMinus
    (76) pointPushPlusMinus -> .

    OPAREN          reduce using rule 76 (pointPushPlusMinus -> .)
    INT             reduce using rule 76 (pointPushPlusMinus -> .)
    DEC             reduce using rule 76 (pointPushPlusMinus -> .)
    STRING          reduce using rule 76 (pointPushPlusMinus -> .)
    TRUE            reduce using rule 76 (pointPushPlusMinus -> .)
    FALSE           reduce using rule 76 (pointPushPlusMinus -> .)
    ID              reduce using rule 76 (pointPushPlusMinus -> .)

    pointPushPlusMinus             shift and go to state 204

state 182

    (74) plusMinus -> multDiv pointCheckPlusMinus MINUS . pointPushPlusMinus plusMinus
    (76) pointPushPlusMinus -> .

    OPAREN          reduce using rule 76 (pointPushPlusMinus -> .)
    INT             reduce using rule 76 (pointPushPlusMinus -> .)
    DEC             reduce using rule 76 (pointPushPlusMinus -> .)
    STRING          reduce using rule 76 (pointPushPlusMinus -> .)
    TRUE            reduce using rule 76 (pointPushPlusMinus -> .)
    FALSE           reduce using rule 76 (pointPushPlusMinus -> .)
    ID              reduce using rule 76 (pointPushPlusMinus -> .)

    pointPushPlusMinus             shift and go to state 205

state 183

    (78) multDiv -> expParen pointCheckMultDiv MULTIPLY . pointPushMultDiv multDiv
    (81) pointPushMultDiv -> .

    OPAREN          reduce using rule 81 (pointPushMultDiv -> .)
    INT             reduce using rule 81 (pointPushMultDiv -> .)
    DEC             reduce using rule 81 (pointPushMultDiv -> .)
    STRING          reduce using rule 81 (pointPushMultDiv -> .)
    TRUE            reduce using rule 81 (pointPushMultDiv -> .)
    FALSE           reduce using rule 81 (pointPushMultDiv -> .)
    ID              reduce using rule 81 (pointPushMultDiv -> .)

    pointPushMultDiv               shift and go to state 206

state 184

    (79) multDiv -> expParen pointCheckMultDiv DIVIDE . pointPushMultDiv multDiv
    (81) pointPushMultDiv -> .

    OPAREN          reduce using rule 81 (pointPushMultDiv -> .)
    INT             reduce using rule 81 (pointPushMultDiv -> .)
    DEC             reduce using rule 81 (pointPushMultDiv -> .)
    STRING          reduce using rule 81 (pointPushMultDiv -> .)
    TRUE            reduce using rule 81 (pointPushMultDiv -> .)
    FALSE           reduce using rule 81 (pointPushMultDiv -> .)
    ID              reduce using rule 81 (pointPushMultDiv -> .)

    pointPushMultDiv               shift and go to state 207

state 185

    (107) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN . pointWhile2 OBRACKET body CBRACKET pointWhile3
    (109) pointWhile2 -> .

    OBRACKET        reduce using rule 109 (pointWhile2 -> .)

    pointWhile2                    shift and go to state 208

state 186

    (111) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 . OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 . OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    OBRACKET        shift and go to state 209


state 187

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET . pointEndFunc fxDef
    (17) pointEndFunc -> .

    VOID            reduce using rule 17 (pointEndFunc -> .)
    INT             reduce using rule 17 (pointEndFunc -> .)
    STRING          reduce using rule 17 (pointEndFunc -> .)
    DEC             reduce using rule 17 (pointEndFunc -> .)
    BOOL            reduce using rule 17 (pointEndFunc -> .)
    MAIN            reduce using rule 17 (pointEndFunc -> .)
    CBRACKET        reduce using rule 17 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 210

state 188

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET . pointEndFunc fxDef
    (17) pointEndFunc -> .

    VOID            reduce using rule 17 (pointEndFunc -> .)
    INT             reduce using rule 17 (pointEndFunc -> .)
    STRING          reduce using rule 17 (pointEndFunc -> .)
    DEC             reduce using rule 17 (pointEndFunc -> .)
    BOOL            reduce using rule 17 (pointEndFunc -> .)
    MAIN            reduce using rule 17 (pointEndFunc -> .)
    CBRACKET        reduce using rule 17 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 211

state 189

    (19) param -> paramType ID pointParam COMMA param .

    CPAREN          reduce using rule 19 (param -> paramType ID pointParam COMMA param .)


state 190

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN . ID pointReturn EOF CBRACKET pointEndFunc fxDef

    ID              shift and go to state 212


state 191

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN . ID pointReturn EOF CBRACKET pointEndFunc fxDef

    ID              shift and go to state 213


state 192

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef . pointScopeClass2 CBRACKET classDef
    (91) pointScopeClass2 -> .

    CBRACKET        reduce using rule 91 (pointScopeClass2 -> .)

    pointScopeClass2               shift and go to state 214

state 193

    (54) arrDef -> ID OSQUAREBR varCte CSQUAREBR .

    OSQUAREBR       reduce using rule 54 (arrDef -> ID OSQUAREBR varCte CSQUAREBR .)
    COMMA           reduce using rule 54 (arrDef -> ID OSQUAREBR varCte CSQUAREBR .)
    EOF             reduce using rule 54 (arrDef -> ID OSQUAREBR varCte CSQUAREBR .)


state 194

    (55) matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR .

    COMMA           reduce using rule 55 (matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR .)
    EOF             reduce using rule 55 (matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR .)


state 195

    (61) returnCall -> ID pointEra OPAREN . paramCall pointGoSub CPAREN
    (62) returnCall -> ID pointEra OPAREN . epsilon pointGoSub CPAREN
    (25) paramCall -> . ID pointParamCall pointParamNum
    (26) paramCall -> . ID pointParamCall COMMA paramCall
    (119) epsilon -> .

    ID              shift and go to state 137
    CPAREN          reduce using rule 119 (epsilon -> .)

    paramCall                      shift and go to state 215
    epsilon                        shift and go to state 216

state 196

    (25) paramCall -> ID pointParamCall pointParamNum .

    CPAREN          reduce using rule 25 (paramCall -> ID pointParamCall pointParamNum .)


state 197

    (26) paramCall -> ID pointParamCall COMMA . paramCall
    (25) paramCall -> . ID pointParamCall pointParamNum
    (26) paramCall -> . ID pointParamCall COMMA paramCall

    ID              shift and go to state 137

    paramCall                      shift and go to state 217

state 198

    (29) voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN . EOF

    EOF             shift and go to state 218


state 199

    (30) voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN . EOF

    EOF             shift and go to state 219


state 200

    (94) classCall -> ID MONEY ID OPAREN paramCall CPAREN . EOF

    EOF             shift and go to state 220


state 201

    (95) classCall -> ID MONEY ID OPAREN epsilon CPAREN . EOF

    EOF             shift and go to state 221


state 202

    (82) expParen -> OPAREN pointFakeBackground expRelational CPAREN . pointRemoveFakeBackground
    (85) pointRemoveFakeBackground -> .

    MULTIPLY        reduce using rule 85 (pointRemoveFakeBackground -> .)
    DIVIDE          reduce using rule 85 (pointRemoveFakeBackground -> .)
    PLUS            reduce using rule 85 (pointRemoveFakeBackground -> .)
    MINUS           reduce using rule 85 (pointRemoveFakeBackground -> .)
    EQUAL           reduce using rule 85 (pointRemoveFakeBackground -> .)
    DIFFERENT       reduce using rule 85 (pointRemoveFakeBackground -> .)
    GREATERTHAN     reduce using rule 85 (pointRemoveFakeBackground -> .)
    GREATERTHANEQ   reduce using rule 85 (pointRemoveFakeBackground -> .)
    LESSTHAN        reduce using rule 85 (pointRemoveFakeBackground -> .)
    LESSTHANEQ      reduce using rule 85 (pointRemoveFakeBackground -> .)
    CPAREN          reduce using rule 85 (pointRemoveFakeBackground -> .)
    EOF             reduce using rule 85 (pointRemoveFakeBackground -> .)

    pointRemoveFakeBackground      shift and go to state 222

state 203

    (64) expRelational -> plusMinus opRelational expRelational pointCheckOpRel .

    CPAREN          reduce using rule 64 (expRelational -> plusMinus opRelational expRelational pointCheckOpRel .)
    EOF             reduce using rule 64 (expRelational -> plusMinus opRelational expRelational pointCheckOpRel .)


state 204

    (73) plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus . plusMinus
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . TRUE pointBOOL
    (101) varCte -> . FALSE pointBOOL
    (102) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    multDiv                        shift and go to state 110
    plusMinus                      shift and go to state 223
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 205

    (74) plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus . plusMinus
    (72) plusMinus -> . multDiv pointCheckPlusMinus
    (73) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . TRUE pointBOOL
    (101) varCte -> . FALSE pointBOOL
    (102) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    multDiv                        shift and go to state 110
    plusMinus                      shift and go to state 224
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 206

    (78) multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv . multDiv
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . TRUE pointBOOL
    (101) varCte -> . FALSE pointBOOL
    (102) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    expParen                       shift and go to state 111
    multDiv                        shift and go to state 225
    varCte                         shift and go to state 112

state 207

    (79) multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv . multDiv
    (77) multDiv -> . expParen pointCheckMultDiv
    (78) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (79) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (83) expParen -> . varCte
    (97) varCte -> . INT pointINT
    (98) varCte -> . DEC pointDEC
    (99) varCte -> . STRING pointSTRING
    (100) varCte -> . TRUE pointBOOL
    (101) varCte -> . FALSE pointBOOL
    (102) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    expParen                       shift and go to state 111
    multDiv                        shift and go to state 226
    varCte                         shift and go to state 112

state 208

    (107) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 . OBRACKET body CBRACKET pointWhile3

    OBRACKET        shift and go to state 227


state 209

    (111) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET . body CBRACKET pointIfCond2
    (112) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET . body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (119) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (116) input -> . INPUT OPAREN ID CPAREN EOF
    (117) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (107) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (111) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 119 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 228
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 210

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (119) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 119 (epsilon -> .)
    CBRACKET        reduce using rule 119 (epsilon -> .)

    fxDef                          shift and go to state 229
    epsilon                        shift and go to state 12
    fxType                         shift and go to state 13

state 211

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (119) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 119 (epsilon -> .)
    CBRACKET        reduce using rule 119 (epsilon -> .)

    epsilon                        shift and go to state 12
    fxDef                          shift and go to state 230
    fxType                         shift and go to state 13

state 212

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID . pointReturn EOF CBRACKET pointEndFunc fxDef
    (16) pointReturn -> .

    EOF             reduce using rule 16 (pointReturn -> .)

    pointReturn                    shift and go to state 231

state 213

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID . pointReturn EOF CBRACKET pointEndFunc fxDef
    (16) pointReturn -> .

    EOF             reduce using rule 16 (pointReturn -> .)

    pointReturn                    shift and go to state 232

state 214

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 . CBRACKET classDef

    CBRACKET        shift and go to state 233


state 215

    (61) returnCall -> ID pointEra OPAREN paramCall . pointGoSub CPAREN
    (32) pointGoSub -> .

    CPAREN          reduce using rule 32 (pointGoSub -> .)

    pointGoSub                     shift and go to state 234

state 216

    (62) returnCall -> ID pointEra OPAREN epsilon . pointGoSub CPAREN
    (32) pointGoSub -> .

    CPAREN          reduce using rule 32 (pointGoSub -> .)

    pointGoSub                     shift and go to state 235

state 217

    (26) paramCall -> ID pointParamCall COMMA paramCall .

    CPAREN          reduce using rule 26 (paramCall -> ID pointParamCall COMMA paramCall .)


state 218

    (29) voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .

    VAR             reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    ID              reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    INPUT           reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    OUTPUT          reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    WHILE           reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    IF              reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    CBRACKET        reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    RETURN          reduce using rule 29 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)


state 219

    (30) voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .

    VAR             reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    ID              reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    INPUT           reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    OUTPUT          reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    WHILE           reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    IF              reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    CBRACKET        reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)
    RETURN          reduce using rule 30 (voidCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN EOF .)


state 220

    (94) classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .

    VAR             reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    ID              reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    INPUT           reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    OUTPUT          reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    WHILE           reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    IF              reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    CBRACKET        reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    RETURN          reduce using rule 94 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)


state 221

    (95) classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .

    VAR             reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    ID              reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    INPUT           reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    OUTPUT          reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    WHILE           reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    IF              reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    CBRACKET        reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    RETURN          reduce using rule 95 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)


state 222

    (82) expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .

    MULTIPLY        reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    DIVIDE          reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    PLUS            reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    MINUS           reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    EQUAL           reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    DIFFERENT       reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    GREATERTHAN     reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    GREATERTHANEQ   reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    LESSTHAN        reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    LESSTHANEQ      reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    CPAREN          reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    EOF             reduce using rule 82 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)


state 223

    (73) plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .

    EQUAL           reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    DIFFERENT       reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    GREATERTHAN     reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    GREATERTHANEQ   reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    LESSTHAN        reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    LESSTHANEQ      reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    CPAREN          reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    EOF             reduce using rule 73 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)


state 224

    (74) plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .

    EQUAL           reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    DIFFERENT       reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    GREATERTHAN     reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    GREATERTHANEQ   reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    LESSTHAN        reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    LESSTHANEQ      reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    CPAREN          reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    EOF             reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)


state 225

    (78) multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .

    PLUS            reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    MINUS           reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    EQUAL           reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    DIFFERENT       reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    GREATERTHAN     reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    GREATERTHANEQ   reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    LESSTHAN        reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    LESSTHANEQ      reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    CPAREN          reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    EOF             reduce using rule 78 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)


state 226

    (79) multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .

    PLUS            reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    MINUS           reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    EQUAL           reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    DIFFERENT       reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    GREATERTHAN     reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    GREATERTHANEQ   reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    LESSTHAN        reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    LESSTHANEQ      reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    CPAREN          reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    EOF             reduce using rule 79 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)


state 227

    (107) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET . body CBRACKET pointWhile3
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (119) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (116) input -> . INPUT OPAREN ID CPAREN EOF
    (117) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (107) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (111) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 119 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 236
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 228

    (111) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body . CBRACKET pointIfCond2
    (112) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body . CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    CBRACKET        shift and go to state 237


state 229

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 5 (fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 5 (fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef .)


state 230

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 6 (fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 6 (fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef .)


state 231

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn . EOF CBRACKET pointEndFunc fxDef

    EOF             shift and go to state 238


state 232

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn . EOF CBRACKET pointEndFunc fxDef

    EOF             shift and go to state 239


state 233

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET . classDef
    (86) classDef -> . CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (87) classDef -> . epsilon
    (119) epsilon -> .

    CLASS           shift and go to state 8
    VOID            reduce using rule 119 (epsilon -> .)
    INT             reduce using rule 119 (epsilon -> .)
    STRING          reduce using rule 119 (epsilon -> .)
    DEC             reduce using rule 119 (epsilon -> .)
    BOOL            reduce using rule 119 (epsilon -> .)
    MAIN            reduce using rule 119 (epsilon -> .)

    classDef                       shift and go to state 240
    epsilon                        shift and go to state 9

state 234

    (61) returnCall -> ID pointEra OPAREN paramCall pointGoSub . CPAREN

    CPAREN          shift and go to state 241


state 235

    (62) returnCall -> ID pointEra OPAREN epsilon pointGoSub . CPAREN

    CPAREN          shift and go to state 242


state 236

    (107) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body . CBRACKET pointWhile3

    CBRACKET        shift and go to state 243


state 237

    (111) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET . pointIfCond2
    (112) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET . ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (114) pointIfCond2 -> .

    ELSE            shift and go to state 245
    VAR             reduce using rule 114 (pointIfCond2 -> .)
    ID              reduce using rule 114 (pointIfCond2 -> .)
    INPUT           reduce using rule 114 (pointIfCond2 -> .)
    OUTPUT          reduce using rule 114 (pointIfCond2 -> .)
    WHILE           reduce using rule 114 (pointIfCond2 -> .)
    IF              reduce using rule 114 (pointIfCond2 -> .)
    CBRACKET        reduce using rule 114 (pointIfCond2 -> .)
    RETURN          reduce using rule 114 (pointIfCond2 -> .)

    pointIfCond2                   shift and go to state 244

state 238

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 246


state 239

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 247


state 240

    (86) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .

    VOID            reduce using rule 86 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    INT             reduce using rule 86 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    STRING          reduce using rule 86 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    DEC             reduce using rule 86 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    BOOL            reduce using rule 86 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    MAIN            reduce using rule 86 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)


state 241

    (61) returnCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN .

    EOF             reduce using rule 61 (returnCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN .)


state 242

    (62) returnCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN .

    EOF             reduce using rule 62 (returnCall -> ID pointEra OPAREN epsilon pointGoSub CPAREN .)


state 243

    (107) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET . pointWhile3
    (110) pointWhile3 -> .

    VAR             reduce using rule 110 (pointWhile3 -> .)
    ID              reduce using rule 110 (pointWhile3 -> .)
    INPUT           reduce using rule 110 (pointWhile3 -> .)
    OUTPUT          reduce using rule 110 (pointWhile3 -> .)
    WHILE           reduce using rule 110 (pointWhile3 -> .)
    IF              reduce using rule 110 (pointWhile3 -> .)
    CBRACKET        reduce using rule 110 (pointWhile3 -> .)
    RETURN          reduce using rule 110 (pointWhile3 -> .)

    pointWhile3                    shift and go to state 248

state 244

    (111) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .

    VAR             reduce using rule 111 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    ID              reduce using rule 111 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    INPUT           reduce using rule 111 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    OUTPUT          reduce using rule 111 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    WHILE           reduce using rule 111 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    IF              reduce using rule 111 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    CBRACKET        reduce using rule 111 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    RETURN          reduce using rule 111 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)


state 245

    (112) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE . pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (115) pointIfCond3 -> .

    OBRACKET        reduce using rule 115 (pointIfCond3 -> .)

    pointIfCond3                   shift and go to state 249

state 246

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET . pointEndFunc fxDef
    (17) pointEndFunc -> .

    VOID            reduce using rule 17 (pointEndFunc -> .)
    INT             reduce using rule 17 (pointEndFunc -> .)
    STRING          reduce using rule 17 (pointEndFunc -> .)
    DEC             reduce using rule 17 (pointEndFunc -> .)
    BOOL            reduce using rule 17 (pointEndFunc -> .)
    MAIN            reduce using rule 17 (pointEndFunc -> .)
    CBRACKET        reduce using rule 17 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 250

state 247

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET . pointEndFunc fxDef
    (17) pointEndFunc -> .

    VOID            reduce using rule 17 (pointEndFunc -> .)
    INT             reduce using rule 17 (pointEndFunc -> .)
    STRING          reduce using rule 17 (pointEndFunc -> .)
    DEC             reduce using rule 17 (pointEndFunc -> .)
    BOOL            reduce using rule 17 (pointEndFunc -> .)
    MAIN            reduce using rule 17 (pointEndFunc -> .)
    CBRACKET        reduce using rule 17 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 251

state 248

    (107) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .

    VAR             reduce using rule 107 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    ID              reduce using rule 107 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    INPUT           reduce using rule 107 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    OUTPUT          reduce using rule 107 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    WHILE           reduce using rule 107 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    IF              reduce using rule 107 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    CBRACKET        reduce using rule 107 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    RETURN          reduce using rule 107 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)


state 249

    (112) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 . OBRACKET body CBRACKET pointIfCond2

    OBRACKET        shift and go to state 252


state 250

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (119) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 119 (epsilon -> .)
    CBRACKET        reduce using rule 119 (epsilon -> .)

    fxType                         shift and go to state 13
    fxDef                          shift and go to state 253
    epsilon                        shift and go to state 12

state 251

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (119) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 119 (epsilon -> .)
    CBRACKET        reduce using rule 119 (epsilon -> .)

    fxType                         shift and go to state 13
    epsilon                        shift and go to state 12
    fxDef                          shift and go to state 254

state 252

    (112) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET . body CBRACKET pointIfCond2
    (33) body -> . varsDef body
    (34) body -> . statements body
    (35) body -> . epsilon
    (43) varsDef -> . VAR objType var EOF
    (44) varsDef -> . VAR varSimpleType var EOF
    (36) statements -> . assignmentDef
    (37) statements -> . input
    (38) statements -> . output
    (39) statements -> . voidCall
    (40) statements -> . whileCycle
    (41) statements -> . ifCond
    (42) statements -> . classCall
    (119) epsilon -> .
    (56) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (116) input -> . INPUT OPAREN ID CPAREN EOF
    (117) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (29) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN epsilon pointGoSub CPAREN EOF
    (107) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (111) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (112) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (94) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (95) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 119 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 255
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 253

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 7 (fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 7 (fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)


state 254

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 8 (fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 8 (fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)


state 255

    (112) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body . CBRACKET pointIfCond2

    CBRACKET        shift and go to state 256


state 256

    (112) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET . pointIfCond2
    (114) pointIfCond2 -> .

    VAR             reduce using rule 114 (pointIfCond2 -> .)
    ID              reduce using rule 114 (pointIfCond2 -> .)
    INPUT           reduce using rule 114 (pointIfCond2 -> .)
    OUTPUT          reduce using rule 114 (pointIfCond2 -> .)
    WHILE           reduce using rule 114 (pointIfCond2 -> .)
    IF              reduce using rule 114 (pointIfCond2 -> .)
    CBRACKET        reduce using rule 114 (pointIfCond2 -> .)
    RETURN          reduce using rule 114 (pointIfCond2 -> .)

    pointIfCond2                   shift and go to state 257

state 257

    (112) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .

    VAR             reduce using rule 112 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    ID              reduce using rule 112 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    INPUT           reduce using rule 112 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    OUTPUT          reduce using rule 112 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    WHILE           reduce using rule 112 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    IF              reduce using rule 112 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    CBRACKET        reduce using rule 112 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    RETURN          reduce using rule 112 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)

