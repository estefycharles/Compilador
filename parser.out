Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> begin
Rule 1     begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end
Rule 2     pointCreateMainCuac -> <empty>
Rule 3     pointMain -> <empty>
Rule 4     main -> MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET
Rule 5     fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
Rule 6     fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
Rule 7     fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
Rule 8     fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
Rule 9     fxDef -> epsilon
Rule 10    fxType -> INT
Rule 11    fxType -> STRING
Rule 12    fxType -> DEC
Rule 13    fxType -> BOOL
Rule 14    pointFx -> <empty>
Rule 15    pointFxId -> <empty>
Rule 16    pointReturn -> <empty>
Rule 17    pointParamCount -> <empty>
Rule 18    pointEndFunc -> <empty>
Rule 19    param -> paramType ID pointParam
Rule 20    param -> paramType ID pointParam COMMA param
Rule 21    paramType -> INT
Rule 22    paramType -> STRING
Rule 23    paramType -> DEC
Rule 24    paramType -> BOOL
Rule 25    pointParam -> <empty>
Rule 26    paramCall -> ID pointParamCall pointParamNum
Rule 27    paramCall -> ID pointParamCall COMMA paramCall
Rule 28    pointParamNum -> <empty>
Rule 29    pointParamCall -> <empty>
Rule 30    voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
Rule 31    voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
Rule 32    pointEra -> <empty>
Rule 33    pointGoSub -> <empty>
Rule 34    body -> varsDef body
Rule 35    body -> statements body
Rule 36    body -> epsilon
Rule 37    statements -> assignmentDef
Rule 38    statements -> input
Rule 39    statements -> output
Rule 40    statements -> voidCall
Rule 41    statements -> whileCycle
Rule 42    statements -> ifCond
Rule 43    statements -> classCall
Rule 44    varsDef -> VAR objType var EOF
Rule 45    varsDef -> VAR varSimpleType var EOF
Rule 46    varSimpleType -> INT
Rule 47    varSimpleType -> STRING
Rule 48    varSimpleType -> DEC
Rule 49    varSimpleType -> BOOL
Rule 50    var -> varsType
Rule 51    var -> varsType COMMA var
Rule 52    varsType -> ID pointID
Rule 53    varsType -> arrDef
Rule 54    varsType -> matrixDef
Rule 55    pointID -> <empty>
Rule 56    arrDef -> ID OSQUAREBR INT COLON INT CSQUAREBR
Rule 57    arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR
Rule 58    pointCheckTypeInt -> <empty>
Rule 59    matrixDef -> arrDef OSQUAREBR varCte COLON varCte CSQUAREBR
Rule 60    assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment
Rule 61    assignmentDef -> arr ASSIGNMENT pointPushAssignment expAssignment
Rule 62    pointPushAssignment -> <empty>
Rule 63    expAssignment -> expRelational EOF
Rule 64    expAssignment -> returnCall EOF
Rule 65    expAssignment -> classCall
Rule 66    returnCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN
Rule 67    returnCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN
Rule 68    pointParamVacio -> <empty>
Rule 69    expRelational -> plusMinus
Rule 70    expRelational -> plusMinus opRelational expRelational pointCheckOpRel
Rule 71    pointCheckOpRel -> <empty>
Rule 72    opRelational -> EQUAL
Rule 73    opRelational -> DIFFERENT
Rule 74    opRelational -> GREATERTHAN
Rule 75    opRelational -> GREATERTHANEQ
Rule 76    opRelational -> LESSTHAN
Rule 77    opRelational -> LESSTHANEQ
Rule 78    plusMinus -> multDiv pointCheckPlusMinus
Rule 79    plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
Rule 80    plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
Rule 81    pointCheckPlusMinus -> <empty>
Rule 82    pointPushPlusMinus -> <empty>
Rule 83    multDiv -> expParen pointCheckMultDiv
Rule 84    multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
Rule 85    multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
Rule 86    pointCheckMultDiv -> <empty>
Rule 87    pointPushMultDiv -> <empty>
Rule 88    expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
Rule 89    expParen -> varCte
Rule 90    pointFakeBackground -> <empty>
Rule 91    pointRemoveFakeBackground -> <empty>
Rule 92    classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
Rule 93    classDef -> epsilon
Rule 94    pointAtt -> varsDef
Rule 95    pointAtt -> varsDef pointAtt
Rule 96    pointScopeClass -> <empty>
Rule 97    pointScopeClass2 -> <empty>
Rule 98    pointClassName -> <empty>
Rule 99    pointClass -> <empty>
Rule 100   classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF
Rule 101   classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF
Rule 102   objType -> ID
Rule 103   varCte -> INT pointINT
Rule 104   varCte -> DEC pointDEC
Rule 105   varCte -> STRING pointSTRING
Rule 106   varCte -> TRUE pointBOOL
Rule 107   varCte -> FALSE pointBOOL
Rule 108   varCte -> ID
Rule 109   varCte -> arr
Rule 110   pointINT -> <empty>
Rule 111   pointDEC -> <empty>
Rule 112   pointSTRING -> <empty>
Rule 113   pointBOOL -> <empty>
Rule 114   whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
Rule 115   pointWhile1 -> <empty>
Rule 116   pointWhile2 -> <empty>
Rule 117   pointWhile3 -> <empty>
Rule 118   ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
Rule 119   ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
Rule 120   pointIfCond1 -> <empty>
Rule 121   pointIfCond2 -> <empty>
Rule 122   pointIfCond3 -> <empty>
Rule 123   input -> INPUT OPAREN ID CPAREN EOF
Rule 124   output -> OUTPUT OPAREN expRelational CPAREN EOF
Rule 125   end -> END OPAREN ID CPAREN
Rule 126   epsilon -> <empty>

Terminals, with rules where they appear

ASSIGNMENT           : 60 61
ATTRIBUTES           : 92
BEGIN                : 1
BOOL                 : 13 24 49
CBRACKET             : 4 5 6 7 8 92 114 118 119 119
CLASS                : 92
COLON                : 56 59 92 92
COMMA                : 20 27 51
CPAREN               : 1 4 5 6 7 8 30 31 66 67 88 100 101 114 118 119 123 124 125
CSQUAREBR            : 56 57 59
DEC                  : 12 23 48 104
DIFFERENT            : 73
DIVIDE               : 85
ELSE                 : 119
END                  : 125
EOF                  : 7 8 30 31 44 45 63 64 100 101 123 124
EQUAL                : 72
FALSE                : 107
FX                   : 5 6 7 8
GREATERTHAN          : 74
GREATERTHANEQ        : 75
ID                   : 1 5 6 7 7 8 8 19 20 26 27 30 31 52 56 57 60 66 67 92 100 100 101 101 102 108 123 125
IF                   : 118 119
INPUT                : 123
INT                  : 10 21 46 56 56 103
LESSTHAN             : 76
LESSTHANEQ           : 77
MAIN                 : 4
METHODS              : 92
MINUS                : 80
MONEY                : 100 101
MULTIPLY             : 84
OBRACKET             : 4 5 6 7 8 92 114 118 119 119
OPAREN               : 1 4 5 6 7 8 30 31 66 67 88 100 101 114 118 119 123 124 125
OSQUAREBR            : 56 57 59
OUTPUT               : 124
PLUS                 : 79
RETURN               : 7 8
STRING               : 11 22 47 105
TRUE                 : 106
VAR                  : 44 45
VOID                 : 5 6
WHILE                : 114
error                : 

Nonterminals, with rules where they appear

arr                  : 61 109
arrDef               : 53 59
assignmentDef        : 37
begin                : 0
body                 : 4 5 6 7 8 34 35 114 118 119 119
classCall            : 43 65
classDef             : 1 92
end                  : 1
epsilon              : 6 8 9 31 36 67 93 101
expAssignment        : 60 61
expParen             : 83 84 85
expRelational        : 63 70 88 114 118 119 124
fxDef                : 1 5 6 7 8 92
fxType               : 7 8
ifCond               : 42
input                : 38
main                 : 1
matrixDef            : 54
multDiv              : 78 79 80 84 85
objType              : 44
opRelational         : 70
output               : 39
param                : 5 7 20
paramCall            : 27 30 66 100
paramType            : 19 20
plusMinus            : 69 70 79 80
pointAtt             : 92 95
pointBOOL            : 106 107
pointCheckMultDiv    : 83 84 85
pointCheckOpRel      : 70
pointCheckPlusMinus  : 78 79 80
pointCheckTypeInt    : 57
pointClass           : 92
pointClassName       : 92
pointCreateMainCuac  : 1
pointDEC             : 104
pointEndFunc         : 5 6 7 8
pointEra             : 30 31 66 67
pointFakeBackground  : 88
pointFx              : 5 6 7 8
pointFxId            : 5 6 7 8
pointGoSub           : 30 31 66 67
pointID              : 52
pointINT             : 103
pointIfCond1         : 118 119
pointIfCond2         : 118 119
pointIfCond3         : 119
pointMain            : 4
pointParam           : 19 20
pointParamCall       : 26 27
pointParamCount      : 5 6 7 8
pointParamNum        : 26
pointParamVacio      : 31 67
pointPushAssignment  : 60 61
pointPushMultDiv     : 84 85
pointPushPlusMinus   : 79 80
pointRemoveFakeBackground : 88
pointReturn          : 7 8
pointSTRING          : 105
pointScopeClass      : 92
pointScopeClass2     : 92
pointWhile1          : 114
pointWhile2          : 114
pointWhile3          : 114
returnCall           : 64
statements           : 35
var                  : 44 45 51
varCte               : 57 59 59 89
varSimpleType        : 45
varsDef              : 34 94 95
varsType             : 50 51
voidCall             : 40
whileCycle           : 41

Parsing method: LALR

state 0

    (0) S' -> . begin
    (1) begin -> . BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end

    BEGIN           shift and go to state 2

    begin                          shift and go to state 1

state 1

    (0) S' -> begin .



state 2

    (1) begin -> BEGIN . pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end
    (2) pointCreateMainCuac -> .

    OPAREN          reduce using rule 2 (pointCreateMainCuac -> .)

    pointCreateMainCuac            shift and go to state 3

state 3

    (1) begin -> BEGIN pointCreateMainCuac . OPAREN ID CPAREN classDef fxDef main end

    OPAREN          shift and go to state 4


state 4

    (1) begin -> BEGIN pointCreateMainCuac OPAREN . ID CPAREN classDef fxDef main end

    ID              shift and go to state 5


state 5

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID . CPAREN classDef fxDef main end

    CPAREN          shift and go to state 6


state 6

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN . classDef fxDef main end
    (92) classDef -> . CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (93) classDef -> . epsilon
    (126) epsilon -> .

    CLASS           shift and go to state 8
    VOID            reduce using rule 126 (epsilon -> .)
    INT             reduce using rule 126 (epsilon -> .)
    STRING          reduce using rule 126 (epsilon -> .)
    DEC             reduce using rule 126 (epsilon -> .)
    BOOL            reduce using rule 126 (epsilon -> .)
    MAIN            reduce using rule 126 (epsilon -> .)

    classDef                       shift and go to state 7
    epsilon                        shift and go to state 9

state 7

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef . fxDef main end
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (126) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 126 (epsilon -> .)

    fxDef                          shift and go to state 10
    epsilon                        shift and go to state 12
    fxType                         shift and go to state 13

state 8

    (92) classDef -> CLASS . pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (99) pointClass -> .

    ID              reduce using rule 99 (pointClass -> .)

    pointClass                     shift and go to state 18

state 9

    (93) classDef -> epsilon .

    VOID            reduce using rule 93 (classDef -> epsilon .)
    INT             reduce using rule 93 (classDef -> epsilon .)
    STRING          reduce using rule 93 (classDef -> epsilon .)
    DEC             reduce using rule 93 (classDef -> epsilon .)
    BOOL            reduce using rule 93 (classDef -> epsilon .)
    MAIN            reduce using rule 93 (classDef -> epsilon .)


state 10

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef . main end
    (4) main -> . MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET

    MAIN            shift and go to state 20

    main                           shift and go to state 19

state 11

    (5) fxDef -> VOID . FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID . FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef

    FX              shift and go to state 21


state 12

    (9) fxDef -> epsilon .

    MAIN            reduce using rule 9 (fxDef -> epsilon .)
    CBRACKET        reduce using rule 9 (fxDef -> epsilon .)


state 13

    (7) fxDef -> fxType . FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType . FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    FX              shift and go to state 22


state 14

    (10) fxType -> INT .

    FX              reduce using rule 10 (fxType -> INT .)


state 15

    (11) fxType -> STRING .

    FX              reduce using rule 11 (fxType -> STRING .)


state 16

    (12) fxType -> DEC .

    FX              reduce using rule 12 (fxType -> DEC .)


state 17

    (13) fxType -> BOOL .

    FX              reduce using rule 13 (fxType -> BOOL .)


state 18

    (92) classDef -> CLASS pointClass . ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    ID              shift and go to state 23


state 19

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main . end
    (125) end -> . END OPAREN ID CPAREN

    END             shift and go to state 25

    end                            shift and go to state 24

state 20

    (4) main -> MAIN . pointMain OPAREN CPAREN OBRACKET body CBRACKET
    (3) pointMain -> .

    OPAREN          reduce using rule 3 (pointMain -> .)

    pointMain                      shift and go to state 26

state 21

    (5) fxDef -> VOID FX . pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX . pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (14) pointFx -> .

    ID              reduce using rule 14 (pointFx -> .)

    pointFx                        shift and go to state 27

state 22

    (7) fxDef -> fxType FX . pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX . pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (14) pointFx -> .

    ID              reduce using rule 14 (pointFx -> .)

    pointFx                        shift and go to state 28

state 23

    (92) classDef -> CLASS pointClass ID . pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (98) pointClassName -> .

    OBRACKET        reduce using rule 98 (pointClassName -> .)

    pointClassName                 shift and go to state 29

state 24

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end .

    $end            reduce using rule 1 (begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end .)


state 25

    (125) end -> END . OPAREN ID CPAREN

    OPAREN          shift and go to state 30


state 26

    (4) main -> MAIN pointMain . OPAREN CPAREN OBRACKET body CBRACKET

    OPAREN          shift and go to state 31


state 27

    (5) fxDef -> VOID FX pointFx . ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx . ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef

    ID              shift and go to state 32


state 28

    (7) fxDef -> fxType FX pointFx . ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx . ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    ID              shift and go to state 33


state 29

    (92) classDef -> CLASS pointClass ID pointClassName . OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    OBRACKET        shift and go to state 34


state 30

    (125) end -> END OPAREN . ID CPAREN

    ID              shift and go to state 35


state 31

    (4) main -> MAIN pointMain OPAREN . CPAREN OBRACKET body CBRACKET

    CPAREN          shift and go to state 36


state 32

    (5) fxDef -> VOID FX pointFx ID . pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx ID . pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (15) pointFxId -> .

    OPAREN          reduce using rule 15 (pointFxId -> .)

    pointFxId                      shift and go to state 37

state 33

    (7) fxDef -> fxType FX pointFx ID . pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx ID . pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (15) pointFxId -> .

    OPAREN          reduce using rule 15 (pointFxId -> .)

    pointFxId                      shift and go to state 38

state 34

    (92) classDef -> CLASS pointClass ID pointClassName OBRACKET . ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    ATTRIBUTES      shift and go to state 39


state 35

    (125) end -> END OPAREN ID . CPAREN

    CPAREN          shift and go to state 40


state 36

    (4) main -> MAIN pointMain OPAREN CPAREN . OBRACKET body CBRACKET

    OBRACKET        shift and go to state 41


state 37

    (5) fxDef -> VOID FX pointFx ID pointFxId . OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx ID pointFxId . OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef

    OPAREN          shift and go to state 42


state 38

    (7) fxDef -> fxType FX pointFx ID pointFxId . OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx ID pointFxId . OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    OPAREN          shift and go to state 43


state 39

    (92) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES . COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    COLON           shift and go to state 44


state 40

    (125) end -> END OPAREN ID CPAREN .

    $end            reduce using rule 125 (end -> END OPAREN ID CPAREN .)


state 41

    (4) main -> MAIN pointMain OPAREN CPAREN OBRACKET . body CBRACKET
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (126) epsilon -> .
    (60) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (61) assignmentDef -> . arr ASSIGNMENT pointPushAssignment expAssignment
    (123) input -> . INPUT OPAREN ID CPAREN EOF
    (124) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (114) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (118) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (100) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 126 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 59
    OUTPUT          shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62

    body                           shift and go to state 45
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56
    arr                            shift and go to state 58

state 42

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN . param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN . epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (19) param -> . paramType ID pointParam
    (20) param -> . paramType ID pointParam COMMA param
    (126) epsilon -> .
    (21) paramType -> . INT
    (22) paramType -> . STRING
    (23) paramType -> . DEC
    (24) paramType -> . BOOL

    CPAREN          reduce using rule 126 (epsilon -> .)
    INT             shift and go to state 66
    STRING          shift and go to state 67
    DEC             shift and go to state 68
    BOOL            shift and go to state 69

    param                          shift and go to state 63
    epsilon                        shift and go to state 64
    paramType                      shift and go to state 65

state 43

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN . param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN . epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (19) param -> . paramType ID pointParam
    (20) param -> . paramType ID pointParam COMMA param
    (126) epsilon -> .
    (21) paramType -> . INT
    (22) paramType -> . STRING
    (23) paramType -> . DEC
    (24) paramType -> . BOOL

    CPAREN          reduce using rule 126 (epsilon -> .)
    INT             shift and go to state 66
    STRING          shift and go to state 67
    DEC             shift and go to state 68
    BOOL            shift and go to state 69

    param                          shift and go to state 70
    epsilon                        shift and go to state 71
    paramType                      shift and go to state 65

state 44

    (92) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON . pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (94) pointAtt -> . varsDef
    (95) pointAtt -> . varsDef pointAtt
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF

    VAR             shift and go to state 49

    pointAtt                       shift and go to state 72
    varsDef                        shift and go to state 73

state 45

    (4) main -> MAIN pointMain OPAREN CPAREN OBRACKET body . CBRACKET

    CBRACKET        shift and go to state 74


state 46

    (34) body -> varsDef . body
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (126) epsilon -> .
    (60) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (61) assignmentDef -> . arr ASSIGNMENT pointPushAssignment expAssignment
    (123) input -> . INPUT OPAREN ID CPAREN EOF
    (124) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (114) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (118) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (100) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 126 (epsilon -> .)
    RETURN          reduce using rule 126 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 59
    OUTPUT          shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62

    varsDef                        shift and go to state 46
    body                           shift and go to state 75
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56
    arr                            shift and go to state 58

state 47

    (35) body -> statements . body
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (126) epsilon -> .
    (60) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (61) assignmentDef -> . arr ASSIGNMENT pointPushAssignment expAssignment
    (123) input -> . INPUT OPAREN ID CPAREN EOF
    (124) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (114) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (118) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (100) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 126 (epsilon -> .)
    RETURN          reduce using rule 126 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 59
    OUTPUT          shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62

    statements                     shift and go to state 47
    body                           shift and go to state 76
    varsDef                        shift and go to state 46
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56
    arr                            shift and go to state 58

state 48

    (36) body -> epsilon .

    CBRACKET        reduce using rule 36 (body -> epsilon .)
    RETURN          reduce using rule 36 (body -> epsilon .)


state 49

    (44) varsDef -> VAR . objType var EOF
    (45) varsDef -> VAR . varSimpleType var EOF
    (102) objType -> . ID
    (46) varSimpleType -> . INT
    (47) varSimpleType -> . STRING
    (48) varSimpleType -> . DEC
    (49) varSimpleType -> . BOOL

    ID              shift and go to state 79
    INT             shift and go to state 80
    STRING          shift and go to state 81
    DEC             shift and go to state 82
    BOOL            shift and go to state 83

    objType                        shift and go to state 77
    varSimpleType                  shift and go to state 78

state 50

    (37) statements -> assignmentDef .

    VAR             reduce using rule 37 (statements -> assignmentDef .)
    ID              reduce using rule 37 (statements -> assignmentDef .)
    INPUT           reduce using rule 37 (statements -> assignmentDef .)
    OUTPUT          reduce using rule 37 (statements -> assignmentDef .)
    WHILE           reduce using rule 37 (statements -> assignmentDef .)
    IF              reduce using rule 37 (statements -> assignmentDef .)
    CBRACKET        reduce using rule 37 (statements -> assignmentDef .)
    RETURN          reduce using rule 37 (statements -> assignmentDef .)


state 51

    (38) statements -> input .

    VAR             reduce using rule 38 (statements -> input .)
    ID              reduce using rule 38 (statements -> input .)
    INPUT           reduce using rule 38 (statements -> input .)
    OUTPUT          reduce using rule 38 (statements -> input .)
    WHILE           reduce using rule 38 (statements -> input .)
    IF              reduce using rule 38 (statements -> input .)
    CBRACKET        reduce using rule 38 (statements -> input .)
    RETURN          reduce using rule 38 (statements -> input .)


state 52

    (39) statements -> output .

    VAR             reduce using rule 39 (statements -> output .)
    ID              reduce using rule 39 (statements -> output .)
    INPUT           reduce using rule 39 (statements -> output .)
    OUTPUT          reduce using rule 39 (statements -> output .)
    WHILE           reduce using rule 39 (statements -> output .)
    IF              reduce using rule 39 (statements -> output .)
    CBRACKET        reduce using rule 39 (statements -> output .)
    RETURN          reduce using rule 39 (statements -> output .)


state 53

    (40) statements -> voidCall .

    VAR             reduce using rule 40 (statements -> voidCall .)
    ID              reduce using rule 40 (statements -> voidCall .)
    INPUT           reduce using rule 40 (statements -> voidCall .)
    OUTPUT          reduce using rule 40 (statements -> voidCall .)
    WHILE           reduce using rule 40 (statements -> voidCall .)
    IF              reduce using rule 40 (statements -> voidCall .)
    CBRACKET        reduce using rule 40 (statements -> voidCall .)
    RETURN          reduce using rule 40 (statements -> voidCall .)


state 54

    (41) statements -> whileCycle .

    VAR             reduce using rule 41 (statements -> whileCycle .)
    ID              reduce using rule 41 (statements -> whileCycle .)
    INPUT           reduce using rule 41 (statements -> whileCycle .)
    OUTPUT          reduce using rule 41 (statements -> whileCycle .)
    WHILE           reduce using rule 41 (statements -> whileCycle .)
    IF              reduce using rule 41 (statements -> whileCycle .)
    CBRACKET        reduce using rule 41 (statements -> whileCycle .)
    RETURN          reduce using rule 41 (statements -> whileCycle .)


state 55

    (42) statements -> ifCond .

    VAR             reduce using rule 42 (statements -> ifCond .)
    ID              reduce using rule 42 (statements -> ifCond .)
    INPUT           reduce using rule 42 (statements -> ifCond .)
    OUTPUT          reduce using rule 42 (statements -> ifCond .)
    WHILE           reduce using rule 42 (statements -> ifCond .)
    IF              reduce using rule 42 (statements -> ifCond .)
    CBRACKET        reduce using rule 42 (statements -> ifCond .)
    RETURN          reduce using rule 42 (statements -> ifCond .)


state 56

    (43) statements -> classCall .

    VAR             reduce using rule 43 (statements -> classCall .)
    ID              reduce using rule 43 (statements -> classCall .)
    INPUT           reduce using rule 43 (statements -> classCall .)
    OUTPUT          reduce using rule 43 (statements -> classCall .)
    WHILE           reduce using rule 43 (statements -> classCall .)
    IF              reduce using rule 43 (statements -> classCall .)
    CBRACKET        reduce using rule 43 (statements -> classCall .)
    RETURN          reduce using rule 43 (statements -> classCall .)


state 57

    (60) assignmentDef -> ID . ASSIGNMENT pointPushAssignment expAssignment
    (30) voidCall -> ID . pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> ID . pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (100) classCall -> ID . MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> ID . MONEY ID OPAREN epsilon CPAREN EOF
    (57) arr -> ID . OSQUAREBR varCte pointCheckTypeInt CSQUAREBR
    (32) pointEra -> .

    ASSIGNMENT      shift and go to state 84
    MONEY           shift and go to state 86
    OSQUAREBR       shift and go to state 87
    OPAREN          reduce using rule 32 (pointEra -> .)

    pointEra                       shift and go to state 85

state 58

    (61) assignmentDef -> arr . ASSIGNMENT pointPushAssignment expAssignment

    ASSIGNMENT      shift and go to state 88


state 59

    (123) input -> INPUT . OPAREN ID CPAREN EOF

    OPAREN          shift and go to state 89


state 60

    (124) output -> OUTPUT . OPAREN expRelational CPAREN EOF

    OPAREN          shift and go to state 90


state 61

    (114) whileCycle -> WHILE . pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (115) pointWhile1 -> .

    OPAREN          reduce using rule 115 (pointWhile1 -> .)

    pointWhile1                    shift and go to state 91

state 62

    (118) ifCond -> IF . OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> IF . OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    OPAREN          shift and go to state 92


state 63

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param . CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 93


state 64

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon . CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 94


state 65

    (19) param -> paramType . ID pointParam
    (20) param -> paramType . ID pointParam COMMA param

    ID              shift and go to state 95


state 66

    (21) paramType -> INT .

    ID              reduce using rule 21 (paramType -> INT .)


state 67

    (22) paramType -> STRING .

    ID              reduce using rule 22 (paramType -> STRING .)


state 68

    (23) paramType -> DEC .

    ID              reduce using rule 23 (paramType -> DEC .)


state 69

    (24) paramType -> BOOL .

    ID              reduce using rule 24 (paramType -> BOOL .)


state 70

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param . CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 96


state 71

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon . CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 97


state 72

    (92) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt . METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    METHODS         shift and go to state 98


state 73

    (94) pointAtt -> varsDef .
    (95) pointAtt -> varsDef . pointAtt
    (94) pointAtt -> . varsDef
    (95) pointAtt -> . varsDef pointAtt
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF

    METHODS         reduce using rule 94 (pointAtt -> varsDef .)
    VAR             shift and go to state 49

    varsDef                        shift and go to state 73
    pointAtt                       shift and go to state 99

state 74

    (4) main -> MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET .

    END             reduce using rule 4 (main -> MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET .)


state 75

    (34) body -> varsDef body .

    CBRACKET        reduce using rule 34 (body -> varsDef body .)
    RETURN          reduce using rule 34 (body -> varsDef body .)


state 76

    (35) body -> statements body .

    CBRACKET        reduce using rule 35 (body -> statements body .)
    RETURN          reduce using rule 35 (body -> statements body .)


state 77

    (44) varsDef -> VAR objType . var EOF
    (50) var -> . varsType
    (51) var -> . varsType COMMA var
    (52) varsType -> . ID pointID
    (53) varsType -> . arrDef
    (54) varsType -> . matrixDef
    (56) arrDef -> . ID OSQUAREBR INT COLON INT CSQUAREBR
    (59) matrixDef -> . arrDef OSQUAREBR varCte COLON varCte CSQUAREBR

    ID              shift and go to state 102

    var                            shift and go to state 100
    varsType                       shift and go to state 101
    arrDef                         shift and go to state 103
    matrixDef                      shift and go to state 104

state 78

    (45) varsDef -> VAR varSimpleType . var EOF
    (50) var -> . varsType
    (51) var -> . varsType COMMA var
    (52) varsType -> . ID pointID
    (53) varsType -> . arrDef
    (54) varsType -> . matrixDef
    (56) arrDef -> . ID OSQUAREBR INT COLON INT CSQUAREBR
    (59) matrixDef -> . arrDef OSQUAREBR varCte COLON varCte CSQUAREBR

    ID              shift and go to state 102

    var                            shift and go to state 105
    varsType                       shift and go to state 101
    arrDef                         shift and go to state 103
    matrixDef                      shift and go to state 104

state 79

    (102) objType -> ID .

    ID              reduce using rule 102 (objType -> ID .)


state 80

    (46) varSimpleType -> INT .

    ID              reduce using rule 46 (varSimpleType -> INT .)


state 81

    (47) varSimpleType -> STRING .

    ID              reduce using rule 47 (varSimpleType -> STRING .)


state 82

    (48) varSimpleType -> DEC .

    ID              reduce using rule 48 (varSimpleType -> DEC .)


state 83

    (49) varSimpleType -> BOOL .

    ID              reduce using rule 49 (varSimpleType -> BOOL .)


state 84

    (60) assignmentDef -> ID ASSIGNMENT . pointPushAssignment expAssignment
    (62) pointPushAssignment -> .

    ID              reduce using rule 62 (pointPushAssignment -> .)
    OPAREN          reduce using rule 62 (pointPushAssignment -> .)
    INT             reduce using rule 62 (pointPushAssignment -> .)
    DEC             reduce using rule 62 (pointPushAssignment -> .)
    STRING          reduce using rule 62 (pointPushAssignment -> .)
    TRUE            reduce using rule 62 (pointPushAssignment -> .)
    FALSE           reduce using rule 62 (pointPushAssignment -> .)

    pointPushAssignment            shift and go to state 106

state 85

    (30) voidCall -> ID pointEra . OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> ID pointEra . OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF

    OPAREN          shift and go to state 107


state 86

    (100) classCall -> ID MONEY . ID OPAREN paramCall CPAREN EOF
    (101) classCall -> ID MONEY . ID OPAREN epsilon CPAREN EOF

    ID              shift and go to state 108


state 87

    (57) arr -> ID OSQUAREBR . varCte pointCheckTypeInt CSQUAREBR
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 109

    varCte                         shift and go to state 110
    arr                            shift and go to state 116

state 88

    (61) assignmentDef -> arr ASSIGNMENT . pointPushAssignment expAssignment
    (62) pointPushAssignment -> .

    ID              reduce using rule 62 (pointPushAssignment -> .)
    OPAREN          reduce using rule 62 (pointPushAssignment -> .)
    INT             reduce using rule 62 (pointPushAssignment -> .)
    DEC             reduce using rule 62 (pointPushAssignment -> .)
    STRING          reduce using rule 62 (pointPushAssignment -> .)
    TRUE            reduce using rule 62 (pointPushAssignment -> .)
    FALSE           reduce using rule 62 (pointPushAssignment -> .)

    pointPushAssignment            shift and go to state 117

state 89

    (123) input -> INPUT OPAREN . ID CPAREN EOF

    ID              shift and go to state 118


state 90

    (124) output -> OUTPUT OPAREN . expRelational CPAREN EOF
    (69) expRelational -> . plusMinus
    (70) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (78) plusMinus -> . multDiv pointCheckPlusMinus
    (79) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (80) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (83) multDiv -> . expParen pointCheckMultDiv
    (84) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (88) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (89) expParen -> . varCte
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    OPAREN          shift and go to state 119
    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 109

    expRelational                  shift and go to state 120
    plusMinus                      shift and go to state 121
    multDiv                        shift and go to state 122
    expParen                       shift and go to state 123
    varCte                         shift and go to state 124
    arr                            shift and go to state 116

state 91

    (114) whileCycle -> WHILE pointWhile1 . OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3

    OPAREN          shift and go to state 125


state 92

    (118) ifCond -> IF OPAREN . expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> IF OPAREN . expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (69) expRelational -> . plusMinus
    (70) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (78) plusMinus -> . multDiv pointCheckPlusMinus
    (79) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (80) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (83) multDiv -> . expParen pointCheckMultDiv
    (84) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (88) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (89) expParen -> . varCte
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    OPAREN          shift and go to state 119
    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 109

    expRelational                  shift and go to state 126
    plusMinus                      shift and go to state 121
    multDiv                        shift and go to state 122
    expParen                       shift and go to state 123
    varCte                         shift and go to state 124
    arr                            shift and go to state 116

state 93

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN . pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (17) pointParamCount -> .

    OBRACKET        reduce using rule 17 (pointParamCount -> .)

    pointParamCount                shift and go to state 127

state 94

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN . pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (17) pointParamCount -> .

    OBRACKET        reduce using rule 17 (pointParamCount -> .)

    pointParamCount                shift and go to state 128

state 95

    (19) param -> paramType ID . pointParam
    (20) param -> paramType ID . pointParam COMMA param
    (25) pointParam -> .

    COMMA           reduce using rule 25 (pointParam -> .)
    CPAREN          reduce using rule 25 (pointParam -> .)

    pointParam                     shift and go to state 129

state 96

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN . pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (17) pointParamCount -> .

    OBRACKET        reduce using rule 17 (pointParamCount -> .)

    pointParamCount                shift and go to state 130

state 97

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN . pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (17) pointParamCount -> .

    OBRACKET        reduce using rule 17 (pointParamCount -> .)

    pointParamCount                shift and go to state 131

state 98

    (92) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS . COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    COLON           shift and go to state 132


state 99

    (95) pointAtt -> varsDef pointAtt .

    METHODS         reduce using rule 95 (pointAtt -> varsDef pointAtt .)


state 100

    (44) varsDef -> VAR objType var . EOF

    EOF             shift and go to state 133


state 101

    (50) var -> varsType .
    (51) var -> varsType . COMMA var

    EOF             reduce using rule 50 (var -> varsType .)
    COMMA           shift and go to state 134


state 102

    (52) varsType -> ID . pointID
    (56) arrDef -> ID . OSQUAREBR INT COLON INT CSQUAREBR
    (55) pointID -> .

    OSQUAREBR       shift and go to state 136
    COMMA           reduce using rule 55 (pointID -> .)
    EOF             reduce using rule 55 (pointID -> .)

    pointID                        shift and go to state 135

state 103

    (53) varsType -> arrDef .
    (59) matrixDef -> arrDef . OSQUAREBR varCte COLON varCte CSQUAREBR

    COMMA           reduce using rule 53 (varsType -> arrDef .)
    EOF             reduce using rule 53 (varsType -> arrDef .)
    OSQUAREBR       shift and go to state 137


state 104

    (54) varsType -> matrixDef .

    COMMA           reduce using rule 54 (varsType -> matrixDef .)
    EOF             reduce using rule 54 (varsType -> matrixDef .)


state 105

    (45) varsDef -> VAR varSimpleType var . EOF

    EOF             shift and go to state 138


state 106

    (60) assignmentDef -> ID ASSIGNMENT pointPushAssignment . expAssignment
    (63) expAssignment -> . expRelational EOF
    (64) expAssignment -> . returnCall EOF
    (65) expAssignment -> . classCall
    (69) expRelational -> . plusMinus
    (70) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (66) returnCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN
    (67) returnCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN
    (100) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (78) plusMinus -> . multDiv pointCheckPlusMinus
    (79) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (80) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (83) multDiv -> . expParen pointCheckMultDiv
    (84) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (88) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (89) expParen -> . varCte
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    ID              shift and go to state 139
    OPAREN          shift and go to state 119
    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115

    expAssignment                  shift and go to state 140
    expRelational                  shift and go to state 141
    returnCall                     shift and go to state 142
    classCall                      shift and go to state 143
    plusMinus                      shift and go to state 121
    multDiv                        shift and go to state 122
    expParen                       shift and go to state 123
    varCte                         shift and go to state 124
    arr                            shift and go to state 116

state 107

    (30) voidCall -> ID pointEra OPAREN . paramCall pointGoSub CPAREN EOF
    (31) voidCall -> ID pointEra OPAREN . epsilon pointParamVacio pointGoSub CPAREN EOF
    (26) paramCall -> . ID pointParamCall pointParamNum
    (27) paramCall -> . ID pointParamCall COMMA paramCall
    (126) epsilon -> .

    ID              shift and go to state 144
    CPAREN          reduce using rule 126 (epsilon -> .)

    paramCall                      shift and go to state 145
    epsilon                        shift and go to state 146

state 108

    (100) classCall -> ID MONEY ID . OPAREN paramCall CPAREN EOF
    (101) classCall -> ID MONEY ID . OPAREN epsilon CPAREN EOF

    OPAREN          shift and go to state 147


state 109

    (108) varCte -> ID .
    (57) arr -> ID . OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    CSQUAREBR       reduce using rule 108 (varCte -> ID .)
    MULTIPLY        reduce using rule 108 (varCte -> ID .)
    DIVIDE          reduce using rule 108 (varCte -> ID .)
    PLUS            reduce using rule 108 (varCte -> ID .)
    MINUS           reduce using rule 108 (varCte -> ID .)
    EQUAL           reduce using rule 108 (varCte -> ID .)
    DIFFERENT       reduce using rule 108 (varCte -> ID .)
    GREATERTHAN     reduce using rule 108 (varCte -> ID .)
    GREATERTHANEQ   reduce using rule 108 (varCte -> ID .)
    LESSTHAN        reduce using rule 108 (varCte -> ID .)
    LESSTHANEQ      reduce using rule 108 (varCte -> ID .)
    CPAREN          reduce using rule 108 (varCte -> ID .)
    COLON           reduce using rule 108 (varCte -> ID .)
    EOF             reduce using rule 108 (varCte -> ID .)
    OSQUAREBR       shift and go to state 87


state 110

    (57) arr -> ID OSQUAREBR varCte . pointCheckTypeInt CSQUAREBR
    (58) pointCheckTypeInt -> .

    CSQUAREBR       reduce using rule 58 (pointCheckTypeInt -> .)

    pointCheckTypeInt              shift and go to state 148

state 111

    (103) varCte -> INT . pointINT
    (110) pointINT -> .

    CSQUAREBR       reduce using rule 110 (pointINT -> .)
    MULTIPLY        reduce using rule 110 (pointINT -> .)
    DIVIDE          reduce using rule 110 (pointINT -> .)
    PLUS            reduce using rule 110 (pointINT -> .)
    MINUS           reduce using rule 110 (pointINT -> .)
    EQUAL           reduce using rule 110 (pointINT -> .)
    DIFFERENT       reduce using rule 110 (pointINT -> .)
    GREATERTHAN     reduce using rule 110 (pointINT -> .)
    GREATERTHANEQ   reduce using rule 110 (pointINT -> .)
    LESSTHAN        reduce using rule 110 (pointINT -> .)
    LESSTHANEQ      reduce using rule 110 (pointINT -> .)
    CPAREN          reduce using rule 110 (pointINT -> .)
    EOF             reduce using rule 110 (pointINT -> .)
    COLON           reduce using rule 110 (pointINT -> .)

    pointINT                       shift and go to state 149

state 112

    (104) varCte -> DEC . pointDEC
    (111) pointDEC -> .

    CSQUAREBR       reduce using rule 111 (pointDEC -> .)
    MULTIPLY        reduce using rule 111 (pointDEC -> .)
    DIVIDE          reduce using rule 111 (pointDEC -> .)
    PLUS            reduce using rule 111 (pointDEC -> .)
    MINUS           reduce using rule 111 (pointDEC -> .)
    EQUAL           reduce using rule 111 (pointDEC -> .)
    DIFFERENT       reduce using rule 111 (pointDEC -> .)
    GREATERTHAN     reduce using rule 111 (pointDEC -> .)
    GREATERTHANEQ   reduce using rule 111 (pointDEC -> .)
    LESSTHAN        reduce using rule 111 (pointDEC -> .)
    LESSTHANEQ      reduce using rule 111 (pointDEC -> .)
    CPAREN          reduce using rule 111 (pointDEC -> .)
    EOF             reduce using rule 111 (pointDEC -> .)
    COLON           reduce using rule 111 (pointDEC -> .)

    pointDEC                       shift and go to state 150

state 113

    (105) varCte -> STRING . pointSTRING
    (112) pointSTRING -> .

    CSQUAREBR       reduce using rule 112 (pointSTRING -> .)
    MULTIPLY        reduce using rule 112 (pointSTRING -> .)
    DIVIDE          reduce using rule 112 (pointSTRING -> .)
    PLUS            reduce using rule 112 (pointSTRING -> .)
    MINUS           reduce using rule 112 (pointSTRING -> .)
    EQUAL           reduce using rule 112 (pointSTRING -> .)
    DIFFERENT       reduce using rule 112 (pointSTRING -> .)
    GREATERTHAN     reduce using rule 112 (pointSTRING -> .)
    GREATERTHANEQ   reduce using rule 112 (pointSTRING -> .)
    LESSTHAN        reduce using rule 112 (pointSTRING -> .)
    LESSTHANEQ      reduce using rule 112 (pointSTRING -> .)
    CPAREN          reduce using rule 112 (pointSTRING -> .)
    EOF             reduce using rule 112 (pointSTRING -> .)
    COLON           reduce using rule 112 (pointSTRING -> .)

    pointSTRING                    shift and go to state 151

state 114

    (106) varCte -> TRUE . pointBOOL
    (113) pointBOOL -> .

    CSQUAREBR       reduce using rule 113 (pointBOOL -> .)
    MULTIPLY        reduce using rule 113 (pointBOOL -> .)
    DIVIDE          reduce using rule 113 (pointBOOL -> .)
    PLUS            reduce using rule 113 (pointBOOL -> .)
    MINUS           reduce using rule 113 (pointBOOL -> .)
    EQUAL           reduce using rule 113 (pointBOOL -> .)
    DIFFERENT       reduce using rule 113 (pointBOOL -> .)
    GREATERTHAN     reduce using rule 113 (pointBOOL -> .)
    GREATERTHANEQ   reduce using rule 113 (pointBOOL -> .)
    LESSTHAN        reduce using rule 113 (pointBOOL -> .)
    LESSTHANEQ      reduce using rule 113 (pointBOOL -> .)
    CPAREN          reduce using rule 113 (pointBOOL -> .)
    EOF             reduce using rule 113 (pointBOOL -> .)
    COLON           reduce using rule 113 (pointBOOL -> .)

    pointBOOL                      shift and go to state 152

state 115

    (107) varCte -> FALSE . pointBOOL
    (113) pointBOOL -> .

    CSQUAREBR       reduce using rule 113 (pointBOOL -> .)
    MULTIPLY        reduce using rule 113 (pointBOOL -> .)
    DIVIDE          reduce using rule 113 (pointBOOL -> .)
    PLUS            reduce using rule 113 (pointBOOL -> .)
    MINUS           reduce using rule 113 (pointBOOL -> .)
    EQUAL           reduce using rule 113 (pointBOOL -> .)
    DIFFERENT       reduce using rule 113 (pointBOOL -> .)
    GREATERTHAN     reduce using rule 113 (pointBOOL -> .)
    GREATERTHANEQ   reduce using rule 113 (pointBOOL -> .)
    LESSTHAN        reduce using rule 113 (pointBOOL -> .)
    LESSTHANEQ      reduce using rule 113 (pointBOOL -> .)
    CPAREN          reduce using rule 113 (pointBOOL -> .)
    EOF             reduce using rule 113 (pointBOOL -> .)
    COLON           reduce using rule 113 (pointBOOL -> .)

    pointBOOL                      shift and go to state 153

state 116

    (109) varCte -> arr .

    CSQUAREBR       reduce using rule 109 (varCte -> arr .)
    MULTIPLY        reduce using rule 109 (varCte -> arr .)
    DIVIDE          reduce using rule 109 (varCte -> arr .)
    PLUS            reduce using rule 109 (varCte -> arr .)
    MINUS           reduce using rule 109 (varCte -> arr .)
    EQUAL           reduce using rule 109 (varCte -> arr .)
    DIFFERENT       reduce using rule 109 (varCte -> arr .)
    GREATERTHAN     reduce using rule 109 (varCte -> arr .)
    GREATERTHANEQ   reduce using rule 109 (varCte -> arr .)
    LESSTHAN        reduce using rule 109 (varCte -> arr .)
    LESSTHANEQ      reduce using rule 109 (varCte -> arr .)
    CPAREN          reduce using rule 109 (varCte -> arr .)
    EOF             reduce using rule 109 (varCte -> arr .)
    COLON           reduce using rule 109 (varCte -> arr .)


state 117

    (61) assignmentDef -> arr ASSIGNMENT pointPushAssignment . expAssignment
    (63) expAssignment -> . expRelational EOF
    (64) expAssignment -> . returnCall EOF
    (65) expAssignment -> . classCall
    (69) expRelational -> . plusMinus
    (70) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (66) returnCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN
    (67) returnCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN
    (100) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (78) plusMinus -> . multDiv pointCheckPlusMinus
    (79) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (80) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (83) multDiv -> . expParen pointCheckMultDiv
    (84) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (88) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (89) expParen -> . varCte
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    ID              shift and go to state 139
    OPAREN          shift and go to state 119
    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115

    arr                            shift and go to state 116
    expAssignment                  shift and go to state 154
    expRelational                  shift and go to state 141
    returnCall                     shift and go to state 142
    classCall                      shift and go to state 143
    plusMinus                      shift and go to state 121
    multDiv                        shift and go to state 122
    expParen                       shift and go to state 123
    varCte                         shift and go to state 124

state 118

    (123) input -> INPUT OPAREN ID . CPAREN EOF

    CPAREN          shift and go to state 155


state 119

    (88) expParen -> OPAREN . pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (90) pointFakeBackground -> .

    OPAREN          reduce using rule 90 (pointFakeBackground -> .)
    INT             reduce using rule 90 (pointFakeBackground -> .)
    DEC             reduce using rule 90 (pointFakeBackground -> .)
    STRING          reduce using rule 90 (pointFakeBackground -> .)
    TRUE            reduce using rule 90 (pointFakeBackground -> .)
    FALSE           reduce using rule 90 (pointFakeBackground -> .)
    ID              reduce using rule 90 (pointFakeBackground -> .)

    pointFakeBackground            shift and go to state 156

state 120

    (124) output -> OUTPUT OPAREN expRelational . CPAREN EOF

    CPAREN          shift and go to state 157


state 121

    (69) expRelational -> plusMinus .
    (70) expRelational -> plusMinus . opRelational expRelational pointCheckOpRel
    (72) opRelational -> . EQUAL
    (73) opRelational -> . DIFFERENT
    (74) opRelational -> . GREATERTHAN
    (75) opRelational -> . GREATERTHANEQ
    (76) opRelational -> . LESSTHAN
    (77) opRelational -> . LESSTHANEQ

    CPAREN          reduce using rule 69 (expRelational -> plusMinus .)
    EOF             reduce using rule 69 (expRelational -> plusMinus .)
    EQUAL           shift and go to state 159
    DIFFERENT       shift and go to state 160
    GREATERTHAN     shift and go to state 161
    GREATERTHANEQ   shift and go to state 162
    LESSTHAN        shift and go to state 163
    LESSTHANEQ      shift and go to state 164

    opRelational                   shift and go to state 158

state 122

    (78) plusMinus -> multDiv . pointCheckPlusMinus
    (79) plusMinus -> multDiv . pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (80) plusMinus -> multDiv . pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (81) pointCheckPlusMinus -> .

    PLUS            reduce using rule 81 (pointCheckPlusMinus -> .)
    MINUS           reduce using rule 81 (pointCheckPlusMinus -> .)
    EQUAL           reduce using rule 81 (pointCheckPlusMinus -> .)
    DIFFERENT       reduce using rule 81 (pointCheckPlusMinus -> .)
    GREATERTHAN     reduce using rule 81 (pointCheckPlusMinus -> .)
    GREATERTHANEQ   reduce using rule 81 (pointCheckPlusMinus -> .)
    LESSTHAN        reduce using rule 81 (pointCheckPlusMinus -> .)
    LESSTHANEQ      reduce using rule 81 (pointCheckPlusMinus -> .)
    CPAREN          reduce using rule 81 (pointCheckPlusMinus -> .)
    EOF             reduce using rule 81 (pointCheckPlusMinus -> .)

    pointCheckPlusMinus            shift and go to state 165

state 123

    (83) multDiv -> expParen . pointCheckMultDiv
    (84) multDiv -> expParen . pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> expParen . pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (86) pointCheckMultDiv -> .

    MULTIPLY        reduce using rule 86 (pointCheckMultDiv -> .)
    DIVIDE          reduce using rule 86 (pointCheckMultDiv -> .)
    PLUS            reduce using rule 86 (pointCheckMultDiv -> .)
    MINUS           reduce using rule 86 (pointCheckMultDiv -> .)
    EQUAL           reduce using rule 86 (pointCheckMultDiv -> .)
    DIFFERENT       reduce using rule 86 (pointCheckMultDiv -> .)
    GREATERTHAN     reduce using rule 86 (pointCheckMultDiv -> .)
    GREATERTHANEQ   reduce using rule 86 (pointCheckMultDiv -> .)
    LESSTHAN        reduce using rule 86 (pointCheckMultDiv -> .)
    LESSTHANEQ      reduce using rule 86 (pointCheckMultDiv -> .)
    CPAREN          reduce using rule 86 (pointCheckMultDiv -> .)
    EOF             reduce using rule 86 (pointCheckMultDiv -> .)

    pointCheckMultDiv              shift and go to state 166

state 124

    (89) expParen -> varCte .

    MULTIPLY        reduce using rule 89 (expParen -> varCte .)
    DIVIDE          reduce using rule 89 (expParen -> varCte .)
    PLUS            reduce using rule 89 (expParen -> varCte .)
    MINUS           reduce using rule 89 (expParen -> varCte .)
    EQUAL           reduce using rule 89 (expParen -> varCte .)
    DIFFERENT       reduce using rule 89 (expParen -> varCte .)
    GREATERTHAN     reduce using rule 89 (expParen -> varCte .)
    GREATERTHANEQ   reduce using rule 89 (expParen -> varCte .)
    LESSTHAN        reduce using rule 89 (expParen -> varCte .)
    LESSTHANEQ      reduce using rule 89 (expParen -> varCte .)
    CPAREN          reduce using rule 89 (expParen -> varCte .)
    EOF             reduce using rule 89 (expParen -> varCte .)


state 125

    (114) whileCycle -> WHILE pointWhile1 OPAREN . expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (69) expRelational -> . plusMinus
    (70) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (78) plusMinus -> . multDiv pointCheckPlusMinus
    (79) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (80) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (83) multDiv -> . expParen pointCheckMultDiv
    (84) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (88) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (89) expParen -> . varCte
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    OPAREN          shift and go to state 119
    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 109

    expRelational                  shift and go to state 167
    plusMinus                      shift and go to state 121
    multDiv                        shift and go to state 122
    expParen                       shift and go to state 123
    varCte                         shift and go to state 124
    arr                            shift and go to state 116

state 126

    (118) ifCond -> IF OPAREN expRelational . CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> IF OPAREN expRelational . CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    CPAREN          shift and go to state 168


state 127

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount . OBRACKET body CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 169


state 128

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount . OBRACKET body CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 170


state 129

    (19) param -> paramType ID pointParam .
    (20) param -> paramType ID pointParam . COMMA param

    CPAREN          reduce using rule 19 (param -> paramType ID pointParam .)
    COMMA           shift and go to state 171


state 130

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount . OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 172


state 131

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount . OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 173


state 132

    (92) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON . pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (96) pointScopeClass -> .

    VOID            reduce using rule 96 (pointScopeClass -> .)
    INT             reduce using rule 96 (pointScopeClass -> .)
    STRING          reduce using rule 96 (pointScopeClass -> .)
    DEC             reduce using rule 96 (pointScopeClass -> .)
    BOOL            reduce using rule 96 (pointScopeClass -> .)
    CBRACKET        reduce using rule 96 (pointScopeClass -> .)

    pointScopeClass                shift and go to state 174

state 133

    (44) varsDef -> VAR objType var EOF .

    VAR             reduce using rule 44 (varsDef -> VAR objType var EOF .)
    ID              reduce using rule 44 (varsDef -> VAR objType var EOF .)
    INPUT           reduce using rule 44 (varsDef -> VAR objType var EOF .)
    OUTPUT          reduce using rule 44 (varsDef -> VAR objType var EOF .)
    WHILE           reduce using rule 44 (varsDef -> VAR objType var EOF .)
    IF              reduce using rule 44 (varsDef -> VAR objType var EOF .)
    CBRACKET        reduce using rule 44 (varsDef -> VAR objType var EOF .)
    METHODS         reduce using rule 44 (varsDef -> VAR objType var EOF .)
    RETURN          reduce using rule 44 (varsDef -> VAR objType var EOF .)


state 134

    (51) var -> varsType COMMA . var
    (50) var -> . varsType
    (51) var -> . varsType COMMA var
    (52) varsType -> . ID pointID
    (53) varsType -> . arrDef
    (54) varsType -> . matrixDef
    (56) arrDef -> . ID OSQUAREBR INT COLON INT CSQUAREBR
    (59) matrixDef -> . arrDef OSQUAREBR varCte COLON varCte CSQUAREBR

    ID              shift and go to state 102

    varsType                       shift and go to state 101
    var                            shift and go to state 175
    arrDef                         shift and go to state 103
    matrixDef                      shift and go to state 104

state 135

    (52) varsType -> ID pointID .

    COMMA           reduce using rule 52 (varsType -> ID pointID .)
    EOF             reduce using rule 52 (varsType -> ID pointID .)


state 136

    (56) arrDef -> ID OSQUAREBR . INT COLON INT CSQUAREBR

    INT             shift and go to state 176


state 137

    (59) matrixDef -> arrDef OSQUAREBR . varCte COLON varCte CSQUAREBR
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 109

    varCte                         shift and go to state 177
    arr                            shift and go to state 116

state 138

    (45) varsDef -> VAR varSimpleType var EOF .

    VAR             reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    ID              reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    INPUT           reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    OUTPUT          reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    WHILE           reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    IF              reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    CBRACKET        reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    METHODS         reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    RETURN          reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)


state 139

    (66) returnCall -> ID . pointEra OPAREN paramCall pointGoSub CPAREN
    (67) returnCall -> ID . pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN
    (100) classCall -> ID . MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> ID . MONEY ID OPAREN epsilon CPAREN EOF
    (108) varCte -> ID .
    (57) arr -> ID . OSQUAREBR varCte pointCheckTypeInt CSQUAREBR
    (32) pointEra -> .

    MONEY           shift and go to state 86
    MULTIPLY        reduce using rule 108 (varCte -> ID .)
    DIVIDE          reduce using rule 108 (varCte -> ID .)
    PLUS            reduce using rule 108 (varCte -> ID .)
    MINUS           reduce using rule 108 (varCte -> ID .)
    EQUAL           reduce using rule 108 (varCte -> ID .)
    DIFFERENT       reduce using rule 108 (varCte -> ID .)
    GREATERTHAN     reduce using rule 108 (varCte -> ID .)
    GREATERTHANEQ   reduce using rule 108 (varCte -> ID .)
    LESSTHAN        reduce using rule 108 (varCte -> ID .)
    LESSTHANEQ      reduce using rule 108 (varCte -> ID .)
    EOF             reduce using rule 108 (varCte -> ID .)
    OSQUAREBR       shift and go to state 87
    OPAREN          reduce using rule 32 (pointEra -> .)

    pointEra                       shift and go to state 178

state 140

    (60) assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .

    VAR             reduce using rule 60 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    ID              reduce using rule 60 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    INPUT           reduce using rule 60 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    OUTPUT          reduce using rule 60 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    WHILE           reduce using rule 60 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    IF              reduce using rule 60 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    CBRACKET        reduce using rule 60 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    RETURN          reduce using rule 60 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)


state 141

    (63) expAssignment -> expRelational . EOF

    EOF             shift and go to state 179


state 142

    (64) expAssignment -> returnCall . EOF

    EOF             shift and go to state 180


state 143

    (65) expAssignment -> classCall .

    VAR             reduce using rule 65 (expAssignment -> classCall .)
    ID              reduce using rule 65 (expAssignment -> classCall .)
    INPUT           reduce using rule 65 (expAssignment -> classCall .)
    OUTPUT          reduce using rule 65 (expAssignment -> classCall .)
    WHILE           reduce using rule 65 (expAssignment -> classCall .)
    IF              reduce using rule 65 (expAssignment -> classCall .)
    CBRACKET        reduce using rule 65 (expAssignment -> classCall .)
    RETURN          reduce using rule 65 (expAssignment -> classCall .)


state 144

    (26) paramCall -> ID . pointParamCall pointParamNum
    (27) paramCall -> ID . pointParamCall COMMA paramCall
    (29) pointParamCall -> .

    COMMA           reduce using rule 29 (pointParamCall -> .)
    CPAREN          reduce using rule 29 (pointParamCall -> .)

    pointParamCall                 shift and go to state 181

state 145

    (30) voidCall -> ID pointEra OPAREN paramCall . pointGoSub CPAREN EOF
    (33) pointGoSub -> .

    CPAREN          reduce using rule 33 (pointGoSub -> .)

    pointGoSub                     shift and go to state 182

state 146

    (31) voidCall -> ID pointEra OPAREN epsilon . pointParamVacio pointGoSub CPAREN EOF
    (68) pointParamVacio -> .

    CPAREN          reduce using rule 68 (pointParamVacio -> .)

    pointParamVacio                shift and go to state 183

state 147

    (100) classCall -> ID MONEY ID OPAREN . paramCall CPAREN EOF
    (101) classCall -> ID MONEY ID OPAREN . epsilon CPAREN EOF
    (26) paramCall -> . ID pointParamCall pointParamNum
    (27) paramCall -> . ID pointParamCall COMMA paramCall
    (126) epsilon -> .

    ID              shift and go to state 144
    CPAREN          reduce using rule 126 (epsilon -> .)

    paramCall                      shift and go to state 184
    epsilon                        shift and go to state 185

state 148

    (57) arr -> ID OSQUAREBR varCte pointCheckTypeInt . CSQUAREBR

    CSQUAREBR       shift and go to state 186


state 149

    (103) varCte -> INT pointINT .

    CSQUAREBR       reduce using rule 103 (varCte -> INT pointINT .)
    MULTIPLY        reduce using rule 103 (varCte -> INT pointINT .)
    DIVIDE          reduce using rule 103 (varCte -> INT pointINT .)
    PLUS            reduce using rule 103 (varCte -> INT pointINT .)
    MINUS           reduce using rule 103 (varCte -> INT pointINT .)
    EQUAL           reduce using rule 103 (varCte -> INT pointINT .)
    DIFFERENT       reduce using rule 103 (varCte -> INT pointINT .)
    GREATERTHAN     reduce using rule 103 (varCte -> INT pointINT .)
    GREATERTHANEQ   reduce using rule 103 (varCte -> INT pointINT .)
    LESSTHAN        reduce using rule 103 (varCte -> INT pointINT .)
    LESSTHANEQ      reduce using rule 103 (varCte -> INT pointINT .)
    CPAREN          reduce using rule 103 (varCte -> INT pointINT .)
    EOF             reduce using rule 103 (varCte -> INT pointINT .)
    COLON           reduce using rule 103 (varCte -> INT pointINT .)


state 150

    (104) varCte -> DEC pointDEC .

    CSQUAREBR       reduce using rule 104 (varCte -> DEC pointDEC .)
    MULTIPLY        reduce using rule 104 (varCte -> DEC pointDEC .)
    DIVIDE          reduce using rule 104 (varCte -> DEC pointDEC .)
    PLUS            reduce using rule 104 (varCte -> DEC pointDEC .)
    MINUS           reduce using rule 104 (varCte -> DEC pointDEC .)
    EQUAL           reduce using rule 104 (varCte -> DEC pointDEC .)
    DIFFERENT       reduce using rule 104 (varCte -> DEC pointDEC .)
    GREATERTHAN     reduce using rule 104 (varCte -> DEC pointDEC .)
    GREATERTHANEQ   reduce using rule 104 (varCte -> DEC pointDEC .)
    LESSTHAN        reduce using rule 104 (varCte -> DEC pointDEC .)
    LESSTHANEQ      reduce using rule 104 (varCte -> DEC pointDEC .)
    CPAREN          reduce using rule 104 (varCte -> DEC pointDEC .)
    EOF             reduce using rule 104 (varCte -> DEC pointDEC .)
    COLON           reduce using rule 104 (varCte -> DEC pointDEC .)


state 151

    (105) varCte -> STRING pointSTRING .

    CSQUAREBR       reduce using rule 105 (varCte -> STRING pointSTRING .)
    MULTIPLY        reduce using rule 105 (varCte -> STRING pointSTRING .)
    DIVIDE          reduce using rule 105 (varCte -> STRING pointSTRING .)
    PLUS            reduce using rule 105 (varCte -> STRING pointSTRING .)
    MINUS           reduce using rule 105 (varCte -> STRING pointSTRING .)
    EQUAL           reduce using rule 105 (varCte -> STRING pointSTRING .)
    DIFFERENT       reduce using rule 105 (varCte -> STRING pointSTRING .)
    GREATERTHAN     reduce using rule 105 (varCte -> STRING pointSTRING .)
    GREATERTHANEQ   reduce using rule 105 (varCte -> STRING pointSTRING .)
    LESSTHAN        reduce using rule 105 (varCte -> STRING pointSTRING .)
    LESSTHANEQ      reduce using rule 105 (varCte -> STRING pointSTRING .)
    CPAREN          reduce using rule 105 (varCte -> STRING pointSTRING .)
    EOF             reduce using rule 105 (varCte -> STRING pointSTRING .)
    COLON           reduce using rule 105 (varCte -> STRING pointSTRING .)


state 152

    (106) varCte -> TRUE pointBOOL .

    CSQUAREBR       reduce using rule 106 (varCte -> TRUE pointBOOL .)
    MULTIPLY        reduce using rule 106 (varCte -> TRUE pointBOOL .)
    DIVIDE          reduce using rule 106 (varCte -> TRUE pointBOOL .)
    PLUS            reduce using rule 106 (varCte -> TRUE pointBOOL .)
    MINUS           reduce using rule 106 (varCte -> TRUE pointBOOL .)
    EQUAL           reduce using rule 106 (varCte -> TRUE pointBOOL .)
    DIFFERENT       reduce using rule 106 (varCte -> TRUE pointBOOL .)
    GREATERTHAN     reduce using rule 106 (varCte -> TRUE pointBOOL .)
    GREATERTHANEQ   reduce using rule 106 (varCte -> TRUE pointBOOL .)
    LESSTHAN        reduce using rule 106 (varCte -> TRUE pointBOOL .)
    LESSTHANEQ      reduce using rule 106 (varCte -> TRUE pointBOOL .)
    CPAREN          reduce using rule 106 (varCte -> TRUE pointBOOL .)
    EOF             reduce using rule 106 (varCte -> TRUE pointBOOL .)
    COLON           reduce using rule 106 (varCte -> TRUE pointBOOL .)


state 153

    (107) varCte -> FALSE pointBOOL .

    CSQUAREBR       reduce using rule 107 (varCte -> FALSE pointBOOL .)
    MULTIPLY        reduce using rule 107 (varCte -> FALSE pointBOOL .)
    DIVIDE          reduce using rule 107 (varCte -> FALSE pointBOOL .)
    PLUS            reduce using rule 107 (varCte -> FALSE pointBOOL .)
    MINUS           reduce using rule 107 (varCte -> FALSE pointBOOL .)
    EQUAL           reduce using rule 107 (varCte -> FALSE pointBOOL .)
    DIFFERENT       reduce using rule 107 (varCte -> FALSE pointBOOL .)
    GREATERTHAN     reduce using rule 107 (varCte -> FALSE pointBOOL .)
    GREATERTHANEQ   reduce using rule 107 (varCte -> FALSE pointBOOL .)
    LESSTHAN        reduce using rule 107 (varCte -> FALSE pointBOOL .)
    LESSTHANEQ      reduce using rule 107 (varCte -> FALSE pointBOOL .)
    CPAREN          reduce using rule 107 (varCte -> FALSE pointBOOL .)
    EOF             reduce using rule 107 (varCte -> FALSE pointBOOL .)
    COLON           reduce using rule 107 (varCte -> FALSE pointBOOL .)


state 154

    (61) assignmentDef -> arr ASSIGNMENT pointPushAssignment expAssignment .

    VAR             reduce using rule 61 (assignmentDef -> arr ASSIGNMENT pointPushAssignment expAssignment .)
    ID              reduce using rule 61 (assignmentDef -> arr ASSIGNMENT pointPushAssignment expAssignment .)
    INPUT           reduce using rule 61 (assignmentDef -> arr ASSIGNMENT pointPushAssignment expAssignment .)
    OUTPUT          reduce using rule 61 (assignmentDef -> arr ASSIGNMENT pointPushAssignment expAssignment .)
    WHILE           reduce using rule 61 (assignmentDef -> arr ASSIGNMENT pointPushAssignment expAssignment .)
    IF              reduce using rule 61 (assignmentDef -> arr ASSIGNMENT pointPushAssignment expAssignment .)
    CBRACKET        reduce using rule 61 (assignmentDef -> arr ASSIGNMENT pointPushAssignment expAssignment .)
    RETURN          reduce using rule 61 (assignmentDef -> arr ASSIGNMENT pointPushAssignment expAssignment .)


state 155

    (123) input -> INPUT OPAREN ID CPAREN . EOF

    EOF             shift and go to state 187


state 156

    (88) expParen -> OPAREN pointFakeBackground . expRelational CPAREN pointRemoveFakeBackground
    (69) expRelational -> . plusMinus
    (70) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (78) plusMinus -> . multDiv pointCheckPlusMinus
    (79) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (80) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (83) multDiv -> . expParen pointCheckMultDiv
    (84) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (88) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (89) expParen -> . varCte
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    OPAREN          shift and go to state 119
    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 109

    expRelational                  shift and go to state 188
    plusMinus                      shift and go to state 121
    multDiv                        shift and go to state 122
    expParen                       shift and go to state 123
    varCte                         shift and go to state 124
    arr                            shift and go to state 116

state 157

    (124) output -> OUTPUT OPAREN expRelational CPAREN . EOF

    EOF             shift and go to state 189


state 158

    (70) expRelational -> plusMinus opRelational . expRelational pointCheckOpRel
    (69) expRelational -> . plusMinus
    (70) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (78) plusMinus -> . multDiv pointCheckPlusMinus
    (79) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (80) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (83) multDiv -> . expParen pointCheckMultDiv
    (84) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (88) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (89) expParen -> . varCte
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    OPAREN          shift and go to state 119
    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 109

    plusMinus                      shift and go to state 121
    expRelational                  shift and go to state 190
    multDiv                        shift and go to state 122
    expParen                       shift and go to state 123
    varCte                         shift and go to state 124
    arr                            shift and go to state 116

state 159

    (72) opRelational -> EQUAL .

    OPAREN          reduce using rule 72 (opRelational -> EQUAL .)
    INT             reduce using rule 72 (opRelational -> EQUAL .)
    DEC             reduce using rule 72 (opRelational -> EQUAL .)
    STRING          reduce using rule 72 (opRelational -> EQUAL .)
    TRUE            reduce using rule 72 (opRelational -> EQUAL .)
    FALSE           reduce using rule 72 (opRelational -> EQUAL .)
    ID              reduce using rule 72 (opRelational -> EQUAL .)


state 160

    (73) opRelational -> DIFFERENT .

    OPAREN          reduce using rule 73 (opRelational -> DIFFERENT .)
    INT             reduce using rule 73 (opRelational -> DIFFERENT .)
    DEC             reduce using rule 73 (opRelational -> DIFFERENT .)
    STRING          reduce using rule 73 (opRelational -> DIFFERENT .)
    TRUE            reduce using rule 73 (opRelational -> DIFFERENT .)
    FALSE           reduce using rule 73 (opRelational -> DIFFERENT .)
    ID              reduce using rule 73 (opRelational -> DIFFERENT .)


state 161

    (74) opRelational -> GREATERTHAN .

    OPAREN          reduce using rule 74 (opRelational -> GREATERTHAN .)
    INT             reduce using rule 74 (opRelational -> GREATERTHAN .)
    DEC             reduce using rule 74 (opRelational -> GREATERTHAN .)
    STRING          reduce using rule 74 (opRelational -> GREATERTHAN .)
    TRUE            reduce using rule 74 (opRelational -> GREATERTHAN .)
    FALSE           reduce using rule 74 (opRelational -> GREATERTHAN .)
    ID              reduce using rule 74 (opRelational -> GREATERTHAN .)


state 162

    (75) opRelational -> GREATERTHANEQ .

    OPAREN          reduce using rule 75 (opRelational -> GREATERTHANEQ .)
    INT             reduce using rule 75 (opRelational -> GREATERTHANEQ .)
    DEC             reduce using rule 75 (opRelational -> GREATERTHANEQ .)
    STRING          reduce using rule 75 (opRelational -> GREATERTHANEQ .)
    TRUE            reduce using rule 75 (opRelational -> GREATERTHANEQ .)
    FALSE           reduce using rule 75 (opRelational -> GREATERTHANEQ .)
    ID              reduce using rule 75 (opRelational -> GREATERTHANEQ .)


state 163

    (76) opRelational -> LESSTHAN .

    OPAREN          reduce using rule 76 (opRelational -> LESSTHAN .)
    INT             reduce using rule 76 (opRelational -> LESSTHAN .)
    DEC             reduce using rule 76 (opRelational -> LESSTHAN .)
    STRING          reduce using rule 76 (opRelational -> LESSTHAN .)
    TRUE            reduce using rule 76 (opRelational -> LESSTHAN .)
    FALSE           reduce using rule 76 (opRelational -> LESSTHAN .)
    ID              reduce using rule 76 (opRelational -> LESSTHAN .)


state 164

    (77) opRelational -> LESSTHANEQ .

    OPAREN          reduce using rule 77 (opRelational -> LESSTHANEQ .)
    INT             reduce using rule 77 (opRelational -> LESSTHANEQ .)
    DEC             reduce using rule 77 (opRelational -> LESSTHANEQ .)
    STRING          reduce using rule 77 (opRelational -> LESSTHANEQ .)
    TRUE            reduce using rule 77 (opRelational -> LESSTHANEQ .)
    FALSE           reduce using rule 77 (opRelational -> LESSTHANEQ .)
    ID              reduce using rule 77 (opRelational -> LESSTHANEQ .)


state 165

    (78) plusMinus -> multDiv pointCheckPlusMinus .
    (79) plusMinus -> multDiv pointCheckPlusMinus . PLUS pointPushPlusMinus plusMinus
    (80) plusMinus -> multDiv pointCheckPlusMinus . MINUS pointPushPlusMinus plusMinus

    EQUAL           reduce using rule 78 (plusMinus -> multDiv pointCheckPlusMinus .)
    DIFFERENT       reduce using rule 78 (plusMinus -> multDiv pointCheckPlusMinus .)
    GREATERTHAN     reduce using rule 78 (plusMinus -> multDiv pointCheckPlusMinus .)
    GREATERTHANEQ   reduce using rule 78 (plusMinus -> multDiv pointCheckPlusMinus .)
    LESSTHAN        reduce using rule 78 (plusMinus -> multDiv pointCheckPlusMinus .)
    LESSTHANEQ      reduce using rule 78 (plusMinus -> multDiv pointCheckPlusMinus .)
    CPAREN          reduce using rule 78 (plusMinus -> multDiv pointCheckPlusMinus .)
    EOF             reduce using rule 78 (plusMinus -> multDiv pointCheckPlusMinus .)
    PLUS            shift and go to state 191
    MINUS           shift and go to state 192


state 166

    (83) multDiv -> expParen pointCheckMultDiv .
    (84) multDiv -> expParen pointCheckMultDiv . MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> expParen pointCheckMultDiv . DIVIDE pointPushMultDiv multDiv

    PLUS            reduce using rule 83 (multDiv -> expParen pointCheckMultDiv .)
    MINUS           reduce using rule 83 (multDiv -> expParen pointCheckMultDiv .)
    EQUAL           reduce using rule 83 (multDiv -> expParen pointCheckMultDiv .)
    DIFFERENT       reduce using rule 83 (multDiv -> expParen pointCheckMultDiv .)
    GREATERTHAN     reduce using rule 83 (multDiv -> expParen pointCheckMultDiv .)
    GREATERTHANEQ   reduce using rule 83 (multDiv -> expParen pointCheckMultDiv .)
    LESSTHAN        reduce using rule 83 (multDiv -> expParen pointCheckMultDiv .)
    LESSTHANEQ      reduce using rule 83 (multDiv -> expParen pointCheckMultDiv .)
    CPAREN          reduce using rule 83 (multDiv -> expParen pointCheckMultDiv .)
    EOF             reduce using rule 83 (multDiv -> expParen pointCheckMultDiv .)
    MULTIPLY        shift and go to state 193
    DIVIDE          shift and go to state 194


state 167

    (114) whileCycle -> WHILE pointWhile1 OPAREN expRelational . CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3

    CPAREN          shift and go to state 195


state 168

    (118) ifCond -> IF OPAREN expRelational CPAREN . pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> IF OPAREN expRelational CPAREN . pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (120) pointIfCond1 -> .

    OBRACKET        reduce using rule 120 (pointIfCond1 -> .)

    pointIfCond1                   shift and go to state 196

state 169

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET . body CBRACKET pointEndFunc fxDef
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (126) epsilon -> .
    (60) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (61) assignmentDef -> . arr ASSIGNMENT pointPushAssignment expAssignment
    (123) input -> . INPUT OPAREN ID CPAREN EOF
    (124) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (114) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (118) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (100) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 126 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 59
    OUTPUT          shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62

    body                           shift and go to state 197
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56
    arr                            shift and go to state 58

state 170

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET . body CBRACKET pointEndFunc fxDef
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (126) epsilon -> .
    (60) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (61) assignmentDef -> . arr ASSIGNMENT pointPushAssignment expAssignment
    (123) input -> . INPUT OPAREN ID CPAREN EOF
    (124) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (114) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (118) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (100) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 126 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 59
    OUTPUT          shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62

    epsilon                        shift and go to state 48
    body                           shift and go to state 198
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56
    arr                            shift and go to state 58

state 171

    (20) param -> paramType ID pointParam COMMA . param
    (19) param -> . paramType ID pointParam
    (20) param -> . paramType ID pointParam COMMA param
    (21) paramType -> . INT
    (22) paramType -> . STRING
    (23) paramType -> . DEC
    (24) paramType -> . BOOL

    INT             shift and go to state 66
    STRING          shift and go to state 67
    DEC             shift and go to state 68
    BOOL            shift and go to state 69

    paramType                      shift and go to state 65
    param                          shift and go to state 199

state 172

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET . body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (126) epsilon -> .
    (60) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (61) assignmentDef -> . arr ASSIGNMENT pointPushAssignment expAssignment
    (123) input -> . INPUT OPAREN ID CPAREN EOF
    (124) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (114) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (118) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (100) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    VAR             shift and go to state 49
    RETURN          reduce using rule 126 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 59
    OUTPUT          shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62

    body                           shift and go to state 200
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56
    arr                            shift and go to state 58

state 173

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET . body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (126) epsilon -> .
    (60) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (61) assignmentDef -> . arr ASSIGNMENT pointPushAssignment expAssignment
    (123) input -> . INPUT OPAREN ID CPAREN EOF
    (124) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (114) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (118) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (100) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    VAR             shift and go to state 49
    RETURN          reduce using rule 126 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 59
    OUTPUT          shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62

    epsilon                        shift and go to state 48
    body                           shift and go to state 201
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56
    arr                            shift and go to state 58

state 174

    (92) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass . fxDef pointScopeClass2 CBRACKET classDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (126) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    CBRACKET        reduce using rule 126 (epsilon -> .)

    fxDef                          shift and go to state 202
    epsilon                        shift and go to state 12
    fxType                         shift and go to state 13

state 175

    (51) var -> varsType COMMA var .

    EOF             reduce using rule 51 (var -> varsType COMMA var .)


state 176

    (56) arrDef -> ID OSQUAREBR INT . COLON INT CSQUAREBR

    COLON           shift and go to state 203


state 177

    (59) matrixDef -> arrDef OSQUAREBR varCte . COLON varCte CSQUAREBR

    COLON           shift and go to state 204


state 178

    (66) returnCall -> ID pointEra . OPAREN paramCall pointGoSub CPAREN
    (67) returnCall -> ID pointEra . OPAREN epsilon pointParamVacio pointGoSub CPAREN

    OPAREN          shift and go to state 205


state 179

    (63) expAssignment -> expRelational EOF .

    VAR             reduce using rule 63 (expAssignment -> expRelational EOF .)
    ID              reduce using rule 63 (expAssignment -> expRelational EOF .)
    INPUT           reduce using rule 63 (expAssignment -> expRelational EOF .)
    OUTPUT          reduce using rule 63 (expAssignment -> expRelational EOF .)
    WHILE           reduce using rule 63 (expAssignment -> expRelational EOF .)
    IF              reduce using rule 63 (expAssignment -> expRelational EOF .)
    CBRACKET        reduce using rule 63 (expAssignment -> expRelational EOF .)
    RETURN          reduce using rule 63 (expAssignment -> expRelational EOF .)


state 180

    (64) expAssignment -> returnCall EOF .

    VAR             reduce using rule 64 (expAssignment -> returnCall EOF .)
    ID              reduce using rule 64 (expAssignment -> returnCall EOF .)
    INPUT           reduce using rule 64 (expAssignment -> returnCall EOF .)
    OUTPUT          reduce using rule 64 (expAssignment -> returnCall EOF .)
    WHILE           reduce using rule 64 (expAssignment -> returnCall EOF .)
    IF              reduce using rule 64 (expAssignment -> returnCall EOF .)
    CBRACKET        reduce using rule 64 (expAssignment -> returnCall EOF .)
    RETURN          reduce using rule 64 (expAssignment -> returnCall EOF .)


state 181

    (26) paramCall -> ID pointParamCall . pointParamNum
    (27) paramCall -> ID pointParamCall . COMMA paramCall
    (28) pointParamNum -> .

    COMMA           shift and go to state 207
    CPAREN          reduce using rule 28 (pointParamNum -> .)

    pointParamNum                  shift and go to state 206

state 182

    (30) voidCall -> ID pointEra OPAREN paramCall pointGoSub . CPAREN EOF

    CPAREN          shift and go to state 208


state 183

    (31) voidCall -> ID pointEra OPAREN epsilon pointParamVacio . pointGoSub CPAREN EOF
    (33) pointGoSub -> .

    CPAREN          reduce using rule 33 (pointGoSub -> .)

    pointGoSub                     shift and go to state 209

state 184

    (100) classCall -> ID MONEY ID OPAREN paramCall . CPAREN EOF

    CPAREN          shift and go to state 210


state 185

    (101) classCall -> ID MONEY ID OPAREN epsilon . CPAREN EOF

    CPAREN          shift and go to state 211


state 186

    (57) arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .

    ASSIGNMENT      reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    CSQUAREBR       reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    MULTIPLY        reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    DIVIDE          reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    PLUS            reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    MINUS           reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    EQUAL           reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    DIFFERENT       reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    GREATERTHAN     reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    GREATERTHANEQ   reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    LESSTHAN        reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    LESSTHANEQ      reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    CPAREN          reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    EOF             reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)
    COLON           reduce using rule 57 (arr -> ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR .)


state 187

    (123) input -> INPUT OPAREN ID CPAREN EOF .

    VAR             reduce using rule 123 (input -> INPUT OPAREN ID CPAREN EOF .)
    ID              reduce using rule 123 (input -> INPUT OPAREN ID CPAREN EOF .)
    INPUT           reduce using rule 123 (input -> INPUT OPAREN ID CPAREN EOF .)
    OUTPUT          reduce using rule 123 (input -> INPUT OPAREN ID CPAREN EOF .)
    WHILE           reduce using rule 123 (input -> INPUT OPAREN ID CPAREN EOF .)
    IF              reduce using rule 123 (input -> INPUT OPAREN ID CPAREN EOF .)
    CBRACKET        reduce using rule 123 (input -> INPUT OPAREN ID CPAREN EOF .)
    RETURN          reduce using rule 123 (input -> INPUT OPAREN ID CPAREN EOF .)


state 188

    (88) expParen -> OPAREN pointFakeBackground expRelational . CPAREN pointRemoveFakeBackground

    CPAREN          shift and go to state 212


state 189

    (124) output -> OUTPUT OPAREN expRelational CPAREN EOF .

    VAR             reduce using rule 124 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    ID              reduce using rule 124 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    INPUT           reduce using rule 124 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    OUTPUT          reduce using rule 124 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    WHILE           reduce using rule 124 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    IF              reduce using rule 124 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    CBRACKET        reduce using rule 124 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    RETURN          reduce using rule 124 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)


state 190

    (70) expRelational -> plusMinus opRelational expRelational . pointCheckOpRel
    (71) pointCheckOpRel -> .

    CPAREN          reduce using rule 71 (pointCheckOpRel -> .)
    EOF             reduce using rule 71 (pointCheckOpRel -> .)

    pointCheckOpRel                shift and go to state 213

state 191

    (79) plusMinus -> multDiv pointCheckPlusMinus PLUS . pointPushPlusMinus plusMinus
    (82) pointPushPlusMinus -> .

    OPAREN          reduce using rule 82 (pointPushPlusMinus -> .)
    INT             reduce using rule 82 (pointPushPlusMinus -> .)
    DEC             reduce using rule 82 (pointPushPlusMinus -> .)
    STRING          reduce using rule 82 (pointPushPlusMinus -> .)
    TRUE            reduce using rule 82 (pointPushPlusMinus -> .)
    FALSE           reduce using rule 82 (pointPushPlusMinus -> .)
    ID              reduce using rule 82 (pointPushPlusMinus -> .)

    pointPushPlusMinus             shift and go to state 214

state 192

    (80) plusMinus -> multDiv pointCheckPlusMinus MINUS . pointPushPlusMinus plusMinus
    (82) pointPushPlusMinus -> .

    OPAREN          reduce using rule 82 (pointPushPlusMinus -> .)
    INT             reduce using rule 82 (pointPushPlusMinus -> .)
    DEC             reduce using rule 82 (pointPushPlusMinus -> .)
    STRING          reduce using rule 82 (pointPushPlusMinus -> .)
    TRUE            reduce using rule 82 (pointPushPlusMinus -> .)
    FALSE           reduce using rule 82 (pointPushPlusMinus -> .)
    ID              reduce using rule 82 (pointPushPlusMinus -> .)

    pointPushPlusMinus             shift and go to state 215

state 193

    (84) multDiv -> expParen pointCheckMultDiv MULTIPLY . pointPushMultDiv multDiv
    (87) pointPushMultDiv -> .

    OPAREN          reduce using rule 87 (pointPushMultDiv -> .)
    INT             reduce using rule 87 (pointPushMultDiv -> .)
    DEC             reduce using rule 87 (pointPushMultDiv -> .)
    STRING          reduce using rule 87 (pointPushMultDiv -> .)
    TRUE            reduce using rule 87 (pointPushMultDiv -> .)
    FALSE           reduce using rule 87 (pointPushMultDiv -> .)
    ID              reduce using rule 87 (pointPushMultDiv -> .)

    pointPushMultDiv               shift and go to state 216

state 194

    (85) multDiv -> expParen pointCheckMultDiv DIVIDE . pointPushMultDiv multDiv
    (87) pointPushMultDiv -> .

    OPAREN          reduce using rule 87 (pointPushMultDiv -> .)
    INT             reduce using rule 87 (pointPushMultDiv -> .)
    DEC             reduce using rule 87 (pointPushMultDiv -> .)
    STRING          reduce using rule 87 (pointPushMultDiv -> .)
    TRUE            reduce using rule 87 (pointPushMultDiv -> .)
    FALSE           reduce using rule 87 (pointPushMultDiv -> .)
    ID              reduce using rule 87 (pointPushMultDiv -> .)

    pointPushMultDiv               shift and go to state 217

state 195

    (114) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN . pointWhile2 OBRACKET body CBRACKET pointWhile3
    (116) pointWhile2 -> .

    OBRACKET        reduce using rule 116 (pointWhile2 -> .)

    pointWhile2                    shift and go to state 218

state 196

    (118) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 . OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 . OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    OBRACKET        shift and go to state 219


state 197

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 220


state 198

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 221


state 199

    (20) param -> paramType ID pointParam COMMA param .

    CPAREN          reduce using rule 20 (param -> paramType ID pointParam COMMA param .)


state 200

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body . RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    RETURN          shift and go to state 222


state 201

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body . RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    RETURN          shift and go to state 223


state 202

    (92) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef . pointScopeClass2 CBRACKET classDef
    (97) pointScopeClass2 -> .

    CBRACKET        reduce using rule 97 (pointScopeClass2 -> .)

    pointScopeClass2               shift and go to state 224

state 203

    (56) arrDef -> ID OSQUAREBR INT COLON . INT CSQUAREBR

    INT             shift and go to state 225


state 204

    (59) matrixDef -> arrDef OSQUAREBR varCte COLON . varCte CSQUAREBR
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 109

    varCte                         shift and go to state 226
    arr                            shift and go to state 116

state 205

    (66) returnCall -> ID pointEra OPAREN . paramCall pointGoSub CPAREN
    (67) returnCall -> ID pointEra OPAREN . epsilon pointParamVacio pointGoSub CPAREN
    (26) paramCall -> . ID pointParamCall pointParamNum
    (27) paramCall -> . ID pointParamCall COMMA paramCall
    (126) epsilon -> .

    ID              shift and go to state 144
    CPAREN          reduce using rule 126 (epsilon -> .)

    paramCall                      shift and go to state 227
    epsilon                        shift and go to state 228

state 206

    (26) paramCall -> ID pointParamCall pointParamNum .

    CPAREN          reduce using rule 26 (paramCall -> ID pointParamCall pointParamNum .)


state 207

    (27) paramCall -> ID pointParamCall COMMA . paramCall
    (26) paramCall -> . ID pointParamCall pointParamNum
    (27) paramCall -> . ID pointParamCall COMMA paramCall

    ID              shift and go to state 144

    paramCall                      shift and go to state 229

state 208

    (30) voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN . EOF

    EOF             shift and go to state 230


state 209

    (31) voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub . CPAREN EOF

    CPAREN          shift and go to state 231


state 210

    (100) classCall -> ID MONEY ID OPAREN paramCall CPAREN . EOF

    EOF             shift and go to state 232


state 211

    (101) classCall -> ID MONEY ID OPAREN epsilon CPAREN . EOF

    EOF             shift and go to state 233


state 212

    (88) expParen -> OPAREN pointFakeBackground expRelational CPAREN . pointRemoveFakeBackground
    (91) pointRemoveFakeBackground -> .

    MULTIPLY        reduce using rule 91 (pointRemoveFakeBackground -> .)
    DIVIDE          reduce using rule 91 (pointRemoveFakeBackground -> .)
    PLUS            reduce using rule 91 (pointRemoveFakeBackground -> .)
    MINUS           reduce using rule 91 (pointRemoveFakeBackground -> .)
    EQUAL           reduce using rule 91 (pointRemoveFakeBackground -> .)
    DIFFERENT       reduce using rule 91 (pointRemoveFakeBackground -> .)
    GREATERTHAN     reduce using rule 91 (pointRemoveFakeBackground -> .)
    GREATERTHANEQ   reduce using rule 91 (pointRemoveFakeBackground -> .)
    LESSTHAN        reduce using rule 91 (pointRemoveFakeBackground -> .)
    LESSTHANEQ      reduce using rule 91 (pointRemoveFakeBackground -> .)
    CPAREN          reduce using rule 91 (pointRemoveFakeBackground -> .)
    EOF             reduce using rule 91 (pointRemoveFakeBackground -> .)

    pointRemoveFakeBackground      shift and go to state 234

state 213

    (70) expRelational -> plusMinus opRelational expRelational pointCheckOpRel .

    CPAREN          reduce using rule 70 (expRelational -> plusMinus opRelational expRelational pointCheckOpRel .)
    EOF             reduce using rule 70 (expRelational -> plusMinus opRelational expRelational pointCheckOpRel .)


state 214

    (79) plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus . plusMinus
    (78) plusMinus -> . multDiv pointCheckPlusMinus
    (79) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (80) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (83) multDiv -> . expParen pointCheckMultDiv
    (84) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (88) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (89) expParen -> . varCte
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    OPAREN          shift and go to state 119
    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 109

    multDiv                        shift and go to state 122
    plusMinus                      shift and go to state 235
    expParen                       shift and go to state 123
    varCte                         shift and go to state 124
    arr                            shift and go to state 116

state 215

    (80) plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus . plusMinus
    (78) plusMinus -> . multDiv pointCheckPlusMinus
    (79) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (80) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (83) multDiv -> . expParen pointCheckMultDiv
    (84) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (88) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (89) expParen -> . varCte
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    OPAREN          shift and go to state 119
    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 109

    multDiv                        shift and go to state 122
    plusMinus                      shift and go to state 236
    expParen                       shift and go to state 123
    varCte                         shift and go to state 124
    arr                            shift and go to state 116

state 216

    (84) multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv . multDiv
    (83) multDiv -> . expParen pointCheckMultDiv
    (84) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (88) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (89) expParen -> . varCte
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    OPAREN          shift and go to state 119
    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 109

    expParen                       shift and go to state 123
    multDiv                        shift and go to state 237
    varCte                         shift and go to state 124
    arr                            shift and go to state 116

state 217

    (85) multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv . multDiv
    (83) multDiv -> . expParen pointCheckMultDiv
    (84) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (85) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (88) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (89) expParen -> . varCte
    (103) varCte -> . INT pointINT
    (104) varCte -> . DEC pointDEC
    (105) varCte -> . STRING pointSTRING
    (106) varCte -> . TRUE pointBOOL
    (107) varCte -> . FALSE pointBOOL
    (108) varCte -> . ID
    (109) varCte -> . arr
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    OPAREN          shift and go to state 119
    INT             shift and go to state 111
    DEC             shift and go to state 112
    STRING          shift and go to state 113
    TRUE            shift and go to state 114
    FALSE           shift and go to state 115
    ID              shift and go to state 109

    expParen                       shift and go to state 123
    multDiv                        shift and go to state 238
    varCte                         shift and go to state 124
    arr                            shift and go to state 116

state 218

    (114) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 . OBRACKET body CBRACKET pointWhile3

    OBRACKET        shift and go to state 239


state 219

    (118) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET . body CBRACKET pointIfCond2
    (119) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET . body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (126) epsilon -> .
    (60) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (61) assignmentDef -> . arr ASSIGNMENT pointPushAssignment expAssignment
    (123) input -> . INPUT OPAREN ID CPAREN EOF
    (124) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (114) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (118) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (100) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 126 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 59
    OUTPUT          shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62

    body                           shift and go to state 240
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56
    arr                            shift and go to state 58

state 220

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET . pointEndFunc fxDef
    (18) pointEndFunc -> .

    VOID            reduce using rule 18 (pointEndFunc -> .)
    INT             reduce using rule 18 (pointEndFunc -> .)
    STRING          reduce using rule 18 (pointEndFunc -> .)
    DEC             reduce using rule 18 (pointEndFunc -> .)
    BOOL            reduce using rule 18 (pointEndFunc -> .)
    MAIN            reduce using rule 18 (pointEndFunc -> .)
    CBRACKET        reduce using rule 18 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 241

state 221

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET . pointEndFunc fxDef
    (18) pointEndFunc -> .

    VOID            reduce using rule 18 (pointEndFunc -> .)
    INT             reduce using rule 18 (pointEndFunc -> .)
    STRING          reduce using rule 18 (pointEndFunc -> .)
    DEC             reduce using rule 18 (pointEndFunc -> .)
    BOOL            reduce using rule 18 (pointEndFunc -> .)
    MAIN            reduce using rule 18 (pointEndFunc -> .)
    CBRACKET        reduce using rule 18 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 242

state 222

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN . ID pointReturn EOF CBRACKET pointEndFunc fxDef

    ID              shift and go to state 243


state 223

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN . ID pointReturn EOF CBRACKET pointEndFunc fxDef

    ID              shift and go to state 244


state 224

    (92) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 . CBRACKET classDef

    CBRACKET        shift and go to state 245


state 225

    (56) arrDef -> ID OSQUAREBR INT COLON INT . CSQUAREBR

    CSQUAREBR       shift and go to state 246


state 226

    (59) matrixDef -> arrDef OSQUAREBR varCte COLON varCte . CSQUAREBR

    CSQUAREBR       shift and go to state 247


state 227

    (66) returnCall -> ID pointEra OPAREN paramCall . pointGoSub CPAREN
    (33) pointGoSub -> .

    CPAREN          reduce using rule 33 (pointGoSub -> .)

    pointGoSub                     shift and go to state 248

state 228

    (67) returnCall -> ID pointEra OPAREN epsilon . pointParamVacio pointGoSub CPAREN
    (68) pointParamVacio -> .

    CPAREN          reduce using rule 68 (pointParamVacio -> .)

    pointParamVacio                shift and go to state 249

state 229

    (27) paramCall -> ID pointParamCall COMMA paramCall .

    CPAREN          reduce using rule 27 (paramCall -> ID pointParamCall COMMA paramCall .)


state 230

    (30) voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .

    VAR             reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    ID              reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    INPUT           reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    OUTPUT          reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    WHILE           reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    IF              reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    CBRACKET        reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    RETURN          reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)


state 231

    (31) voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN . EOF

    EOF             shift and go to state 250


state 232

    (100) classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .

    VAR             reduce using rule 100 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    ID              reduce using rule 100 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    INPUT           reduce using rule 100 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    OUTPUT          reduce using rule 100 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    WHILE           reduce using rule 100 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    IF              reduce using rule 100 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    CBRACKET        reduce using rule 100 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    RETURN          reduce using rule 100 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)


state 233

    (101) classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .

    VAR             reduce using rule 101 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    ID              reduce using rule 101 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    INPUT           reduce using rule 101 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    OUTPUT          reduce using rule 101 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    WHILE           reduce using rule 101 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    IF              reduce using rule 101 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    CBRACKET        reduce using rule 101 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    RETURN          reduce using rule 101 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)


state 234

    (88) expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .

    MULTIPLY        reduce using rule 88 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    DIVIDE          reduce using rule 88 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    PLUS            reduce using rule 88 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    MINUS           reduce using rule 88 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    EQUAL           reduce using rule 88 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    DIFFERENT       reduce using rule 88 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    GREATERTHAN     reduce using rule 88 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    GREATERTHANEQ   reduce using rule 88 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    LESSTHAN        reduce using rule 88 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    LESSTHANEQ      reduce using rule 88 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    CPAREN          reduce using rule 88 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    EOF             reduce using rule 88 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)


state 235

    (79) plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .

    EQUAL           reduce using rule 79 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    DIFFERENT       reduce using rule 79 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    GREATERTHAN     reduce using rule 79 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    GREATERTHANEQ   reduce using rule 79 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    LESSTHAN        reduce using rule 79 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    LESSTHANEQ      reduce using rule 79 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    CPAREN          reduce using rule 79 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    EOF             reduce using rule 79 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)


state 236

    (80) plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .

    EQUAL           reduce using rule 80 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    DIFFERENT       reduce using rule 80 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    GREATERTHAN     reduce using rule 80 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    GREATERTHANEQ   reduce using rule 80 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    LESSTHAN        reduce using rule 80 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    LESSTHANEQ      reduce using rule 80 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    CPAREN          reduce using rule 80 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    EOF             reduce using rule 80 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)


state 237

    (84) multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .

    PLUS            reduce using rule 84 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    MINUS           reduce using rule 84 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    EQUAL           reduce using rule 84 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    DIFFERENT       reduce using rule 84 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    GREATERTHAN     reduce using rule 84 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    GREATERTHANEQ   reduce using rule 84 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    LESSTHAN        reduce using rule 84 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    LESSTHANEQ      reduce using rule 84 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    CPAREN          reduce using rule 84 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    EOF             reduce using rule 84 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)


state 238

    (85) multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .

    PLUS            reduce using rule 85 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    MINUS           reduce using rule 85 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    EQUAL           reduce using rule 85 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    DIFFERENT       reduce using rule 85 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    GREATERTHAN     reduce using rule 85 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    GREATERTHANEQ   reduce using rule 85 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    LESSTHAN        reduce using rule 85 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    LESSTHANEQ      reduce using rule 85 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    CPAREN          reduce using rule 85 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    EOF             reduce using rule 85 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)


state 239

    (114) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET . body CBRACKET pointWhile3
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (126) epsilon -> .
    (60) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (61) assignmentDef -> . arr ASSIGNMENT pointPushAssignment expAssignment
    (123) input -> . INPUT OPAREN ID CPAREN EOF
    (124) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (114) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (118) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (100) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 126 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 59
    OUTPUT          shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62

    body                           shift and go to state 251
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56
    arr                            shift and go to state 58

state 240

    (118) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body . CBRACKET pointIfCond2
    (119) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body . CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    CBRACKET        shift and go to state 252


state 241

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (126) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 126 (epsilon -> .)
    CBRACKET        reduce using rule 126 (epsilon -> .)

    fxDef                          shift and go to state 253
    epsilon                        shift and go to state 12
    fxType                         shift and go to state 13

state 242

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (126) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 126 (epsilon -> .)
    CBRACKET        reduce using rule 126 (epsilon -> .)

    epsilon                        shift and go to state 12
    fxDef                          shift and go to state 254
    fxType                         shift and go to state 13

state 243

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID . pointReturn EOF CBRACKET pointEndFunc fxDef
    (16) pointReturn -> .

    EOF             reduce using rule 16 (pointReturn -> .)

    pointReturn                    shift and go to state 255

state 244

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID . pointReturn EOF CBRACKET pointEndFunc fxDef
    (16) pointReturn -> .

    EOF             reduce using rule 16 (pointReturn -> .)

    pointReturn                    shift and go to state 256

state 245

    (92) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET . classDef
    (92) classDef -> . CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (93) classDef -> . epsilon
    (126) epsilon -> .

    CLASS           shift and go to state 8
    VOID            reduce using rule 126 (epsilon -> .)
    INT             reduce using rule 126 (epsilon -> .)
    STRING          reduce using rule 126 (epsilon -> .)
    DEC             reduce using rule 126 (epsilon -> .)
    BOOL            reduce using rule 126 (epsilon -> .)
    MAIN            reduce using rule 126 (epsilon -> .)

    classDef                       shift and go to state 257
    epsilon                        shift and go to state 9

state 246

    (56) arrDef -> ID OSQUAREBR INT COLON INT CSQUAREBR .

    OSQUAREBR       reduce using rule 56 (arrDef -> ID OSQUAREBR INT COLON INT CSQUAREBR .)
    COMMA           reduce using rule 56 (arrDef -> ID OSQUAREBR INT COLON INT CSQUAREBR .)
    EOF             reduce using rule 56 (arrDef -> ID OSQUAREBR INT COLON INT CSQUAREBR .)


state 247

    (59) matrixDef -> arrDef OSQUAREBR varCte COLON varCte CSQUAREBR .

    COMMA           reduce using rule 59 (matrixDef -> arrDef OSQUAREBR varCte COLON varCte CSQUAREBR .)
    EOF             reduce using rule 59 (matrixDef -> arrDef OSQUAREBR varCte COLON varCte CSQUAREBR .)


state 248

    (66) returnCall -> ID pointEra OPAREN paramCall pointGoSub . CPAREN

    CPAREN          shift and go to state 258


state 249

    (67) returnCall -> ID pointEra OPAREN epsilon pointParamVacio . pointGoSub CPAREN
    (33) pointGoSub -> .

    CPAREN          reduce using rule 33 (pointGoSub -> .)

    pointGoSub                     shift and go to state 259

state 250

    (31) voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .

    VAR             reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    ID              reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    INPUT           reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    OUTPUT          reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    WHILE           reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    IF              reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    CBRACKET        reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    RETURN          reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)


state 251

    (114) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body . CBRACKET pointWhile3

    CBRACKET        shift and go to state 260


state 252

    (118) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET . pointIfCond2
    (119) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET . ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (121) pointIfCond2 -> .

    ELSE            shift and go to state 262
    VAR             reduce using rule 121 (pointIfCond2 -> .)
    ID              reduce using rule 121 (pointIfCond2 -> .)
    INPUT           reduce using rule 121 (pointIfCond2 -> .)
    OUTPUT          reduce using rule 121 (pointIfCond2 -> .)
    WHILE           reduce using rule 121 (pointIfCond2 -> .)
    IF              reduce using rule 121 (pointIfCond2 -> .)
    CBRACKET        reduce using rule 121 (pointIfCond2 -> .)
    RETURN          reduce using rule 121 (pointIfCond2 -> .)

    pointIfCond2                   shift and go to state 261

state 253

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 5 (fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 5 (fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef .)


state 254

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 6 (fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 6 (fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef .)


state 255

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn . EOF CBRACKET pointEndFunc fxDef

    EOF             shift and go to state 263


state 256

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn . EOF CBRACKET pointEndFunc fxDef

    EOF             shift and go to state 264


state 257

    (92) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .

    VOID            reduce using rule 92 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    INT             reduce using rule 92 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    STRING          reduce using rule 92 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    DEC             reduce using rule 92 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    BOOL            reduce using rule 92 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    MAIN            reduce using rule 92 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)


state 258

    (66) returnCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN .

    EOF             reduce using rule 66 (returnCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN .)


state 259

    (67) returnCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub . CPAREN

    CPAREN          shift and go to state 265


state 260

    (114) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET . pointWhile3
    (117) pointWhile3 -> .

    VAR             reduce using rule 117 (pointWhile3 -> .)
    ID              reduce using rule 117 (pointWhile3 -> .)
    INPUT           reduce using rule 117 (pointWhile3 -> .)
    OUTPUT          reduce using rule 117 (pointWhile3 -> .)
    WHILE           reduce using rule 117 (pointWhile3 -> .)
    IF              reduce using rule 117 (pointWhile3 -> .)
    CBRACKET        reduce using rule 117 (pointWhile3 -> .)
    RETURN          reduce using rule 117 (pointWhile3 -> .)

    pointWhile3                    shift and go to state 266

state 261

    (118) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .

    VAR             reduce using rule 118 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    ID              reduce using rule 118 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    INPUT           reduce using rule 118 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    OUTPUT          reduce using rule 118 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    WHILE           reduce using rule 118 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    IF              reduce using rule 118 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    CBRACKET        reduce using rule 118 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    RETURN          reduce using rule 118 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)


state 262

    (119) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE . pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (122) pointIfCond3 -> .

    OBRACKET        reduce using rule 122 (pointIfCond3 -> .)

    pointIfCond3                   shift and go to state 267

state 263

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 268


state 264

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 269


state 265

    (67) returnCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN .

    EOF             reduce using rule 67 (returnCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN .)


state 266

    (114) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .

    VAR             reduce using rule 114 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    ID              reduce using rule 114 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    INPUT           reduce using rule 114 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    OUTPUT          reduce using rule 114 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    WHILE           reduce using rule 114 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    IF              reduce using rule 114 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    CBRACKET        reduce using rule 114 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    RETURN          reduce using rule 114 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)


state 267

    (119) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 . OBRACKET body CBRACKET pointIfCond2

    OBRACKET        shift and go to state 270


state 268

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET . pointEndFunc fxDef
    (18) pointEndFunc -> .

    VOID            reduce using rule 18 (pointEndFunc -> .)
    INT             reduce using rule 18 (pointEndFunc -> .)
    STRING          reduce using rule 18 (pointEndFunc -> .)
    DEC             reduce using rule 18 (pointEndFunc -> .)
    BOOL            reduce using rule 18 (pointEndFunc -> .)
    MAIN            reduce using rule 18 (pointEndFunc -> .)
    CBRACKET        reduce using rule 18 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 271

state 269

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET . pointEndFunc fxDef
    (18) pointEndFunc -> .

    VOID            reduce using rule 18 (pointEndFunc -> .)
    INT             reduce using rule 18 (pointEndFunc -> .)
    STRING          reduce using rule 18 (pointEndFunc -> .)
    DEC             reduce using rule 18 (pointEndFunc -> .)
    BOOL            reduce using rule 18 (pointEndFunc -> .)
    MAIN            reduce using rule 18 (pointEndFunc -> .)
    CBRACKET        reduce using rule 18 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 272

state 270

    (119) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET . body CBRACKET pointIfCond2
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (126) epsilon -> .
    (60) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (61) assignmentDef -> . arr ASSIGNMENT pointPushAssignment expAssignment
    (123) input -> . INPUT OPAREN ID CPAREN EOF
    (124) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (114) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (118) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (119) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (100) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (101) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (57) arr -> . ID OSQUAREBR varCte pointCheckTypeInt CSQUAREBR

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 126 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 59
    OUTPUT          shift and go to state 60
    WHILE           shift and go to state 61
    IF              shift and go to state 62

    body                           shift and go to state 273
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56
    arr                            shift and go to state 58

state 271

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (126) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 126 (epsilon -> .)
    CBRACKET        reduce using rule 126 (epsilon -> .)

    fxType                         shift and go to state 13
    fxDef                          shift and go to state 274
    epsilon                        shift and go to state 12

state 272

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (126) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 126 (epsilon -> .)
    CBRACKET        reduce using rule 126 (epsilon -> .)

    fxType                         shift and go to state 13
    epsilon                        shift and go to state 12
    fxDef                          shift and go to state 275

state 273

    (119) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body . CBRACKET pointIfCond2

    CBRACKET        shift and go to state 276


state 274

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 7 (fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 7 (fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)


state 275

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 8 (fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 8 (fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)


state 276

    (119) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET . pointIfCond2
    (121) pointIfCond2 -> .

    VAR             reduce using rule 121 (pointIfCond2 -> .)
    ID              reduce using rule 121 (pointIfCond2 -> .)
    INPUT           reduce using rule 121 (pointIfCond2 -> .)
    OUTPUT          reduce using rule 121 (pointIfCond2 -> .)
    WHILE           reduce using rule 121 (pointIfCond2 -> .)
    IF              reduce using rule 121 (pointIfCond2 -> .)
    CBRACKET        reduce using rule 121 (pointIfCond2 -> .)
    RETURN          reduce using rule 121 (pointIfCond2 -> .)

    pointIfCond2                   shift and go to state 277

state 277

    (119) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .

    VAR             reduce using rule 119 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    ID              reduce using rule 119 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    INPUT           reduce using rule 119 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    OUTPUT          reduce using rule 119 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    WHILE           reduce using rule 119 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    IF              reduce using rule 119 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    CBRACKET        reduce using rule 119 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    RETURN          reduce using rule 119 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)

