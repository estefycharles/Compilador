Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> begin
Rule 1     begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end
Rule 2     pointCreateMainCuac -> <empty>
Rule 3     pointMain -> <empty>
Rule 4     main -> MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET
Rule 5     fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
Rule 6     fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
Rule 7     fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
Rule 8     fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
Rule 9     fxDef -> epsilon
Rule 10    fxType -> INT
Rule 11    fxType -> STRING
Rule 12    fxType -> DEC
Rule 13    fxType -> BOOL
Rule 14    pointFx -> <empty>
Rule 15    pointFxId -> <empty>
Rule 16    pointReturn -> <empty>
Rule 17    pointParamCount -> <empty>
Rule 18    pointEndFunc -> <empty>
Rule 19    param -> paramType ID pointParam
Rule 20    param -> paramType ID pointParam COMMA param
Rule 21    paramType -> INT
Rule 22    paramType -> STRING
Rule 23    paramType -> DEC
Rule 24    paramType -> BOOL
Rule 25    pointParam -> <empty>
Rule 26    paramCall -> ID pointParamCall pointParamNum
Rule 27    paramCall -> ID pointParamCall COMMA paramCall
Rule 28    pointParamNum -> <empty>
Rule 29    pointParamCall -> <empty>
Rule 30    voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
Rule 31    voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
Rule 32    pointEra -> <empty>
Rule 33    pointGoSub -> <empty>
Rule 34    body -> varsDef body
Rule 35    body -> statements body
Rule 36    body -> epsilon
Rule 37    statements -> assignmentDef
Rule 38    statements -> input
Rule 39    statements -> output
Rule 40    statements -> voidCall
Rule 41    statements -> whileCycle
Rule 42    statements -> ifCond
Rule 43    statements -> classCall
Rule 44    varsDef -> VAR objType var EOF
Rule 45    varsDef -> VAR varSimpleType var EOF
Rule 46    varSimpleType -> INT
Rule 47    varSimpleType -> STRING
Rule 48    varSimpleType -> DEC
Rule 49    varSimpleType -> BOOL
Rule 50    var -> varsType
Rule 51    var -> varsType COMMA var
Rule 52    varsType -> ID
Rule 53    varsType -> arrDef
Rule 54    varsType -> matrixDef
Rule 55    arrDef -> ID OSQUAREBR varCte CSQUAREBR
Rule 56    matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR
Rule 57    assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment
Rule 58    pointPushAssignment -> <empty>
Rule 59    expAssignment -> expRelational EOF
Rule 60    expAssignment -> returnCall EOF
Rule 61    expAssignment -> classCall
Rule 62    returnCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN
Rule 63    returnCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN
Rule 64    pointParamVacio -> <empty>
Rule 65    expRelational -> plusMinus
Rule 66    expRelational -> plusMinus opRelational expRelational pointCheckOpRel
Rule 67    pointCheckOpRel -> <empty>
Rule 68    opRelational -> EQUAL
Rule 69    opRelational -> DIFFERENT
Rule 70    opRelational -> GREATERTHAN
Rule 71    opRelational -> GREATERTHANEQ
Rule 72    opRelational -> LESSTHAN
Rule 73    opRelational -> LESSTHANEQ
Rule 74    plusMinus -> multDiv pointCheckPlusMinus
Rule 75    plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
Rule 76    plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
Rule 77    pointCheckPlusMinus -> <empty>
Rule 78    pointPushPlusMinus -> <empty>
Rule 79    multDiv -> expParen pointCheckMultDiv
Rule 80    multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
Rule 81    multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
Rule 82    pointCheckMultDiv -> <empty>
Rule 83    pointPushMultDiv -> <empty>
Rule 84    expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
Rule 85    expParen -> varCte
Rule 86    pointFakeBackground -> <empty>
Rule 87    pointRemoveFakeBackground -> <empty>
Rule 88    classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
Rule 89    classDef -> epsilon
Rule 90    pointAtt -> varsDef
Rule 91    pointAtt -> varsDef pointAtt
Rule 92    pointScopeClass -> <empty>
Rule 93    pointScopeClass2 -> <empty>
Rule 94    pointClassName -> <empty>
Rule 95    pointClass -> <empty>
Rule 96    classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF
Rule 97    classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF
Rule 98    objType -> ID
Rule 99    varCte -> INT pointINT
Rule 100   varCte -> DEC pointDEC
Rule 101   varCte -> STRING pointSTRING
Rule 102   varCte -> TRUE pointBOOL
Rule 103   varCte -> FALSE pointBOOL
Rule 104   varCte -> ID
Rule 105   pointINT -> <empty>
Rule 106   pointDEC -> <empty>
Rule 107   pointSTRING -> <empty>
Rule 108   pointBOOL -> <empty>
Rule 109   whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
Rule 110   pointWhile1 -> <empty>
Rule 111   pointWhile2 -> <empty>
Rule 112   pointWhile3 -> <empty>
Rule 113   ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
Rule 114   ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
Rule 115   pointIfCond1 -> <empty>
Rule 116   pointIfCond2 -> <empty>
Rule 117   pointIfCond3 -> <empty>
Rule 118   input -> INPUT OPAREN ID CPAREN EOF
Rule 119   output -> OUTPUT OPAREN expRelational CPAREN EOF
Rule 120   end -> END OPAREN ID CPAREN
Rule 121   epsilon -> <empty>

Terminals, with rules where they appear

ASSIGNMENT           : 57
ATTRIBUTES           : 88
BEGIN                : 1
BOOL                 : 13 24 49
CBRACKET             : 4 5 6 7 8 88 109 113 114 114
CLASS                : 88
COLON                : 88 88
COMMA                : 20 27 51
CPAREN               : 1 4 5 6 7 8 30 31 62 63 84 96 97 109 113 114 118 119 120
CSQUAREBR            : 55 56
DEC                  : 12 23 48 100
DIFFERENT            : 69
DIVIDE               : 81
ELSE                 : 114
END                  : 120
EOF                  : 7 8 30 31 44 45 59 60 96 97 118 119
EQUAL                : 68
FALSE                : 103
FX                   : 5 6 7 8
GREATERTHAN          : 70
GREATERTHANEQ        : 71
ID                   : 1 5 6 7 7 8 8 19 20 26 27 30 31 52 55 57 62 63 88 96 96 97 97 98 104 118 120
IF                   : 113 114
INPUT                : 118
INT                  : 10 21 46 99
LESSTHAN             : 72
LESSTHANEQ           : 73
MAIN                 : 4
METHODS              : 88
MINUS                : 76
MONEY                : 96 97
MULTIPLY             : 80
OBRACKET             : 4 5 6 7 8 88 109 113 114 114
OPAREN               : 1 4 5 6 7 8 30 31 62 63 84 96 97 109 113 114 118 119 120
OSQUAREBR            : 55 56
OUTPUT               : 119
PLUS                 : 75
RETURN               : 7 8
STRING               : 11 22 47 101
TRUE                 : 102
VAR                  : 44 45
VOID                 : 5 6
WHILE                : 109
error                : 

Nonterminals, with rules where they appear

arrDef               : 53 56
assignmentDef        : 37
begin                : 0
body                 : 4 5 6 7 8 34 35 109 113 114 114
classCall            : 43 61
classDef             : 1 88
end                  : 1
epsilon              : 6 8 9 31 36 63 89 97
expAssignment        : 57
expParen             : 79 80 81
expRelational        : 59 66 84 109 113 114 119
fxDef                : 1 5 6 7 8 88
fxType               : 7 8
ifCond               : 42
input                : 38
main                 : 1
matrixDef            : 54
multDiv              : 74 75 76 80 81
objType              : 44
opRelational         : 66
output               : 39
param                : 5 7 20
paramCall            : 27 30 62 96
paramType            : 19 20
plusMinus            : 65 66 75 76
pointAtt             : 88 91
pointBOOL            : 102 103
pointCheckMultDiv    : 79 80 81
pointCheckOpRel      : 66
pointCheckPlusMinus  : 74 75 76
pointClass           : 88
pointClassName       : 88
pointCreateMainCuac  : 1
pointDEC             : 100
pointEndFunc         : 5 6 7 8
pointEra             : 30 31 62 63
pointFakeBackground  : 84
pointFx              : 5 6 7 8
pointFxId            : 5 6 7 8
pointGoSub           : 30 31 62 63
pointINT             : 99
pointIfCond1         : 113 114
pointIfCond2         : 113 114
pointIfCond3         : 114
pointMain            : 4
pointParam           : 19 20
pointParamCall       : 26 27
pointParamCount      : 5 6 7 8
pointParamNum        : 26
pointParamVacio      : 31 63
pointPushAssignment  : 57
pointPushMultDiv     : 80 81
pointPushPlusMinus   : 75 76
pointRemoveFakeBackground : 84
pointReturn          : 7 8
pointSTRING          : 101
pointScopeClass      : 88
pointScopeClass2     : 88
pointWhile1          : 109
pointWhile2          : 109
pointWhile3          : 109
returnCall           : 60
statements           : 35
var                  : 44 45 51
varCte               : 55 56 85
varSimpleType        : 45
varsDef              : 34 90 91
varsType             : 50 51
voidCall             : 40
whileCycle           : 41

Parsing method: LALR

state 0

    (0) S' -> . begin
    (1) begin -> . BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end

    BEGIN           shift and go to state 2

    begin                          shift and go to state 1

state 1

    (0) S' -> begin .



state 2

    (1) begin -> BEGIN . pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end
    (2) pointCreateMainCuac -> .

    OPAREN          reduce using rule 2 (pointCreateMainCuac -> .)

    pointCreateMainCuac            shift and go to state 3

state 3

    (1) begin -> BEGIN pointCreateMainCuac . OPAREN ID CPAREN classDef fxDef main end

    OPAREN          shift and go to state 4


state 4

    (1) begin -> BEGIN pointCreateMainCuac OPAREN . ID CPAREN classDef fxDef main end

    ID              shift and go to state 5


state 5

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID . CPAREN classDef fxDef main end

    CPAREN          shift and go to state 6


state 6

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN . classDef fxDef main end
    (88) classDef -> . CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (89) classDef -> . epsilon
    (121) epsilon -> .

    CLASS           shift and go to state 8
    VOID            reduce using rule 121 (epsilon -> .)
    INT             reduce using rule 121 (epsilon -> .)
    STRING          reduce using rule 121 (epsilon -> .)
    DEC             reduce using rule 121 (epsilon -> .)
    BOOL            reduce using rule 121 (epsilon -> .)
    MAIN            reduce using rule 121 (epsilon -> .)

    classDef                       shift and go to state 7
    epsilon                        shift and go to state 9

state 7

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef . fxDef main end
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (121) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 121 (epsilon -> .)

    fxDef                          shift and go to state 10
    epsilon                        shift and go to state 12
    fxType                         shift and go to state 13

state 8

    (88) classDef -> CLASS . pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (95) pointClass -> .

    ID              reduce using rule 95 (pointClass -> .)

    pointClass                     shift and go to state 18

state 9

    (89) classDef -> epsilon .

    VOID            reduce using rule 89 (classDef -> epsilon .)
    INT             reduce using rule 89 (classDef -> epsilon .)
    STRING          reduce using rule 89 (classDef -> epsilon .)
    DEC             reduce using rule 89 (classDef -> epsilon .)
    BOOL            reduce using rule 89 (classDef -> epsilon .)
    MAIN            reduce using rule 89 (classDef -> epsilon .)


state 10

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef . main end
    (4) main -> . MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET

    MAIN            shift and go to state 20

    main                           shift and go to state 19

state 11

    (5) fxDef -> VOID . FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID . FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef

    FX              shift and go to state 21


state 12

    (9) fxDef -> epsilon .

    MAIN            reduce using rule 9 (fxDef -> epsilon .)
    CBRACKET        reduce using rule 9 (fxDef -> epsilon .)


state 13

    (7) fxDef -> fxType . FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType . FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    FX              shift and go to state 22


state 14

    (10) fxType -> INT .

    FX              reduce using rule 10 (fxType -> INT .)


state 15

    (11) fxType -> STRING .

    FX              reduce using rule 11 (fxType -> STRING .)


state 16

    (12) fxType -> DEC .

    FX              reduce using rule 12 (fxType -> DEC .)


state 17

    (13) fxType -> BOOL .

    FX              reduce using rule 13 (fxType -> BOOL .)


state 18

    (88) classDef -> CLASS pointClass . ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    ID              shift and go to state 23


state 19

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main . end
    (120) end -> . END OPAREN ID CPAREN

    END             shift and go to state 25

    end                            shift and go to state 24

state 20

    (4) main -> MAIN . pointMain OPAREN CPAREN OBRACKET body CBRACKET
    (3) pointMain -> .

    OPAREN          reduce using rule 3 (pointMain -> .)

    pointMain                      shift and go to state 26

state 21

    (5) fxDef -> VOID FX . pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX . pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (14) pointFx -> .

    ID              reduce using rule 14 (pointFx -> .)

    pointFx                        shift and go to state 27

state 22

    (7) fxDef -> fxType FX . pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX . pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (14) pointFx -> .

    ID              reduce using rule 14 (pointFx -> .)

    pointFx                        shift and go to state 28

state 23

    (88) classDef -> CLASS pointClass ID . pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (94) pointClassName -> .

    OBRACKET        reduce using rule 94 (pointClassName -> .)

    pointClassName                 shift and go to state 29

state 24

    (1) begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end .

    $end            reduce using rule 1 (begin -> BEGIN pointCreateMainCuac OPAREN ID CPAREN classDef fxDef main end .)


state 25

    (120) end -> END . OPAREN ID CPAREN

    OPAREN          shift and go to state 30


state 26

    (4) main -> MAIN pointMain . OPAREN CPAREN OBRACKET body CBRACKET

    OPAREN          shift and go to state 31


state 27

    (5) fxDef -> VOID FX pointFx . ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx . ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef

    ID              shift and go to state 32


state 28

    (7) fxDef -> fxType FX pointFx . ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx . ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    ID              shift and go to state 33


state 29

    (88) classDef -> CLASS pointClass ID pointClassName . OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    OBRACKET        shift and go to state 34


state 30

    (120) end -> END OPAREN . ID CPAREN

    ID              shift and go to state 35


state 31

    (4) main -> MAIN pointMain OPAREN . CPAREN OBRACKET body CBRACKET

    CPAREN          shift and go to state 36


state 32

    (5) fxDef -> VOID FX pointFx ID . pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx ID . pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (15) pointFxId -> .

    OPAREN          reduce using rule 15 (pointFxId -> .)

    pointFxId                      shift and go to state 37

state 33

    (7) fxDef -> fxType FX pointFx ID . pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx ID . pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (15) pointFxId -> .

    OPAREN          reduce using rule 15 (pointFxId -> .)

    pointFxId                      shift and go to state 38

state 34

    (88) classDef -> CLASS pointClass ID pointClassName OBRACKET . ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    ATTRIBUTES      shift and go to state 39


state 35

    (120) end -> END OPAREN ID . CPAREN

    CPAREN          shift and go to state 40


state 36

    (4) main -> MAIN pointMain OPAREN CPAREN . OBRACKET body CBRACKET

    OBRACKET        shift and go to state 41


state 37

    (5) fxDef -> VOID FX pointFx ID pointFxId . OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx ID pointFxId . OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef

    OPAREN          shift and go to state 42


state 38

    (7) fxDef -> fxType FX pointFx ID pointFxId . OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx ID pointFxId . OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    OPAREN          shift and go to state 43


state 39

    (88) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES . COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    COLON           shift and go to state 44


state 40

    (120) end -> END OPAREN ID CPAREN .

    $end            reduce using rule 120 (end -> END OPAREN ID CPAREN .)


state 41

    (4) main -> MAIN pointMain OPAREN CPAREN OBRACKET . body CBRACKET
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (121) epsilon -> .
    (57) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (118) input -> . INPUT OPAREN ID CPAREN EOF
    (119) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (109) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (113) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (96) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 121 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 45
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 42

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN . param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN . epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (19) param -> . paramType ID pointParam
    (20) param -> . paramType ID pointParam COMMA param
    (121) epsilon -> .
    (21) paramType -> . INT
    (22) paramType -> . STRING
    (23) paramType -> . DEC
    (24) paramType -> . BOOL

    CPAREN          reduce using rule 121 (epsilon -> .)
    INT             shift and go to state 65
    STRING          shift and go to state 66
    DEC             shift and go to state 67
    BOOL            shift and go to state 68

    param                          shift and go to state 62
    epsilon                        shift and go to state 63
    paramType                      shift and go to state 64

state 43

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN . param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN . epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (19) param -> . paramType ID pointParam
    (20) param -> . paramType ID pointParam COMMA param
    (121) epsilon -> .
    (21) paramType -> . INT
    (22) paramType -> . STRING
    (23) paramType -> . DEC
    (24) paramType -> . BOOL

    CPAREN          reduce using rule 121 (epsilon -> .)
    INT             shift and go to state 65
    STRING          shift and go to state 66
    DEC             shift and go to state 67
    BOOL            shift and go to state 68

    param                          shift and go to state 69
    epsilon                        shift and go to state 70
    paramType                      shift and go to state 64

state 44

    (88) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON . pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (90) pointAtt -> . varsDef
    (91) pointAtt -> . varsDef pointAtt
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF

    VAR             shift and go to state 49

    pointAtt                       shift and go to state 71
    varsDef                        shift and go to state 72

state 45

    (4) main -> MAIN pointMain OPAREN CPAREN OBRACKET body . CBRACKET

    CBRACKET        shift and go to state 73


state 46

    (34) body -> varsDef . body
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (121) epsilon -> .
    (57) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (118) input -> . INPUT OPAREN ID CPAREN EOF
    (119) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (109) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (113) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (96) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 121 (epsilon -> .)
    RETURN          reduce using rule 121 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    varsDef                        shift and go to state 46
    body                           shift and go to state 74
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 47

    (35) body -> statements . body
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (121) epsilon -> .
    (57) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (118) input -> . INPUT OPAREN ID CPAREN EOF
    (119) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (109) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (113) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (96) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 121 (epsilon -> .)
    RETURN          reduce using rule 121 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    statements                     shift and go to state 47
    body                           shift and go to state 75
    varsDef                        shift and go to state 46
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 48

    (36) body -> epsilon .

    CBRACKET        reduce using rule 36 (body -> epsilon .)
    RETURN          reduce using rule 36 (body -> epsilon .)


state 49

    (44) varsDef -> VAR . objType var EOF
    (45) varsDef -> VAR . varSimpleType var EOF
    (98) objType -> . ID
    (46) varSimpleType -> . INT
    (47) varSimpleType -> . STRING
    (48) varSimpleType -> . DEC
    (49) varSimpleType -> . BOOL

    ID              shift and go to state 78
    INT             shift and go to state 79
    STRING          shift and go to state 80
    DEC             shift and go to state 81
    BOOL            shift and go to state 82

    objType                        shift and go to state 76
    varSimpleType                  shift and go to state 77

state 50

    (37) statements -> assignmentDef .

    VAR             reduce using rule 37 (statements -> assignmentDef .)
    ID              reduce using rule 37 (statements -> assignmentDef .)
    INPUT           reduce using rule 37 (statements -> assignmentDef .)
    OUTPUT          reduce using rule 37 (statements -> assignmentDef .)
    WHILE           reduce using rule 37 (statements -> assignmentDef .)
    IF              reduce using rule 37 (statements -> assignmentDef .)
    CBRACKET        reduce using rule 37 (statements -> assignmentDef .)
    RETURN          reduce using rule 37 (statements -> assignmentDef .)


state 51

    (38) statements -> input .

    VAR             reduce using rule 38 (statements -> input .)
    ID              reduce using rule 38 (statements -> input .)
    INPUT           reduce using rule 38 (statements -> input .)
    OUTPUT          reduce using rule 38 (statements -> input .)
    WHILE           reduce using rule 38 (statements -> input .)
    IF              reduce using rule 38 (statements -> input .)
    CBRACKET        reduce using rule 38 (statements -> input .)
    RETURN          reduce using rule 38 (statements -> input .)


state 52

    (39) statements -> output .

    VAR             reduce using rule 39 (statements -> output .)
    ID              reduce using rule 39 (statements -> output .)
    INPUT           reduce using rule 39 (statements -> output .)
    OUTPUT          reduce using rule 39 (statements -> output .)
    WHILE           reduce using rule 39 (statements -> output .)
    IF              reduce using rule 39 (statements -> output .)
    CBRACKET        reduce using rule 39 (statements -> output .)
    RETURN          reduce using rule 39 (statements -> output .)


state 53

    (40) statements -> voidCall .

    VAR             reduce using rule 40 (statements -> voidCall .)
    ID              reduce using rule 40 (statements -> voidCall .)
    INPUT           reduce using rule 40 (statements -> voidCall .)
    OUTPUT          reduce using rule 40 (statements -> voidCall .)
    WHILE           reduce using rule 40 (statements -> voidCall .)
    IF              reduce using rule 40 (statements -> voidCall .)
    CBRACKET        reduce using rule 40 (statements -> voidCall .)
    RETURN          reduce using rule 40 (statements -> voidCall .)


state 54

    (41) statements -> whileCycle .

    VAR             reduce using rule 41 (statements -> whileCycle .)
    ID              reduce using rule 41 (statements -> whileCycle .)
    INPUT           reduce using rule 41 (statements -> whileCycle .)
    OUTPUT          reduce using rule 41 (statements -> whileCycle .)
    WHILE           reduce using rule 41 (statements -> whileCycle .)
    IF              reduce using rule 41 (statements -> whileCycle .)
    CBRACKET        reduce using rule 41 (statements -> whileCycle .)
    RETURN          reduce using rule 41 (statements -> whileCycle .)


state 55

    (42) statements -> ifCond .

    VAR             reduce using rule 42 (statements -> ifCond .)
    ID              reduce using rule 42 (statements -> ifCond .)
    INPUT           reduce using rule 42 (statements -> ifCond .)
    OUTPUT          reduce using rule 42 (statements -> ifCond .)
    WHILE           reduce using rule 42 (statements -> ifCond .)
    IF              reduce using rule 42 (statements -> ifCond .)
    CBRACKET        reduce using rule 42 (statements -> ifCond .)
    RETURN          reduce using rule 42 (statements -> ifCond .)


state 56

    (43) statements -> classCall .

    VAR             reduce using rule 43 (statements -> classCall .)
    ID              reduce using rule 43 (statements -> classCall .)
    INPUT           reduce using rule 43 (statements -> classCall .)
    OUTPUT          reduce using rule 43 (statements -> classCall .)
    WHILE           reduce using rule 43 (statements -> classCall .)
    IF              reduce using rule 43 (statements -> classCall .)
    CBRACKET        reduce using rule 43 (statements -> classCall .)
    RETURN          reduce using rule 43 (statements -> classCall .)


state 57

    (57) assignmentDef -> ID . ASSIGNMENT pointPushAssignment expAssignment
    (30) voidCall -> ID . pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> ID . pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (96) classCall -> ID . MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> ID . MONEY ID OPAREN epsilon CPAREN EOF
    (32) pointEra -> .

    ASSIGNMENT      shift and go to state 83
    MONEY           shift and go to state 85
    OPAREN          reduce using rule 32 (pointEra -> .)

    pointEra                       shift and go to state 84

state 58

    (118) input -> INPUT . OPAREN ID CPAREN EOF

    OPAREN          shift and go to state 86


state 59

    (119) output -> OUTPUT . OPAREN expRelational CPAREN EOF

    OPAREN          shift and go to state 87


state 60

    (109) whileCycle -> WHILE . pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (110) pointWhile1 -> .

    OPAREN          reduce using rule 110 (pointWhile1 -> .)

    pointWhile1                    shift and go to state 88

state 61

    (113) ifCond -> IF . OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> IF . OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    OPAREN          shift and go to state 89


state 62

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param . CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 90


state 63

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon . CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 91


state 64

    (19) param -> paramType . ID pointParam
    (20) param -> paramType . ID pointParam COMMA param

    ID              shift and go to state 92


state 65

    (21) paramType -> INT .

    ID              reduce using rule 21 (paramType -> INT .)


state 66

    (22) paramType -> STRING .

    ID              reduce using rule 22 (paramType -> STRING .)


state 67

    (23) paramType -> DEC .

    ID              reduce using rule 23 (paramType -> DEC .)


state 68

    (24) paramType -> BOOL .

    ID              reduce using rule 24 (paramType -> BOOL .)


state 69

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param . CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 93


state 70

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon . CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    CPAREN          shift and go to state 94


state 71

    (88) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt . METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    METHODS         shift and go to state 95


state 72

    (90) pointAtt -> varsDef .
    (91) pointAtt -> varsDef . pointAtt
    (90) pointAtt -> . varsDef
    (91) pointAtt -> . varsDef pointAtt
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF

    METHODS         reduce using rule 90 (pointAtt -> varsDef .)
    VAR             shift and go to state 49

    varsDef                        shift and go to state 72
    pointAtt                       shift and go to state 96

state 73

    (4) main -> MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET .

    END             reduce using rule 4 (main -> MAIN pointMain OPAREN CPAREN OBRACKET body CBRACKET .)


state 74

    (34) body -> varsDef body .

    CBRACKET        reduce using rule 34 (body -> varsDef body .)
    RETURN          reduce using rule 34 (body -> varsDef body .)


state 75

    (35) body -> statements body .

    CBRACKET        reduce using rule 35 (body -> statements body .)
    RETURN          reduce using rule 35 (body -> statements body .)


state 76

    (44) varsDef -> VAR objType . var EOF
    (50) var -> . varsType
    (51) var -> . varsType COMMA var
    (52) varsType -> . ID
    (53) varsType -> . arrDef
    (54) varsType -> . matrixDef
    (55) arrDef -> . ID OSQUAREBR varCte CSQUAREBR
    (56) matrixDef -> . arrDef OSQUAREBR varCte CSQUAREBR

    ID              shift and go to state 99

    var                            shift and go to state 97
    varsType                       shift and go to state 98
    arrDef                         shift and go to state 100
    matrixDef                      shift and go to state 101

state 77

    (45) varsDef -> VAR varSimpleType . var EOF
    (50) var -> . varsType
    (51) var -> . varsType COMMA var
    (52) varsType -> . ID
    (53) varsType -> . arrDef
    (54) varsType -> . matrixDef
    (55) arrDef -> . ID OSQUAREBR varCte CSQUAREBR
    (56) matrixDef -> . arrDef OSQUAREBR varCte CSQUAREBR

    ID              shift and go to state 99

    var                            shift and go to state 102
    varsType                       shift and go to state 98
    arrDef                         shift and go to state 100
    matrixDef                      shift and go to state 101

state 78

    (98) objType -> ID .

    ID              reduce using rule 98 (objType -> ID .)


state 79

    (46) varSimpleType -> INT .

    ID              reduce using rule 46 (varSimpleType -> INT .)


state 80

    (47) varSimpleType -> STRING .

    ID              reduce using rule 47 (varSimpleType -> STRING .)


state 81

    (48) varSimpleType -> DEC .

    ID              reduce using rule 48 (varSimpleType -> DEC .)


state 82

    (49) varSimpleType -> BOOL .

    ID              reduce using rule 49 (varSimpleType -> BOOL .)


state 83

    (57) assignmentDef -> ID ASSIGNMENT . pointPushAssignment expAssignment
    (58) pointPushAssignment -> .

    ID              reduce using rule 58 (pointPushAssignment -> .)
    OPAREN          reduce using rule 58 (pointPushAssignment -> .)
    INT             reduce using rule 58 (pointPushAssignment -> .)
    DEC             reduce using rule 58 (pointPushAssignment -> .)
    STRING          reduce using rule 58 (pointPushAssignment -> .)
    TRUE            reduce using rule 58 (pointPushAssignment -> .)
    FALSE           reduce using rule 58 (pointPushAssignment -> .)

    pointPushAssignment            shift and go to state 103

state 84

    (30) voidCall -> ID pointEra . OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> ID pointEra . OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF

    OPAREN          shift and go to state 104


state 85

    (96) classCall -> ID MONEY . ID OPAREN paramCall CPAREN EOF
    (97) classCall -> ID MONEY . ID OPAREN epsilon CPAREN EOF

    ID              shift and go to state 105


state 86

    (118) input -> INPUT OPAREN . ID CPAREN EOF

    ID              shift and go to state 106


state 87

    (119) output -> OUTPUT OPAREN . expRelational CPAREN EOF
    (65) expRelational -> . plusMinus
    (66) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (74) plusMinus -> . multDiv pointCheckPlusMinus
    (75) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (76) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (79) multDiv -> . expParen pointCheckMultDiv
    (80) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (81) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (84) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (85) expParen -> . varCte
    (99) varCte -> . INT pointINT
    (100) varCte -> . DEC pointDEC
    (101) varCte -> . STRING pointSTRING
    (102) varCte -> . TRUE pointBOOL
    (103) varCte -> . FALSE pointBOOL
    (104) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    expRelational                  shift and go to state 108
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 88

    (109) whileCycle -> WHILE pointWhile1 . OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3

    OPAREN          shift and go to state 119


state 89

    (113) ifCond -> IF OPAREN . expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> IF OPAREN . expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (65) expRelational -> . plusMinus
    (66) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (74) plusMinus -> . multDiv pointCheckPlusMinus
    (75) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (76) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (79) multDiv -> . expParen pointCheckMultDiv
    (80) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (81) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (84) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (85) expParen -> . varCte
    (99) varCte -> . INT pointINT
    (100) varCte -> . DEC pointDEC
    (101) varCte -> . STRING pointSTRING
    (102) varCte -> . TRUE pointBOOL
    (103) varCte -> . FALSE pointBOOL
    (104) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    expRelational                  shift and go to state 120
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 90

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN . pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (17) pointParamCount -> .

    OBRACKET        reduce using rule 17 (pointParamCount -> .)

    pointParamCount                shift and go to state 121

state 91

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN . pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (17) pointParamCount -> .

    OBRACKET        reduce using rule 17 (pointParamCount -> .)

    pointParamCount                shift and go to state 122

state 92

    (19) param -> paramType ID . pointParam
    (20) param -> paramType ID . pointParam COMMA param
    (25) pointParam -> .

    COMMA           reduce using rule 25 (pointParam -> .)
    CPAREN          reduce using rule 25 (pointParam -> .)

    pointParam                     shift and go to state 123

state 93

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN . pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (17) pointParamCount -> .

    OBRACKET        reduce using rule 17 (pointParamCount -> .)

    pointParamCount                shift and go to state 124

state 94

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN . pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (17) pointParamCount -> .

    OBRACKET        reduce using rule 17 (pointParamCount -> .)

    pointParamCount                shift and go to state 125

state 95

    (88) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS . COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef

    COLON           shift and go to state 126


state 96

    (91) pointAtt -> varsDef pointAtt .

    METHODS         reduce using rule 91 (pointAtt -> varsDef pointAtt .)


state 97

    (44) varsDef -> VAR objType var . EOF

    EOF             shift and go to state 127


state 98

    (50) var -> varsType .
    (51) var -> varsType . COMMA var

    EOF             reduce using rule 50 (var -> varsType .)
    COMMA           shift and go to state 128


state 99

    (52) varsType -> ID .
    (55) arrDef -> ID . OSQUAREBR varCte CSQUAREBR

    COMMA           reduce using rule 52 (varsType -> ID .)
    EOF             reduce using rule 52 (varsType -> ID .)
    OSQUAREBR       shift and go to state 129


state 100

    (53) varsType -> arrDef .
    (56) matrixDef -> arrDef . OSQUAREBR varCte CSQUAREBR

    COMMA           reduce using rule 53 (varsType -> arrDef .)
    EOF             reduce using rule 53 (varsType -> arrDef .)
    OSQUAREBR       shift and go to state 130


state 101

    (54) varsType -> matrixDef .

    COMMA           reduce using rule 54 (varsType -> matrixDef .)
    EOF             reduce using rule 54 (varsType -> matrixDef .)


state 102

    (45) varsDef -> VAR varSimpleType var . EOF

    EOF             shift and go to state 131


state 103

    (57) assignmentDef -> ID ASSIGNMENT pointPushAssignment . expAssignment
    (59) expAssignment -> . expRelational EOF
    (60) expAssignment -> . returnCall EOF
    (61) expAssignment -> . classCall
    (65) expRelational -> . plusMinus
    (66) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (62) returnCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN
    (63) returnCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN
    (96) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF
    (74) plusMinus -> . multDiv pointCheckPlusMinus
    (75) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (76) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (79) multDiv -> . expParen pointCheckMultDiv
    (80) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (81) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (84) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (85) expParen -> . varCte
    (99) varCte -> . INT pointINT
    (100) varCte -> . DEC pointDEC
    (101) varCte -> . STRING pointSTRING
    (102) varCte -> . TRUE pointBOOL
    (103) varCte -> . FALSE pointBOOL
    (104) varCte -> . ID

    ID              shift and go to state 132
    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117

    expAssignment                  shift and go to state 133
    expRelational                  shift and go to state 134
    returnCall                     shift and go to state 135
    classCall                      shift and go to state 136
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 104

    (30) voidCall -> ID pointEra OPAREN . paramCall pointGoSub CPAREN EOF
    (31) voidCall -> ID pointEra OPAREN . epsilon pointParamVacio pointGoSub CPAREN EOF
    (26) paramCall -> . ID pointParamCall pointParamNum
    (27) paramCall -> . ID pointParamCall COMMA paramCall
    (121) epsilon -> .

    ID              shift and go to state 137
    CPAREN          reduce using rule 121 (epsilon -> .)

    paramCall                      shift and go to state 138
    epsilon                        shift and go to state 139

state 105

    (96) classCall -> ID MONEY ID . OPAREN paramCall CPAREN EOF
    (97) classCall -> ID MONEY ID . OPAREN epsilon CPAREN EOF

    OPAREN          shift and go to state 140


state 106

    (118) input -> INPUT OPAREN ID . CPAREN EOF

    CPAREN          shift and go to state 141


state 107

    (84) expParen -> OPAREN . pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (86) pointFakeBackground -> .

    OPAREN          reduce using rule 86 (pointFakeBackground -> .)
    INT             reduce using rule 86 (pointFakeBackground -> .)
    DEC             reduce using rule 86 (pointFakeBackground -> .)
    STRING          reduce using rule 86 (pointFakeBackground -> .)
    TRUE            reduce using rule 86 (pointFakeBackground -> .)
    FALSE           reduce using rule 86 (pointFakeBackground -> .)
    ID              reduce using rule 86 (pointFakeBackground -> .)

    pointFakeBackground            shift and go to state 142

state 108

    (119) output -> OUTPUT OPAREN expRelational . CPAREN EOF

    CPAREN          shift and go to state 143


state 109

    (65) expRelational -> plusMinus .
    (66) expRelational -> plusMinus . opRelational expRelational pointCheckOpRel
    (68) opRelational -> . EQUAL
    (69) opRelational -> . DIFFERENT
    (70) opRelational -> . GREATERTHAN
    (71) opRelational -> . GREATERTHANEQ
    (72) opRelational -> . LESSTHAN
    (73) opRelational -> . LESSTHANEQ

    CPAREN          reduce using rule 65 (expRelational -> plusMinus .)
    EOF             reduce using rule 65 (expRelational -> plusMinus .)
    EQUAL           shift and go to state 145
    DIFFERENT       shift and go to state 146
    GREATERTHAN     shift and go to state 147
    GREATERTHANEQ   shift and go to state 148
    LESSTHAN        shift and go to state 149
    LESSTHANEQ      shift and go to state 150

    opRelational                   shift and go to state 144

state 110

    (74) plusMinus -> multDiv . pointCheckPlusMinus
    (75) plusMinus -> multDiv . pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (76) plusMinus -> multDiv . pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (77) pointCheckPlusMinus -> .

    PLUS            reduce using rule 77 (pointCheckPlusMinus -> .)
    MINUS           reduce using rule 77 (pointCheckPlusMinus -> .)
    EQUAL           reduce using rule 77 (pointCheckPlusMinus -> .)
    DIFFERENT       reduce using rule 77 (pointCheckPlusMinus -> .)
    GREATERTHAN     reduce using rule 77 (pointCheckPlusMinus -> .)
    GREATERTHANEQ   reduce using rule 77 (pointCheckPlusMinus -> .)
    LESSTHAN        reduce using rule 77 (pointCheckPlusMinus -> .)
    LESSTHANEQ      reduce using rule 77 (pointCheckPlusMinus -> .)
    CPAREN          reduce using rule 77 (pointCheckPlusMinus -> .)
    EOF             reduce using rule 77 (pointCheckPlusMinus -> .)

    pointCheckPlusMinus            shift and go to state 151

state 111

    (79) multDiv -> expParen . pointCheckMultDiv
    (80) multDiv -> expParen . pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (81) multDiv -> expParen . pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (82) pointCheckMultDiv -> .

    MULTIPLY        reduce using rule 82 (pointCheckMultDiv -> .)
    DIVIDE          reduce using rule 82 (pointCheckMultDiv -> .)
    PLUS            reduce using rule 82 (pointCheckMultDiv -> .)
    MINUS           reduce using rule 82 (pointCheckMultDiv -> .)
    EQUAL           reduce using rule 82 (pointCheckMultDiv -> .)
    DIFFERENT       reduce using rule 82 (pointCheckMultDiv -> .)
    GREATERTHAN     reduce using rule 82 (pointCheckMultDiv -> .)
    GREATERTHANEQ   reduce using rule 82 (pointCheckMultDiv -> .)
    LESSTHAN        reduce using rule 82 (pointCheckMultDiv -> .)
    LESSTHANEQ      reduce using rule 82 (pointCheckMultDiv -> .)
    CPAREN          reduce using rule 82 (pointCheckMultDiv -> .)
    EOF             reduce using rule 82 (pointCheckMultDiv -> .)

    pointCheckMultDiv              shift and go to state 152

state 112

    (85) expParen -> varCte .

    MULTIPLY        reduce using rule 85 (expParen -> varCte .)
    DIVIDE          reduce using rule 85 (expParen -> varCte .)
    PLUS            reduce using rule 85 (expParen -> varCte .)
    MINUS           reduce using rule 85 (expParen -> varCte .)
    EQUAL           reduce using rule 85 (expParen -> varCte .)
    DIFFERENT       reduce using rule 85 (expParen -> varCte .)
    GREATERTHAN     reduce using rule 85 (expParen -> varCte .)
    GREATERTHANEQ   reduce using rule 85 (expParen -> varCte .)
    LESSTHAN        reduce using rule 85 (expParen -> varCte .)
    LESSTHANEQ      reduce using rule 85 (expParen -> varCte .)
    CPAREN          reduce using rule 85 (expParen -> varCte .)
    EOF             reduce using rule 85 (expParen -> varCte .)


state 113

    (99) varCte -> INT . pointINT
    (105) pointINT -> .

    MULTIPLY        reduce using rule 105 (pointINT -> .)
    DIVIDE          reduce using rule 105 (pointINT -> .)
    PLUS            reduce using rule 105 (pointINT -> .)
    MINUS           reduce using rule 105 (pointINT -> .)
    EQUAL           reduce using rule 105 (pointINT -> .)
    DIFFERENT       reduce using rule 105 (pointINT -> .)
    GREATERTHAN     reduce using rule 105 (pointINT -> .)
    GREATERTHANEQ   reduce using rule 105 (pointINT -> .)
    LESSTHAN        reduce using rule 105 (pointINT -> .)
    LESSTHANEQ      reduce using rule 105 (pointINT -> .)
    CPAREN          reduce using rule 105 (pointINT -> .)
    EOF             reduce using rule 105 (pointINT -> .)
    CSQUAREBR       reduce using rule 105 (pointINT -> .)

    pointINT                       shift and go to state 153

state 114

    (100) varCte -> DEC . pointDEC
    (106) pointDEC -> .

    MULTIPLY        reduce using rule 106 (pointDEC -> .)
    DIVIDE          reduce using rule 106 (pointDEC -> .)
    PLUS            reduce using rule 106 (pointDEC -> .)
    MINUS           reduce using rule 106 (pointDEC -> .)
    EQUAL           reduce using rule 106 (pointDEC -> .)
    DIFFERENT       reduce using rule 106 (pointDEC -> .)
    GREATERTHAN     reduce using rule 106 (pointDEC -> .)
    GREATERTHANEQ   reduce using rule 106 (pointDEC -> .)
    LESSTHAN        reduce using rule 106 (pointDEC -> .)
    LESSTHANEQ      reduce using rule 106 (pointDEC -> .)
    CPAREN          reduce using rule 106 (pointDEC -> .)
    EOF             reduce using rule 106 (pointDEC -> .)
    CSQUAREBR       reduce using rule 106 (pointDEC -> .)

    pointDEC                       shift and go to state 154

state 115

    (101) varCte -> STRING . pointSTRING
    (107) pointSTRING -> .

    MULTIPLY        reduce using rule 107 (pointSTRING -> .)
    DIVIDE          reduce using rule 107 (pointSTRING -> .)
    PLUS            reduce using rule 107 (pointSTRING -> .)
    MINUS           reduce using rule 107 (pointSTRING -> .)
    EQUAL           reduce using rule 107 (pointSTRING -> .)
    DIFFERENT       reduce using rule 107 (pointSTRING -> .)
    GREATERTHAN     reduce using rule 107 (pointSTRING -> .)
    GREATERTHANEQ   reduce using rule 107 (pointSTRING -> .)
    LESSTHAN        reduce using rule 107 (pointSTRING -> .)
    LESSTHANEQ      reduce using rule 107 (pointSTRING -> .)
    CPAREN          reduce using rule 107 (pointSTRING -> .)
    EOF             reduce using rule 107 (pointSTRING -> .)
    CSQUAREBR       reduce using rule 107 (pointSTRING -> .)

    pointSTRING                    shift and go to state 155

state 116

    (102) varCte -> TRUE . pointBOOL
    (108) pointBOOL -> .

    MULTIPLY        reduce using rule 108 (pointBOOL -> .)
    DIVIDE          reduce using rule 108 (pointBOOL -> .)
    PLUS            reduce using rule 108 (pointBOOL -> .)
    MINUS           reduce using rule 108 (pointBOOL -> .)
    EQUAL           reduce using rule 108 (pointBOOL -> .)
    DIFFERENT       reduce using rule 108 (pointBOOL -> .)
    GREATERTHAN     reduce using rule 108 (pointBOOL -> .)
    GREATERTHANEQ   reduce using rule 108 (pointBOOL -> .)
    LESSTHAN        reduce using rule 108 (pointBOOL -> .)
    LESSTHANEQ      reduce using rule 108 (pointBOOL -> .)
    CPAREN          reduce using rule 108 (pointBOOL -> .)
    EOF             reduce using rule 108 (pointBOOL -> .)
    CSQUAREBR       reduce using rule 108 (pointBOOL -> .)

    pointBOOL                      shift and go to state 156

state 117

    (103) varCte -> FALSE . pointBOOL
    (108) pointBOOL -> .

    MULTIPLY        reduce using rule 108 (pointBOOL -> .)
    DIVIDE          reduce using rule 108 (pointBOOL -> .)
    PLUS            reduce using rule 108 (pointBOOL -> .)
    MINUS           reduce using rule 108 (pointBOOL -> .)
    EQUAL           reduce using rule 108 (pointBOOL -> .)
    DIFFERENT       reduce using rule 108 (pointBOOL -> .)
    GREATERTHAN     reduce using rule 108 (pointBOOL -> .)
    GREATERTHANEQ   reduce using rule 108 (pointBOOL -> .)
    LESSTHAN        reduce using rule 108 (pointBOOL -> .)
    LESSTHANEQ      reduce using rule 108 (pointBOOL -> .)
    CPAREN          reduce using rule 108 (pointBOOL -> .)
    EOF             reduce using rule 108 (pointBOOL -> .)
    CSQUAREBR       reduce using rule 108 (pointBOOL -> .)

    pointBOOL                      shift and go to state 157

state 118

    (104) varCte -> ID .

    MULTIPLY        reduce using rule 104 (varCte -> ID .)
    DIVIDE          reduce using rule 104 (varCte -> ID .)
    PLUS            reduce using rule 104 (varCte -> ID .)
    MINUS           reduce using rule 104 (varCte -> ID .)
    EQUAL           reduce using rule 104 (varCte -> ID .)
    DIFFERENT       reduce using rule 104 (varCte -> ID .)
    GREATERTHAN     reduce using rule 104 (varCte -> ID .)
    GREATERTHANEQ   reduce using rule 104 (varCte -> ID .)
    LESSTHAN        reduce using rule 104 (varCte -> ID .)
    LESSTHANEQ      reduce using rule 104 (varCte -> ID .)
    CPAREN          reduce using rule 104 (varCte -> ID .)
    CSQUAREBR       reduce using rule 104 (varCte -> ID .)
    EOF             reduce using rule 104 (varCte -> ID .)


state 119

    (109) whileCycle -> WHILE pointWhile1 OPAREN . expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (65) expRelational -> . plusMinus
    (66) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (74) plusMinus -> . multDiv pointCheckPlusMinus
    (75) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (76) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (79) multDiv -> . expParen pointCheckMultDiv
    (80) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (81) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (84) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (85) expParen -> . varCte
    (99) varCte -> . INT pointINT
    (100) varCte -> . DEC pointDEC
    (101) varCte -> . STRING pointSTRING
    (102) varCte -> . TRUE pointBOOL
    (103) varCte -> . FALSE pointBOOL
    (104) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    expRelational                  shift and go to state 158
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 120

    (113) ifCond -> IF OPAREN expRelational . CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> IF OPAREN expRelational . CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    CPAREN          shift and go to state 159


state 121

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount . OBRACKET body CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 160


state 122

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount . OBRACKET body CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 161


state 123

    (19) param -> paramType ID pointParam .
    (20) param -> paramType ID pointParam . COMMA param

    CPAREN          reduce using rule 19 (param -> paramType ID pointParam .)
    COMMA           shift and go to state 162


state 124

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount . OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 163


state 125

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount . OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    OBRACKET        shift and go to state 164


state 126

    (88) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON . pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (92) pointScopeClass -> .

    VOID            reduce using rule 92 (pointScopeClass -> .)
    INT             reduce using rule 92 (pointScopeClass -> .)
    STRING          reduce using rule 92 (pointScopeClass -> .)
    DEC             reduce using rule 92 (pointScopeClass -> .)
    BOOL            reduce using rule 92 (pointScopeClass -> .)
    CBRACKET        reduce using rule 92 (pointScopeClass -> .)

    pointScopeClass                shift and go to state 165

state 127

    (44) varsDef -> VAR objType var EOF .

    VAR             reduce using rule 44 (varsDef -> VAR objType var EOF .)
    ID              reduce using rule 44 (varsDef -> VAR objType var EOF .)
    INPUT           reduce using rule 44 (varsDef -> VAR objType var EOF .)
    OUTPUT          reduce using rule 44 (varsDef -> VAR objType var EOF .)
    WHILE           reduce using rule 44 (varsDef -> VAR objType var EOF .)
    IF              reduce using rule 44 (varsDef -> VAR objType var EOF .)
    CBRACKET        reduce using rule 44 (varsDef -> VAR objType var EOF .)
    METHODS         reduce using rule 44 (varsDef -> VAR objType var EOF .)
    RETURN          reduce using rule 44 (varsDef -> VAR objType var EOF .)


state 128

    (51) var -> varsType COMMA . var
    (50) var -> . varsType
    (51) var -> . varsType COMMA var
    (52) varsType -> . ID
    (53) varsType -> . arrDef
    (54) varsType -> . matrixDef
    (55) arrDef -> . ID OSQUAREBR varCte CSQUAREBR
    (56) matrixDef -> . arrDef OSQUAREBR varCte CSQUAREBR

    ID              shift and go to state 99

    varsType                       shift and go to state 98
    var                            shift and go to state 166
    arrDef                         shift and go to state 100
    matrixDef                      shift and go to state 101

state 129

    (55) arrDef -> ID OSQUAREBR . varCte CSQUAREBR
    (99) varCte -> . INT pointINT
    (100) varCte -> . DEC pointDEC
    (101) varCte -> . STRING pointSTRING
    (102) varCte -> . TRUE pointBOOL
    (103) varCte -> . FALSE pointBOOL
    (104) varCte -> . ID

    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    varCte                         shift and go to state 167

state 130

    (56) matrixDef -> arrDef OSQUAREBR . varCte CSQUAREBR
    (99) varCte -> . INT pointINT
    (100) varCte -> . DEC pointDEC
    (101) varCte -> . STRING pointSTRING
    (102) varCte -> . TRUE pointBOOL
    (103) varCte -> . FALSE pointBOOL
    (104) varCte -> . ID

    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    varCte                         shift and go to state 168

state 131

    (45) varsDef -> VAR varSimpleType var EOF .

    VAR             reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    ID              reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    INPUT           reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    OUTPUT          reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    WHILE           reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    IF              reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    CBRACKET        reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    METHODS         reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)
    RETURN          reduce using rule 45 (varsDef -> VAR varSimpleType var EOF .)


state 132

    (62) returnCall -> ID . pointEra OPAREN paramCall pointGoSub CPAREN
    (63) returnCall -> ID . pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN
    (96) classCall -> ID . MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> ID . MONEY ID OPAREN epsilon CPAREN EOF
    (104) varCte -> ID .
    (32) pointEra -> .

    MONEY           shift and go to state 85
    MULTIPLY        reduce using rule 104 (varCte -> ID .)
    DIVIDE          reduce using rule 104 (varCte -> ID .)
    PLUS            reduce using rule 104 (varCte -> ID .)
    MINUS           reduce using rule 104 (varCte -> ID .)
    EQUAL           reduce using rule 104 (varCte -> ID .)
    DIFFERENT       reduce using rule 104 (varCte -> ID .)
    GREATERTHAN     reduce using rule 104 (varCte -> ID .)
    GREATERTHANEQ   reduce using rule 104 (varCte -> ID .)
    LESSTHAN        reduce using rule 104 (varCte -> ID .)
    LESSTHANEQ      reduce using rule 104 (varCte -> ID .)
    EOF             reduce using rule 104 (varCte -> ID .)
    OPAREN          reduce using rule 32 (pointEra -> .)

    pointEra                       shift and go to state 169

state 133

    (57) assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .

    VAR             reduce using rule 57 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    ID              reduce using rule 57 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    INPUT           reduce using rule 57 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    OUTPUT          reduce using rule 57 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    WHILE           reduce using rule 57 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    IF              reduce using rule 57 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    CBRACKET        reduce using rule 57 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)
    RETURN          reduce using rule 57 (assignmentDef -> ID ASSIGNMENT pointPushAssignment expAssignment .)


state 134

    (59) expAssignment -> expRelational . EOF

    EOF             shift and go to state 170


state 135

    (60) expAssignment -> returnCall . EOF

    EOF             shift and go to state 171


state 136

    (61) expAssignment -> classCall .

    VAR             reduce using rule 61 (expAssignment -> classCall .)
    ID              reduce using rule 61 (expAssignment -> classCall .)
    INPUT           reduce using rule 61 (expAssignment -> classCall .)
    OUTPUT          reduce using rule 61 (expAssignment -> classCall .)
    WHILE           reduce using rule 61 (expAssignment -> classCall .)
    IF              reduce using rule 61 (expAssignment -> classCall .)
    CBRACKET        reduce using rule 61 (expAssignment -> classCall .)
    RETURN          reduce using rule 61 (expAssignment -> classCall .)


state 137

    (26) paramCall -> ID . pointParamCall pointParamNum
    (27) paramCall -> ID . pointParamCall COMMA paramCall
    (29) pointParamCall -> .

    COMMA           reduce using rule 29 (pointParamCall -> .)
    CPAREN          reduce using rule 29 (pointParamCall -> .)

    pointParamCall                 shift and go to state 172

state 138

    (30) voidCall -> ID pointEra OPAREN paramCall . pointGoSub CPAREN EOF
    (33) pointGoSub -> .

    CPAREN          reduce using rule 33 (pointGoSub -> .)

    pointGoSub                     shift and go to state 173

state 139

    (31) voidCall -> ID pointEra OPAREN epsilon . pointParamVacio pointGoSub CPAREN EOF
    (64) pointParamVacio -> .

    CPAREN          reduce using rule 64 (pointParamVacio -> .)

    pointParamVacio                shift and go to state 174

state 140

    (96) classCall -> ID MONEY ID OPAREN . paramCall CPAREN EOF
    (97) classCall -> ID MONEY ID OPAREN . epsilon CPAREN EOF
    (26) paramCall -> . ID pointParamCall pointParamNum
    (27) paramCall -> . ID pointParamCall COMMA paramCall
    (121) epsilon -> .

    ID              shift and go to state 137
    CPAREN          reduce using rule 121 (epsilon -> .)

    paramCall                      shift and go to state 175
    epsilon                        shift and go to state 176

state 141

    (118) input -> INPUT OPAREN ID CPAREN . EOF

    EOF             shift and go to state 177


state 142

    (84) expParen -> OPAREN pointFakeBackground . expRelational CPAREN pointRemoveFakeBackground
    (65) expRelational -> . plusMinus
    (66) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (74) plusMinus -> . multDiv pointCheckPlusMinus
    (75) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (76) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (79) multDiv -> . expParen pointCheckMultDiv
    (80) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (81) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (84) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (85) expParen -> . varCte
    (99) varCte -> . INT pointINT
    (100) varCte -> . DEC pointDEC
    (101) varCte -> . STRING pointSTRING
    (102) varCte -> . TRUE pointBOOL
    (103) varCte -> . FALSE pointBOOL
    (104) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    expRelational                  shift and go to state 178
    plusMinus                      shift and go to state 109
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 143

    (119) output -> OUTPUT OPAREN expRelational CPAREN . EOF

    EOF             shift and go to state 179


state 144

    (66) expRelational -> plusMinus opRelational . expRelational pointCheckOpRel
    (65) expRelational -> . plusMinus
    (66) expRelational -> . plusMinus opRelational expRelational pointCheckOpRel
    (74) plusMinus -> . multDiv pointCheckPlusMinus
    (75) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (76) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (79) multDiv -> . expParen pointCheckMultDiv
    (80) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (81) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (84) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (85) expParen -> . varCte
    (99) varCte -> . INT pointINT
    (100) varCte -> . DEC pointDEC
    (101) varCte -> . STRING pointSTRING
    (102) varCte -> . TRUE pointBOOL
    (103) varCte -> . FALSE pointBOOL
    (104) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    plusMinus                      shift and go to state 109
    expRelational                  shift and go to state 180
    multDiv                        shift and go to state 110
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 145

    (68) opRelational -> EQUAL .

    OPAREN          reduce using rule 68 (opRelational -> EQUAL .)
    INT             reduce using rule 68 (opRelational -> EQUAL .)
    DEC             reduce using rule 68 (opRelational -> EQUAL .)
    STRING          reduce using rule 68 (opRelational -> EQUAL .)
    TRUE            reduce using rule 68 (opRelational -> EQUAL .)
    FALSE           reduce using rule 68 (opRelational -> EQUAL .)
    ID              reduce using rule 68 (opRelational -> EQUAL .)


state 146

    (69) opRelational -> DIFFERENT .

    OPAREN          reduce using rule 69 (opRelational -> DIFFERENT .)
    INT             reduce using rule 69 (opRelational -> DIFFERENT .)
    DEC             reduce using rule 69 (opRelational -> DIFFERENT .)
    STRING          reduce using rule 69 (opRelational -> DIFFERENT .)
    TRUE            reduce using rule 69 (opRelational -> DIFFERENT .)
    FALSE           reduce using rule 69 (opRelational -> DIFFERENT .)
    ID              reduce using rule 69 (opRelational -> DIFFERENT .)


state 147

    (70) opRelational -> GREATERTHAN .

    OPAREN          reduce using rule 70 (opRelational -> GREATERTHAN .)
    INT             reduce using rule 70 (opRelational -> GREATERTHAN .)
    DEC             reduce using rule 70 (opRelational -> GREATERTHAN .)
    STRING          reduce using rule 70 (opRelational -> GREATERTHAN .)
    TRUE            reduce using rule 70 (opRelational -> GREATERTHAN .)
    FALSE           reduce using rule 70 (opRelational -> GREATERTHAN .)
    ID              reduce using rule 70 (opRelational -> GREATERTHAN .)


state 148

    (71) opRelational -> GREATERTHANEQ .

    OPAREN          reduce using rule 71 (opRelational -> GREATERTHANEQ .)
    INT             reduce using rule 71 (opRelational -> GREATERTHANEQ .)
    DEC             reduce using rule 71 (opRelational -> GREATERTHANEQ .)
    STRING          reduce using rule 71 (opRelational -> GREATERTHANEQ .)
    TRUE            reduce using rule 71 (opRelational -> GREATERTHANEQ .)
    FALSE           reduce using rule 71 (opRelational -> GREATERTHANEQ .)
    ID              reduce using rule 71 (opRelational -> GREATERTHANEQ .)


state 149

    (72) opRelational -> LESSTHAN .

    OPAREN          reduce using rule 72 (opRelational -> LESSTHAN .)
    INT             reduce using rule 72 (opRelational -> LESSTHAN .)
    DEC             reduce using rule 72 (opRelational -> LESSTHAN .)
    STRING          reduce using rule 72 (opRelational -> LESSTHAN .)
    TRUE            reduce using rule 72 (opRelational -> LESSTHAN .)
    FALSE           reduce using rule 72 (opRelational -> LESSTHAN .)
    ID              reduce using rule 72 (opRelational -> LESSTHAN .)


state 150

    (73) opRelational -> LESSTHANEQ .

    OPAREN          reduce using rule 73 (opRelational -> LESSTHANEQ .)
    INT             reduce using rule 73 (opRelational -> LESSTHANEQ .)
    DEC             reduce using rule 73 (opRelational -> LESSTHANEQ .)
    STRING          reduce using rule 73 (opRelational -> LESSTHANEQ .)
    TRUE            reduce using rule 73 (opRelational -> LESSTHANEQ .)
    FALSE           reduce using rule 73 (opRelational -> LESSTHANEQ .)
    ID              reduce using rule 73 (opRelational -> LESSTHANEQ .)


state 151

    (74) plusMinus -> multDiv pointCheckPlusMinus .
    (75) plusMinus -> multDiv pointCheckPlusMinus . PLUS pointPushPlusMinus plusMinus
    (76) plusMinus -> multDiv pointCheckPlusMinus . MINUS pointPushPlusMinus plusMinus

    EQUAL           reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus .)
    DIFFERENT       reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus .)
    GREATERTHAN     reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus .)
    GREATERTHANEQ   reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus .)
    LESSTHAN        reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus .)
    LESSTHANEQ      reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus .)
    CPAREN          reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus .)
    EOF             reduce using rule 74 (plusMinus -> multDiv pointCheckPlusMinus .)
    PLUS            shift and go to state 181
    MINUS           shift and go to state 182


state 152

    (79) multDiv -> expParen pointCheckMultDiv .
    (80) multDiv -> expParen pointCheckMultDiv . MULTIPLY pointPushMultDiv multDiv
    (81) multDiv -> expParen pointCheckMultDiv . DIVIDE pointPushMultDiv multDiv

    PLUS            reduce using rule 79 (multDiv -> expParen pointCheckMultDiv .)
    MINUS           reduce using rule 79 (multDiv -> expParen pointCheckMultDiv .)
    EQUAL           reduce using rule 79 (multDiv -> expParen pointCheckMultDiv .)
    DIFFERENT       reduce using rule 79 (multDiv -> expParen pointCheckMultDiv .)
    GREATERTHAN     reduce using rule 79 (multDiv -> expParen pointCheckMultDiv .)
    GREATERTHANEQ   reduce using rule 79 (multDiv -> expParen pointCheckMultDiv .)
    LESSTHAN        reduce using rule 79 (multDiv -> expParen pointCheckMultDiv .)
    LESSTHANEQ      reduce using rule 79 (multDiv -> expParen pointCheckMultDiv .)
    CPAREN          reduce using rule 79 (multDiv -> expParen pointCheckMultDiv .)
    EOF             reduce using rule 79 (multDiv -> expParen pointCheckMultDiv .)
    MULTIPLY        shift and go to state 183
    DIVIDE          shift and go to state 184


state 153

    (99) varCte -> INT pointINT .

    MULTIPLY        reduce using rule 99 (varCte -> INT pointINT .)
    DIVIDE          reduce using rule 99 (varCte -> INT pointINT .)
    PLUS            reduce using rule 99 (varCte -> INT pointINT .)
    MINUS           reduce using rule 99 (varCte -> INT pointINT .)
    EQUAL           reduce using rule 99 (varCte -> INT pointINT .)
    DIFFERENT       reduce using rule 99 (varCte -> INT pointINT .)
    GREATERTHAN     reduce using rule 99 (varCte -> INT pointINT .)
    GREATERTHANEQ   reduce using rule 99 (varCte -> INT pointINT .)
    LESSTHAN        reduce using rule 99 (varCte -> INT pointINT .)
    LESSTHANEQ      reduce using rule 99 (varCte -> INT pointINT .)
    CPAREN          reduce using rule 99 (varCte -> INT pointINT .)
    EOF             reduce using rule 99 (varCte -> INT pointINT .)
    CSQUAREBR       reduce using rule 99 (varCte -> INT pointINT .)


state 154

    (100) varCte -> DEC pointDEC .

    MULTIPLY        reduce using rule 100 (varCte -> DEC pointDEC .)
    DIVIDE          reduce using rule 100 (varCte -> DEC pointDEC .)
    PLUS            reduce using rule 100 (varCte -> DEC pointDEC .)
    MINUS           reduce using rule 100 (varCte -> DEC pointDEC .)
    EQUAL           reduce using rule 100 (varCte -> DEC pointDEC .)
    DIFFERENT       reduce using rule 100 (varCte -> DEC pointDEC .)
    GREATERTHAN     reduce using rule 100 (varCte -> DEC pointDEC .)
    GREATERTHANEQ   reduce using rule 100 (varCte -> DEC pointDEC .)
    LESSTHAN        reduce using rule 100 (varCte -> DEC pointDEC .)
    LESSTHANEQ      reduce using rule 100 (varCte -> DEC pointDEC .)
    CPAREN          reduce using rule 100 (varCte -> DEC pointDEC .)
    EOF             reduce using rule 100 (varCte -> DEC pointDEC .)
    CSQUAREBR       reduce using rule 100 (varCte -> DEC pointDEC .)


state 155

    (101) varCte -> STRING pointSTRING .

    MULTIPLY        reduce using rule 101 (varCte -> STRING pointSTRING .)
    DIVIDE          reduce using rule 101 (varCte -> STRING pointSTRING .)
    PLUS            reduce using rule 101 (varCte -> STRING pointSTRING .)
    MINUS           reduce using rule 101 (varCte -> STRING pointSTRING .)
    EQUAL           reduce using rule 101 (varCte -> STRING pointSTRING .)
    DIFFERENT       reduce using rule 101 (varCte -> STRING pointSTRING .)
    GREATERTHAN     reduce using rule 101 (varCte -> STRING pointSTRING .)
    GREATERTHANEQ   reduce using rule 101 (varCte -> STRING pointSTRING .)
    LESSTHAN        reduce using rule 101 (varCte -> STRING pointSTRING .)
    LESSTHANEQ      reduce using rule 101 (varCte -> STRING pointSTRING .)
    CPAREN          reduce using rule 101 (varCte -> STRING pointSTRING .)
    EOF             reduce using rule 101 (varCte -> STRING pointSTRING .)
    CSQUAREBR       reduce using rule 101 (varCte -> STRING pointSTRING .)


state 156

    (102) varCte -> TRUE pointBOOL .

    MULTIPLY        reduce using rule 102 (varCte -> TRUE pointBOOL .)
    DIVIDE          reduce using rule 102 (varCte -> TRUE pointBOOL .)
    PLUS            reduce using rule 102 (varCte -> TRUE pointBOOL .)
    MINUS           reduce using rule 102 (varCte -> TRUE pointBOOL .)
    EQUAL           reduce using rule 102 (varCte -> TRUE pointBOOL .)
    DIFFERENT       reduce using rule 102 (varCte -> TRUE pointBOOL .)
    GREATERTHAN     reduce using rule 102 (varCte -> TRUE pointBOOL .)
    GREATERTHANEQ   reduce using rule 102 (varCte -> TRUE pointBOOL .)
    LESSTHAN        reduce using rule 102 (varCte -> TRUE pointBOOL .)
    LESSTHANEQ      reduce using rule 102 (varCte -> TRUE pointBOOL .)
    CPAREN          reduce using rule 102 (varCte -> TRUE pointBOOL .)
    EOF             reduce using rule 102 (varCte -> TRUE pointBOOL .)
    CSQUAREBR       reduce using rule 102 (varCte -> TRUE pointBOOL .)


state 157

    (103) varCte -> FALSE pointBOOL .

    MULTIPLY        reduce using rule 103 (varCte -> FALSE pointBOOL .)
    DIVIDE          reduce using rule 103 (varCte -> FALSE pointBOOL .)
    PLUS            reduce using rule 103 (varCte -> FALSE pointBOOL .)
    MINUS           reduce using rule 103 (varCte -> FALSE pointBOOL .)
    EQUAL           reduce using rule 103 (varCte -> FALSE pointBOOL .)
    DIFFERENT       reduce using rule 103 (varCte -> FALSE pointBOOL .)
    GREATERTHAN     reduce using rule 103 (varCte -> FALSE pointBOOL .)
    GREATERTHANEQ   reduce using rule 103 (varCte -> FALSE pointBOOL .)
    LESSTHAN        reduce using rule 103 (varCte -> FALSE pointBOOL .)
    LESSTHANEQ      reduce using rule 103 (varCte -> FALSE pointBOOL .)
    CPAREN          reduce using rule 103 (varCte -> FALSE pointBOOL .)
    EOF             reduce using rule 103 (varCte -> FALSE pointBOOL .)
    CSQUAREBR       reduce using rule 103 (varCte -> FALSE pointBOOL .)


state 158

    (109) whileCycle -> WHILE pointWhile1 OPAREN expRelational . CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3

    CPAREN          shift and go to state 185


state 159

    (113) ifCond -> IF OPAREN expRelational CPAREN . pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> IF OPAREN expRelational CPAREN . pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (115) pointIfCond1 -> .

    OBRACKET        reduce using rule 115 (pointIfCond1 -> .)

    pointIfCond1                   shift and go to state 186

state 160

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET . body CBRACKET pointEndFunc fxDef
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (121) epsilon -> .
    (57) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (118) input -> . INPUT OPAREN ID CPAREN EOF
    (119) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (109) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (113) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (96) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 121 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 187
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 161

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET . body CBRACKET pointEndFunc fxDef
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (121) epsilon -> .
    (57) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (118) input -> . INPUT OPAREN ID CPAREN EOF
    (119) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (109) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (113) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (96) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 121 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    epsilon                        shift and go to state 48
    body                           shift and go to state 188
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 162

    (20) param -> paramType ID pointParam COMMA . param
    (19) param -> . paramType ID pointParam
    (20) param -> . paramType ID pointParam COMMA param
    (21) paramType -> . INT
    (22) paramType -> . STRING
    (23) paramType -> . DEC
    (24) paramType -> . BOOL

    INT             shift and go to state 65
    STRING          shift and go to state 66
    DEC             shift and go to state 67
    BOOL            shift and go to state 68

    paramType                      shift and go to state 64
    param                          shift and go to state 189

state 163

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET . body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (121) epsilon -> .
    (57) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (118) input -> . INPUT OPAREN ID CPAREN EOF
    (119) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (109) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (113) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (96) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    RETURN          reduce using rule 121 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 190
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 164

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET . body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (121) epsilon -> .
    (57) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (118) input -> . INPUT OPAREN ID CPAREN EOF
    (119) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (109) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (113) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (96) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    RETURN          reduce using rule 121 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    epsilon                        shift and go to state 48
    body                           shift and go to state 191
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 165

    (88) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass . fxDef pointScopeClass2 CBRACKET classDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (121) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    CBRACKET        reduce using rule 121 (epsilon -> .)

    fxDef                          shift and go to state 192
    epsilon                        shift and go to state 12
    fxType                         shift and go to state 13

state 166

    (51) var -> varsType COMMA var .

    EOF             reduce using rule 51 (var -> varsType COMMA var .)


state 167

    (55) arrDef -> ID OSQUAREBR varCte . CSQUAREBR

    CSQUAREBR       shift and go to state 193


state 168

    (56) matrixDef -> arrDef OSQUAREBR varCte . CSQUAREBR

    CSQUAREBR       shift and go to state 194


state 169

    (62) returnCall -> ID pointEra . OPAREN paramCall pointGoSub CPAREN
    (63) returnCall -> ID pointEra . OPAREN epsilon pointParamVacio pointGoSub CPAREN

    OPAREN          shift and go to state 195


state 170

    (59) expAssignment -> expRelational EOF .

    VAR             reduce using rule 59 (expAssignment -> expRelational EOF .)
    ID              reduce using rule 59 (expAssignment -> expRelational EOF .)
    INPUT           reduce using rule 59 (expAssignment -> expRelational EOF .)
    OUTPUT          reduce using rule 59 (expAssignment -> expRelational EOF .)
    WHILE           reduce using rule 59 (expAssignment -> expRelational EOF .)
    IF              reduce using rule 59 (expAssignment -> expRelational EOF .)
    CBRACKET        reduce using rule 59 (expAssignment -> expRelational EOF .)
    RETURN          reduce using rule 59 (expAssignment -> expRelational EOF .)


state 171

    (60) expAssignment -> returnCall EOF .

    VAR             reduce using rule 60 (expAssignment -> returnCall EOF .)
    ID              reduce using rule 60 (expAssignment -> returnCall EOF .)
    INPUT           reduce using rule 60 (expAssignment -> returnCall EOF .)
    OUTPUT          reduce using rule 60 (expAssignment -> returnCall EOF .)
    WHILE           reduce using rule 60 (expAssignment -> returnCall EOF .)
    IF              reduce using rule 60 (expAssignment -> returnCall EOF .)
    CBRACKET        reduce using rule 60 (expAssignment -> returnCall EOF .)
    RETURN          reduce using rule 60 (expAssignment -> returnCall EOF .)


state 172

    (26) paramCall -> ID pointParamCall . pointParamNum
    (27) paramCall -> ID pointParamCall . COMMA paramCall
    (28) pointParamNum -> .

    COMMA           shift and go to state 197
    CPAREN          reduce using rule 28 (pointParamNum -> .)

    pointParamNum                  shift and go to state 196

state 173

    (30) voidCall -> ID pointEra OPAREN paramCall pointGoSub . CPAREN EOF

    CPAREN          shift and go to state 198


state 174

    (31) voidCall -> ID pointEra OPAREN epsilon pointParamVacio . pointGoSub CPAREN EOF
    (33) pointGoSub -> .

    CPAREN          reduce using rule 33 (pointGoSub -> .)

    pointGoSub                     shift and go to state 199

state 175

    (96) classCall -> ID MONEY ID OPAREN paramCall . CPAREN EOF

    CPAREN          shift and go to state 200


state 176

    (97) classCall -> ID MONEY ID OPAREN epsilon . CPAREN EOF

    CPAREN          shift and go to state 201


state 177

    (118) input -> INPUT OPAREN ID CPAREN EOF .

    VAR             reduce using rule 118 (input -> INPUT OPAREN ID CPAREN EOF .)
    ID              reduce using rule 118 (input -> INPUT OPAREN ID CPAREN EOF .)
    INPUT           reduce using rule 118 (input -> INPUT OPAREN ID CPAREN EOF .)
    OUTPUT          reduce using rule 118 (input -> INPUT OPAREN ID CPAREN EOF .)
    WHILE           reduce using rule 118 (input -> INPUT OPAREN ID CPAREN EOF .)
    IF              reduce using rule 118 (input -> INPUT OPAREN ID CPAREN EOF .)
    CBRACKET        reduce using rule 118 (input -> INPUT OPAREN ID CPAREN EOF .)
    RETURN          reduce using rule 118 (input -> INPUT OPAREN ID CPAREN EOF .)


state 178

    (84) expParen -> OPAREN pointFakeBackground expRelational . CPAREN pointRemoveFakeBackground

    CPAREN          shift and go to state 202


state 179

    (119) output -> OUTPUT OPAREN expRelational CPAREN EOF .

    VAR             reduce using rule 119 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    ID              reduce using rule 119 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    INPUT           reduce using rule 119 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    OUTPUT          reduce using rule 119 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    WHILE           reduce using rule 119 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    IF              reduce using rule 119 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    CBRACKET        reduce using rule 119 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)
    RETURN          reduce using rule 119 (output -> OUTPUT OPAREN expRelational CPAREN EOF .)


state 180

    (66) expRelational -> plusMinus opRelational expRelational . pointCheckOpRel
    (67) pointCheckOpRel -> .

    CPAREN          reduce using rule 67 (pointCheckOpRel -> .)
    EOF             reduce using rule 67 (pointCheckOpRel -> .)

    pointCheckOpRel                shift and go to state 203

state 181

    (75) plusMinus -> multDiv pointCheckPlusMinus PLUS . pointPushPlusMinus plusMinus
    (78) pointPushPlusMinus -> .

    OPAREN          reduce using rule 78 (pointPushPlusMinus -> .)
    INT             reduce using rule 78 (pointPushPlusMinus -> .)
    DEC             reduce using rule 78 (pointPushPlusMinus -> .)
    STRING          reduce using rule 78 (pointPushPlusMinus -> .)
    TRUE            reduce using rule 78 (pointPushPlusMinus -> .)
    FALSE           reduce using rule 78 (pointPushPlusMinus -> .)
    ID              reduce using rule 78 (pointPushPlusMinus -> .)

    pointPushPlusMinus             shift and go to state 204

state 182

    (76) plusMinus -> multDiv pointCheckPlusMinus MINUS . pointPushPlusMinus plusMinus
    (78) pointPushPlusMinus -> .

    OPAREN          reduce using rule 78 (pointPushPlusMinus -> .)
    INT             reduce using rule 78 (pointPushPlusMinus -> .)
    DEC             reduce using rule 78 (pointPushPlusMinus -> .)
    STRING          reduce using rule 78 (pointPushPlusMinus -> .)
    TRUE            reduce using rule 78 (pointPushPlusMinus -> .)
    FALSE           reduce using rule 78 (pointPushPlusMinus -> .)
    ID              reduce using rule 78 (pointPushPlusMinus -> .)

    pointPushPlusMinus             shift and go to state 205

state 183

    (80) multDiv -> expParen pointCheckMultDiv MULTIPLY . pointPushMultDiv multDiv
    (83) pointPushMultDiv -> .

    OPAREN          reduce using rule 83 (pointPushMultDiv -> .)
    INT             reduce using rule 83 (pointPushMultDiv -> .)
    DEC             reduce using rule 83 (pointPushMultDiv -> .)
    STRING          reduce using rule 83 (pointPushMultDiv -> .)
    TRUE            reduce using rule 83 (pointPushMultDiv -> .)
    FALSE           reduce using rule 83 (pointPushMultDiv -> .)
    ID              reduce using rule 83 (pointPushMultDiv -> .)

    pointPushMultDiv               shift and go to state 206

state 184

    (81) multDiv -> expParen pointCheckMultDiv DIVIDE . pointPushMultDiv multDiv
    (83) pointPushMultDiv -> .

    OPAREN          reduce using rule 83 (pointPushMultDiv -> .)
    INT             reduce using rule 83 (pointPushMultDiv -> .)
    DEC             reduce using rule 83 (pointPushMultDiv -> .)
    STRING          reduce using rule 83 (pointPushMultDiv -> .)
    TRUE            reduce using rule 83 (pointPushMultDiv -> .)
    FALSE           reduce using rule 83 (pointPushMultDiv -> .)
    ID              reduce using rule 83 (pointPushMultDiv -> .)

    pointPushMultDiv               shift and go to state 207

state 185

    (109) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN . pointWhile2 OBRACKET body CBRACKET pointWhile3
    (111) pointWhile2 -> .

    OBRACKET        reduce using rule 111 (pointWhile2 -> .)

    pointWhile2                    shift and go to state 208

state 186

    (113) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 . OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 . OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    OBRACKET        shift and go to state 209


state 187

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 210


state 188

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 211


state 189

    (20) param -> paramType ID pointParam COMMA param .

    CPAREN          reduce using rule 20 (param -> paramType ID pointParam COMMA param .)


state 190

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body . RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    RETURN          shift and go to state 212


state 191

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body . RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef

    RETURN          shift and go to state 213


state 192

    (88) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef . pointScopeClass2 CBRACKET classDef
    (93) pointScopeClass2 -> .

    CBRACKET        reduce using rule 93 (pointScopeClass2 -> .)

    pointScopeClass2               shift and go to state 214

state 193

    (55) arrDef -> ID OSQUAREBR varCte CSQUAREBR .

    OSQUAREBR       reduce using rule 55 (arrDef -> ID OSQUAREBR varCte CSQUAREBR .)
    COMMA           reduce using rule 55 (arrDef -> ID OSQUAREBR varCte CSQUAREBR .)
    EOF             reduce using rule 55 (arrDef -> ID OSQUAREBR varCte CSQUAREBR .)


state 194

    (56) matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR .

    COMMA           reduce using rule 56 (matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR .)
    EOF             reduce using rule 56 (matrixDef -> arrDef OSQUAREBR varCte CSQUAREBR .)


state 195

    (62) returnCall -> ID pointEra OPAREN . paramCall pointGoSub CPAREN
    (63) returnCall -> ID pointEra OPAREN . epsilon pointParamVacio pointGoSub CPAREN
    (26) paramCall -> . ID pointParamCall pointParamNum
    (27) paramCall -> . ID pointParamCall COMMA paramCall
    (121) epsilon -> .

    ID              shift and go to state 137
    CPAREN          reduce using rule 121 (epsilon -> .)

    paramCall                      shift and go to state 215
    epsilon                        shift and go to state 216

state 196

    (26) paramCall -> ID pointParamCall pointParamNum .

    CPAREN          reduce using rule 26 (paramCall -> ID pointParamCall pointParamNum .)


state 197

    (27) paramCall -> ID pointParamCall COMMA . paramCall
    (26) paramCall -> . ID pointParamCall pointParamNum
    (27) paramCall -> . ID pointParamCall COMMA paramCall

    ID              shift and go to state 137

    paramCall                      shift and go to state 217

state 198

    (30) voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN . EOF

    EOF             shift and go to state 218


state 199

    (31) voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub . CPAREN EOF

    CPAREN          shift and go to state 219


state 200

    (96) classCall -> ID MONEY ID OPAREN paramCall CPAREN . EOF

    EOF             shift and go to state 220


state 201

    (97) classCall -> ID MONEY ID OPAREN epsilon CPAREN . EOF

    EOF             shift and go to state 221


state 202

    (84) expParen -> OPAREN pointFakeBackground expRelational CPAREN . pointRemoveFakeBackground
    (87) pointRemoveFakeBackground -> .

    MULTIPLY        reduce using rule 87 (pointRemoveFakeBackground -> .)
    DIVIDE          reduce using rule 87 (pointRemoveFakeBackground -> .)
    PLUS            reduce using rule 87 (pointRemoveFakeBackground -> .)
    MINUS           reduce using rule 87 (pointRemoveFakeBackground -> .)
    EQUAL           reduce using rule 87 (pointRemoveFakeBackground -> .)
    DIFFERENT       reduce using rule 87 (pointRemoveFakeBackground -> .)
    GREATERTHAN     reduce using rule 87 (pointRemoveFakeBackground -> .)
    GREATERTHANEQ   reduce using rule 87 (pointRemoveFakeBackground -> .)
    LESSTHAN        reduce using rule 87 (pointRemoveFakeBackground -> .)
    LESSTHANEQ      reduce using rule 87 (pointRemoveFakeBackground -> .)
    CPAREN          reduce using rule 87 (pointRemoveFakeBackground -> .)
    EOF             reduce using rule 87 (pointRemoveFakeBackground -> .)

    pointRemoveFakeBackground      shift and go to state 222

state 203

    (66) expRelational -> plusMinus opRelational expRelational pointCheckOpRel .

    CPAREN          reduce using rule 66 (expRelational -> plusMinus opRelational expRelational pointCheckOpRel .)
    EOF             reduce using rule 66 (expRelational -> plusMinus opRelational expRelational pointCheckOpRel .)


state 204

    (75) plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus . plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus
    (75) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (76) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (79) multDiv -> . expParen pointCheckMultDiv
    (80) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (81) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (84) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (85) expParen -> . varCte
    (99) varCte -> . INT pointINT
    (100) varCte -> . DEC pointDEC
    (101) varCte -> . STRING pointSTRING
    (102) varCte -> . TRUE pointBOOL
    (103) varCte -> . FALSE pointBOOL
    (104) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    multDiv                        shift and go to state 110
    plusMinus                      shift and go to state 223
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 205

    (76) plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus . plusMinus
    (74) plusMinus -> . multDiv pointCheckPlusMinus
    (75) plusMinus -> . multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus
    (76) plusMinus -> . multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus
    (79) multDiv -> . expParen pointCheckMultDiv
    (80) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (81) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (84) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (85) expParen -> . varCte
    (99) varCte -> . INT pointINT
    (100) varCte -> . DEC pointDEC
    (101) varCte -> . STRING pointSTRING
    (102) varCte -> . TRUE pointBOOL
    (103) varCte -> . FALSE pointBOOL
    (104) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    multDiv                        shift and go to state 110
    plusMinus                      shift and go to state 224
    expParen                       shift and go to state 111
    varCte                         shift and go to state 112

state 206

    (80) multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv . multDiv
    (79) multDiv -> . expParen pointCheckMultDiv
    (80) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (81) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (84) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (85) expParen -> . varCte
    (99) varCte -> . INT pointINT
    (100) varCte -> . DEC pointDEC
    (101) varCte -> . STRING pointSTRING
    (102) varCte -> . TRUE pointBOOL
    (103) varCte -> . FALSE pointBOOL
    (104) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    expParen                       shift and go to state 111
    multDiv                        shift and go to state 225
    varCte                         shift and go to state 112

state 207

    (81) multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv . multDiv
    (79) multDiv -> . expParen pointCheckMultDiv
    (80) multDiv -> . expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv
    (81) multDiv -> . expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv
    (84) expParen -> . OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground
    (85) expParen -> . varCte
    (99) varCte -> . INT pointINT
    (100) varCte -> . DEC pointDEC
    (101) varCte -> . STRING pointSTRING
    (102) varCte -> . TRUE pointBOOL
    (103) varCte -> . FALSE pointBOOL
    (104) varCte -> . ID

    OPAREN          shift and go to state 107
    INT             shift and go to state 113
    DEC             shift and go to state 114
    STRING          shift and go to state 115
    TRUE            shift and go to state 116
    FALSE           shift and go to state 117
    ID              shift and go to state 118

    expParen                       shift and go to state 111
    multDiv                        shift and go to state 226
    varCte                         shift and go to state 112

state 208

    (109) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 . OBRACKET body CBRACKET pointWhile3

    OBRACKET        shift and go to state 227


state 209

    (113) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET . body CBRACKET pointIfCond2
    (114) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET . body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (121) epsilon -> .
    (57) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (118) input -> . INPUT OPAREN ID CPAREN EOF
    (119) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (109) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (113) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (96) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 121 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 228
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 210

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET . pointEndFunc fxDef
    (18) pointEndFunc -> .

    VOID            reduce using rule 18 (pointEndFunc -> .)
    INT             reduce using rule 18 (pointEndFunc -> .)
    STRING          reduce using rule 18 (pointEndFunc -> .)
    DEC             reduce using rule 18 (pointEndFunc -> .)
    BOOL            reduce using rule 18 (pointEndFunc -> .)
    MAIN            reduce using rule 18 (pointEndFunc -> .)
    CBRACKET        reduce using rule 18 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 229

state 211

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET . pointEndFunc fxDef
    (18) pointEndFunc -> .

    VOID            reduce using rule 18 (pointEndFunc -> .)
    INT             reduce using rule 18 (pointEndFunc -> .)
    STRING          reduce using rule 18 (pointEndFunc -> .)
    DEC             reduce using rule 18 (pointEndFunc -> .)
    BOOL            reduce using rule 18 (pointEndFunc -> .)
    MAIN            reduce using rule 18 (pointEndFunc -> .)
    CBRACKET        reduce using rule 18 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 230

state 212

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN . ID pointReturn EOF CBRACKET pointEndFunc fxDef

    ID              shift and go to state 231


state 213

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN . ID pointReturn EOF CBRACKET pointEndFunc fxDef

    ID              shift and go to state 232


state 214

    (88) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 . CBRACKET classDef

    CBRACKET        shift and go to state 233


state 215

    (62) returnCall -> ID pointEra OPAREN paramCall . pointGoSub CPAREN
    (33) pointGoSub -> .

    CPAREN          reduce using rule 33 (pointGoSub -> .)

    pointGoSub                     shift and go to state 234

state 216

    (63) returnCall -> ID pointEra OPAREN epsilon . pointParamVacio pointGoSub CPAREN
    (64) pointParamVacio -> .

    CPAREN          reduce using rule 64 (pointParamVacio -> .)

    pointParamVacio                shift and go to state 235

state 217

    (27) paramCall -> ID pointParamCall COMMA paramCall .

    CPAREN          reduce using rule 27 (paramCall -> ID pointParamCall COMMA paramCall .)


state 218

    (30) voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .

    VAR             reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    ID              reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    INPUT           reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    OUTPUT          reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    WHILE           reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    IF              reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    CBRACKET        reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)
    RETURN          reduce using rule 30 (voidCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN EOF .)


state 219

    (31) voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN . EOF

    EOF             shift and go to state 236


state 220

    (96) classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .

    VAR             reduce using rule 96 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    ID              reduce using rule 96 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    INPUT           reduce using rule 96 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    OUTPUT          reduce using rule 96 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    WHILE           reduce using rule 96 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    IF              reduce using rule 96 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    CBRACKET        reduce using rule 96 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)
    RETURN          reduce using rule 96 (classCall -> ID MONEY ID OPAREN paramCall CPAREN EOF .)


state 221

    (97) classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .

    VAR             reduce using rule 97 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    ID              reduce using rule 97 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    INPUT           reduce using rule 97 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    OUTPUT          reduce using rule 97 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    WHILE           reduce using rule 97 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    IF              reduce using rule 97 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    CBRACKET        reduce using rule 97 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)
    RETURN          reduce using rule 97 (classCall -> ID MONEY ID OPAREN epsilon CPAREN EOF .)


state 222

    (84) expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .

    MULTIPLY        reduce using rule 84 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    DIVIDE          reduce using rule 84 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    PLUS            reduce using rule 84 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    MINUS           reduce using rule 84 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    EQUAL           reduce using rule 84 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    DIFFERENT       reduce using rule 84 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    GREATERTHAN     reduce using rule 84 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    GREATERTHANEQ   reduce using rule 84 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    LESSTHAN        reduce using rule 84 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    LESSTHANEQ      reduce using rule 84 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    CPAREN          reduce using rule 84 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)
    EOF             reduce using rule 84 (expParen -> OPAREN pointFakeBackground expRelational CPAREN pointRemoveFakeBackground .)


state 223

    (75) plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .

    EQUAL           reduce using rule 75 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    DIFFERENT       reduce using rule 75 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    GREATERTHAN     reduce using rule 75 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    GREATERTHANEQ   reduce using rule 75 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    LESSTHAN        reduce using rule 75 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    LESSTHANEQ      reduce using rule 75 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    CPAREN          reduce using rule 75 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)
    EOF             reduce using rule 75 (plusMinus -> multDiv pointCheckPlusMinus PLUS pointPushPlusMinus plusMinus .)


state 224

    (76) plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .

    EQUAL           reduce using rule 76 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    DIFFERENT       reduce using rule 76 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    GREATERTHAN     reduce using rule 76 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    GREATERTHANEQ   reduce using rule 76 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    LESSTHAN        reduce using rule 76 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    LESSTHANEQ      reduce using rule 76 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    CPAREN          reduce using rule 76 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)
    EOF             reduce using rule 76 (plusMinus -> multDiv pointCheckPlusMinus MINUS pointPushPlusMinus plusMinus .)


state 225

    (80) multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .

    PLUS            reduce using rule 80 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    MINUS           reduce using rule 80 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    EQUAL           reduce using rule 80 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    DIFFERENT       reduce using rule 80 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    GREATERTHAN     reduce using rule 80 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    GREATERTHANEQ   reduce using rule 80 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    LESSTHAN        reduce using rule 80 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    LESSTHANEQ      reduce using rule 80 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    CPAREN          reduce using rule 80 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)
    EOF             reduce using rule 80 (multDiv -> expParen pointCheckMultDiv MULTIPLY pointPushMultDiv multDiv .)


state 226

    (81) multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .

    PLUS            reduce using rule 81 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    MINUS           reduce using rule 81 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    EQUAL           reduce using rule 81 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    DIFFERENT       reduce using rule 81 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    GREATERTHAN     reduce using rule 81 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    GREATERTHANEQ   reduce using rule 81 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    LESSTHAN        reduce using rule 81 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    LESSTHANEQ      reduce using rule 81 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    CPAREN          reduce using rule 81 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)
    EOF             reduce using rule 81 (multDiv -> expParen pointCheckMultDiv DIVIDE pointPushMultDiv multDiv .)


state 227

    (109) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET . body CBRACKET pointWhile3
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (121) epsilon -> .
    (57) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (118) input -> . INPUT OPAREN ID CPAREN EOF
    (119) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (109) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (113) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (96) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 121 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 237
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 228

    (113) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body . CBRACKET pointIfCond2
    (114) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body . CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2

    CBRACKET        shift and go to state 238


state 229

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (121) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 121 (epsilon -> .)
    CBRACKET        reduce using rule 121 (epsilon -> .)

    fxDef                          shift and go to state 239
    epsilon                        shift and go to state 12
    fxType                         shift and go to state 13

state 230

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (121) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 121 (epsilon -> .)
    CBRACKET        reduce using rule 121 (epsilon -> .)

    epsilon                        shift and go to state 12
    fxDef                          shift and go to state 240
    fxType                         shift and go to state 13

state 231

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID . pointReturn EOF CBRACKET pointEndFunc fxDef
    (16) pointReturn -> .

    EOF             reduce using rule 16 (pointReturn -> .)

    pointReturn                    shift and go to state 241

state 232

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID . pointReturn EOF CBRACKET pointEndFunc fxDef
    (16) pointReturn -> .

    EOF             reduce using rule 16 (pointReturn -> .)

    pointReturn                    shift and go to state 242

state 233

    (88) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET . classDef
    (88) classDef -> . CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef
    (89) classDef -> . epsilon
    (121) epsilon -> .

    CLASS           shift and go to state 8
    VOID            reduce using rule 121 (epsilon -> .)
    INT             reduce using rule 121 (epsilon -> .)
    STRING          reduce using rule 121 (epsilon -> .)
    DEC             reduce using rule 121 (epsilon -> .)
    BOOL            reduce using rule 121 (epsilon -> .)
    MAIN            reduce using rule 121 (epsilon -> .)

    classDef                       shift and go to state 243
    epsilon                        shift and go to state 9

state 234

    (62) returnCall -> ID pointEra OPAREN paramCall pointGoSub . CPAREN

    CPAREN          shift and go to state 244


state 235

    (63) returnCall -> ID pointEra OPAREN epsilon pointParamVacio . pointGoSub CPAREN
    (33) pointGoSub -> .

    CPAREN          reduce using rule 33 (pointGoSub -> .)

    pointGoSub                     shift and go to state 245

state 236

    (31) voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .

    VAR             reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    ID              reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    INPUT           reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    OUTPUT          reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    WHILE           reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    IF              reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    CBRACKET        reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)
    RETURN          reduce using rule 31 (voidCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF .)


state 237

    (109) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body . CBRACKET pointWhile3

    CBRACKET        shift and go to state 246


state 238

    (113) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET . pointIfCond2
    (114) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET . ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (116) pointIfCond2 -> .

    ELSE            shift and go to state 248
    VAR             reduce using rule 116 (pointIfCond2 -> .)
    ID              reduce using rule 116 (pointIfCond2 -> .)
    INPUT           reduce using rule 116 (pointIfCond2 -> .)
    OUTPUT          reduce using rule 116 (pointIfCond2 -> .)
    WHILE           reduce using rule 116 (pointIfCond2 -> .)
    IF              reduce using rule 116 (pointIfCond2 -> .)
    CBRACKET        reduce using rule 116 (pointIfCond2 -> .)
    RETURN          reduce using rule 116 (pointIfCond2 -> .)

    pointIfCond2                   shift and go to state 247

state 239

    (5) fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 5 (fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 5 (fxDef -> VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef .)


state 240

    (6) fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 6 (fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 6 (fxDef -> VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef .)


state 241

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn . EOF CBRACKET pointEndFunc fxDef

    EOF             shift and go to state 249


state 242

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn . EOF CBRACKET pointEndFunc fxDef

    EOF             shift and go to state 250


state 243

    (88) classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .

    VOID            reduce using rule 88 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    INT             reduce using rule 88 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    STRING          reduce using rule 88 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    DEC             reduce using rule 88 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    BOOL            reduce using rule 88 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)
    MAIN            reduce using rule 88 (classDef -> CLASS pointClass ID pointClassName OBRACKET ATTRIBUTES COLON pointAtt METHODS COLON pointScopeClass fxDef pointScopeClass2 CBRACKET classDef .)


state 244

    (62) returnCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN .

    EOF             reduce using rule 62 (returnCall -> ID pointEra OPAREN paramCall pointGoSub CPAREN .)


state 245

    (63) returnCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub . CPAREN

    CPAREN          shift and go to state 251


state 246

    (109) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET . pointWhile3
    (112) pointWhile3 -> .

    VAR             reduce using rule 112 (pointWhile3 -> .)
    ID              reduce using rule 112 (pointWhile3 -> .)
    INPUT           reduce using rule 112 (pointWhile3 -> .)
    OUTPUT          reduce using rule 112 (pointWhile3 -> .)
    WHILE           reduce using rule 112 (pointWhile3 -> .)
    IF              reduce using rule 112 (pointWhile3 -> .)
    CBRACKET        reduce using rule 112 (pointWhile3 -> .)
    RETURN          reduce using rule 112 (pointWhile3 -> .)

    pointWhile3                    shift and go to state 252

state 247

    (113) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .

    VAR             reduce using rule 113 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    ID              reduce using rule 113 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    INPUT           reduce using rule 113 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    OUTPUT          reduce using rule 113 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    WHILE           reduce using rule 113 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    IF              reduce using rule 113 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    CBRACKET        reduce using rule 113 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)
    RETURN          reduce using rule 113 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2 .)


state 248

    (114) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE . pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (117) pointIfCond3 -> .

    OBRACKET        reduce using rule 117 (pointIfCond3 -> .)

    pointIfCond3                   shift and go to state 253

state 249

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 254


state 250

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF . CBRACKET pointEndFunc fxDef

    CBRACKET        shift and go to state 255


state 251

    (63) returnCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN .

    EOF             reduce using rule 63 (returnCall -> ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN .)


state 252

    (109) whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .

    VAR             reduce using rule 109 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    ID              reduce using rule 109 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    INPUT           reduce using rule 109 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    OUTPUT          reduce using rule 109 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    WHILE           reduce using rule 109 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    IF              reduce using rule 109 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    CBRACKET        reduce using rule 109 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)
    RETURN          reduce using rule 109 (whileCycle -> WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3 .)


state 253

    (114) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 . OBRACKET body CBRACKET pointIfCond2

    OBRACKET        shift and go to state 256


state 254

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET . pointEndFunc fxDef
    (18) pointEndFunc -> .

    VOID            reduce using rule 18 (pointEndFunc -> .)
    INT             reduce using rule 18 (pointEndFunc -> .)
    STRING          reduce using rule 18 (pointEndFunc -> .)
    DEC             reduce using rule 18 (pointEndFunc -> .)
    BOOL            reduce using rule 18 (pointEndFunc -> .)
    MAIN            reduce using rule 18 (pointEndFunc -> .)
    CBRACKET        reduce using rule 18 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 257

state 255

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET . pointEndFunc fxDef
    (18) pointEndFunc -> .

    VOID            reduce using rule 18 (pointEndFunc -> .)
    INT             reduce using rule 18 (pointEndFunc -> .)
    STRING          reduce using rule 18 (pointEndFunc -> .)
    DEC             reduce using rule 18 (pointEndFunc -> .)
    BOOL            reduce using rule 18 (pointEndFunc -> .)
    MAIN            reduce using rule 18 (pointEndFunc -> .)
    CBRACKET        reduce using rule 18 (pointEndFunc -> .)

    pointEndFunc                   shift and go to state 258

state 256

    (114) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET . body CBRACKET pointIfCond2
    (34) body -> . varsDef body
    (35) body -> . statements body
    (36) body -> . epsilon
    (44) varsDef -> . VAR objType var EOF
    (45) varsDef -> . VAR varSimpleType var EOF
    (37) statements -> . assignmentDef
    (38) statements -> . input
    (39) statements -> . output
    (40) statements -> . voidCall
    (41) statements -> . whileCycle
    (42) statements -> . ifCond
    (43) statements -> . classCall
    (121) epsilon -> .
    (57) assignmentDef -> . ID ASSIGNMENT pointPushAssignment expAssignment
    (118) input -> . INPUT OPAREN ID CPAREN EOF
    (119) output -> . OUTPUT OPAREN expRelational CPAREN EOF
    (30) voidCall -> . ID pointEra OPAREN paramCall pointGoSub CPAREN EOF
    (31) voidCall -> . ID pointEra OPAREN epsilon pointParamVacio pointGoSub CPAREN EOF
    (109) whileCycle -> . WHILE pointWhile1 OPAREN expRelational CPAREN pointWhile2 OBRACKET body CBRACKET pointWhile3
    (113) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET pointIfCond2
    (114) ifCond -> . IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2
    (96) classCall -> . ID MONEY ID OPAREN paramCall CPAREN EOF
    (97) classCall -> . ID MONEY ID OPAREN epsilon CPAREN EOF

    VAR             shift and go to state 49
    CBRACKET        reduce using rule 121 (epsilon -> .)
    ID              shift and go to state 57
    INPUT           shift and go to state 58
    OUTPUT          shift and go to state 59
    WHILE           shift and go to state 60
    IF              shift and go to state 61

    body                           shift and go to state 259
    varsDef                        shift and go to state 46
    statements                     shift and go to state 47
    epsilon                        shift and go to state 48
    assignmentDef                  shift and go to state 50
    input                          shift and go to state 51
    output                         shift and go to state 52
    voidCall                       shift and go to state 53
    whileCycle                     shift and go to state 54
    ifCond                         shift and go to state 55
    classCall                      shift and go to state 56

state 257

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (121) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 121 (epsilon -> .)
    CBRACKET        reduce using rule 121 (epsilon -> .)

    fxType                         shift and go to state 13
    fxDef                          shift and go to state 260
    epsilon                        shift and go to state 12

state 258

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc . fxDef
    (5) fxDef -> . VOID FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (6) fxDef -> . VOID FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body CBRACKET pointEndFunc fxDef
    (7) fxDef -> . fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (8) fxDef -> . fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef
    (9) fxDef -> . epsilon
    (10) fxType -> . INT
    (11) fxType -> . STRING
    (12) fxType -> . DEC
    (13) fxType -> . BOOL
    (121) epsilon -> .

    VOID            shift and go to state 11
    INT             shift and go to state 14
    STRING          shift and go to state 15
    DEC             shift and go to state 16
    BOOL            shift and go to state 17
    MAIN            reduce using rule 121 (epsilon -> .)
    CBRACKET        reduce using rule 121 (epsilon -> .)

    fxType                         shift and go to state 13
    epsilon                        shift and go to state 12
    fxDef                          shift and go to state 261

state 259

    (114) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body . CBRACKET pointIfCond2

    CBRACKET        shift and go to state 262


state 260

    (7) fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 7 (fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 7 (fxDef -> fxType FX pointFx ID pointFxId OPAREN param CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)


state 261

    (8) fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .

    MAIN            reduce using rule 8 (fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)
    CBRACKET        reduce using rule 8 (fxDef -> fxType FX pointFx ID pointFxId OPAREN epsilon CPAREN pointParamCount OBRACKET body RETURN ID pointReturn EOF CBRACKET pointEndFunc fxDef .)


state 262

    (114) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET . pointIfCond2
    (116) pointIfCond2 -> .

    VAR             reduce using rule 116 (pointIfCond2 -> .)
    ID              reduce using rule 116 (pointIfCond2 -> .)
    INPUT           reduce using rule 116 (pointIfCond2 -> .)
    OUTPUT          reduce using rule 116 (pointIfCond2 -> .)
    WHILE           reduce using rule 116 (pointIfCond2 -> .)
    IF              reduce using rule 116 (pointIfCond2 -> .)
    CBRACKET        reduce using rule 116 (pointIfCond2 -> .)
    RETURN          reduce using rule 116 (pointIfCond2 -> .)

    pointIfCond2                   shift and go to state 263

state 263

    (114) ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .

    VAR             reduce using rule 114 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    ID              reduce using rule 114 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    INPUT           reduce using rule 114 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    OUTPUT          reduce using rule 114 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    WHILE           reduce using rule 114 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    IF              reduce using rule 114 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    CBRACKET        reduce using rule 114 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)
    RETURN          reduce using rule 114 (ifCond -> IF OPAREN expRelational CPAREN pointIfCond1 OBRACKET body CBRACKET ELSE pointIfCond3 OBRACKET body CBRACKET pointIfCond2 .)

